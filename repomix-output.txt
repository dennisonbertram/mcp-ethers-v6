This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-16T21:25:37.068Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
artifacts/
  build-info/
    a41376ba4fdfb875b722abb085e468b4.json
  contracts/
    TestToken.sol/
      TestToken.dbg.json
      TestToken.json
cache/
  solidity-files-cache.json
contracts/
  TestToken.sol
examples/
  erc-standards.ts
src/
  config/
    config.ts
    networkList.ts
    networks.ts
  services/
    erc/
      constants.ts
      erc1155.test.ts.md
      erc1155.ts
      erc20.test.ts.md
      erc20.ts
      erc721.test.ts.md
      erc721.ts
      errors.ts
      index.ts
      types.ts
      utils.ts
    ethersService.ts
  tests/
    contracts/
      TestToken.sol
    utils/
      globalTestSetup.ts
      hardhatTestProvider.ts
      testContractHelper.ts
      testHelpers.ts.md
      types.ts
    contract-methods.test.ts
    test.ts
    write-methods.test.ts
  tools/
    definitions/
      erc1155.ts
      erc20.ts
      erc721.ts
      index.ts
    handlers/
      erc1155.ts
      erc20.ts
      erc721.ts
      index.ts
    index.ts
  utils/
    cache.ts
    errors.ts
    logger.ts
    metrics.ts
    rateLimiter.ts
  index.ts
  server.ts
.env.example
.gitignore
claude-server.json
hardhat.config.cjs
jest.config.cjs
jest.config.js
jest.setup.js
jest.setup.ts
LICENSE
MCP-docs.txt
MCP-Typescript-readme.txt
package.json
README.md
server.ts.backup
tsconfig.json
tsconfig.node.json

================================================================
Files
================================================================

================
File: artifacts/build-info/a41376ba4fdfb875b722abb085e468b4.json
================
{"id":"a41376ba4fdfb875b722abb085e468b4","_format":"hh-sol-build-info-1","solcVersion":"0.8.24","solcLongVersion":"0.8.24+commit.e11b9ed9","input":{"language":"Solidity","sources":{"contracts/TestToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract TestToken {\n    string public name = \"MyToken\";\n    string public symbol = \"MCP\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() {\n        totalSupply = 1000000 * 10**uint256(decimals);\n        balanceOf[msg.sender] = totalSupply;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= value, \"insufficient balance\");\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool success) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n        require(balanceOf[from] >= value, \"insufficient balance\");\n        require(allowance[from][msg.sender] >= value, \"exceeds allowance\");\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        allowance[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function mint(address to, uint256 value) public {\n        balanceOf[to] += value;\n        totalSupply += value;\n        emit Transfer(address(0), to, value);\n    }\n} "}},"settings":{"evmVersion":"paris","optimizer":{"enabled":false,"runs":200},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"],"":["ast"]}}}},"output":{"sources":{"contracts/TestToken.sol":{"ast":{"absolutePath":"contracts/TestToken.sol","exportedSymbols":{"TestToken":[220]},"id":221,"license":"MIT","nodeType":"SourceUnit","nodes":[{"id":1,"literals":["solidity","^","0.8",".24"],"nodeType":"PragmaDirective","src":"32:24:0"},{"abstract":false,"baseContracts":[],"canonicalName":"TestToken","contractDependencies":[],"contractKind":"contract","fullyImplemented":true,"id":220,"linearizedBaseContracts":[220],"name":"TestToken","nameLocation":"67:9:0","nodeType":"ContractDefinition","nodes":[{"constant":false,"functionSelector":"06fdde03","id":4,"mutability":"mutable","name":"name","nameLocation":"97:4:0","nodeType":"VariableDeclaration","scope":220,"src":"83:30:0","stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_string_storage","typeString":"string"},"typeName":{"id":2,"name":"string","nodeType":"ElementaryTypeName","src":"83:6:0","typeDescriptions":{"typeIdentifier":"t_string_storage_ptr","typeString":"string"}},"value":{"hexValue":"4d79546f6b656e","id":3,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"104:9:0","typeDescriptions":{"typeIdentifier":"t_stringliteral_245c734e6d4ec044daf7beffa09d54d4bafba490113c199734d790b04a7390e5","typeString":"literal_string \"MyToken\""},"value":"MyToken"},"visibility":"public"},{"constant":false,"functionSelector":"95d89b41","id":7,"mutability":"mutable","name":"symbol","nameLocation":"133:6:0","nodeType":"VariableDeclaration","scope":220,"src":"119:28:0","stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_string_storage","typeString":"string"},"typeName":{"id":5,"name":"string","nodeType":"ElementaryTypeName","src":"119:6:0","typeDescriptions":{"typeIdentifier":"t_string_storage_ptr","typeString":"string"}},"value":{"hexValue":"4d4350","id":6,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"142:5:0","typeDescriptions":{"typeIdentifier":"t_stringliteral_03680a80fc10e1ad314508d1058b02af5d98938afa4b1d7c5d1fdb5f8a411d13","typeString":"literal_string \"MCP\""},"value":"MCP"},"visibility":"public"},{"constant":false,"functionSelector":"313ce567","id":10,"mutability":"mutable","name":"decimals","nameLocation":"166:8:0","nodeType":"VariableDeclaration","scope":220,"src":"153:26:0","stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint8","typeString":"uint8"},"typeName":{"id":8,"name":"uint8","nodeType":"ElementaryTypeName","src":"153:5:0","typeDescriptions":{"typeIdentifier":"t_uint8","typeString":"uint8"}},"value":{"hexValue":"3138","id":9,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"177:2:0","typeDescriptions":{"typeIdentifier":"t_rational_18_by_1","typeString":"int_const 18"},"value":"18"},"visibility":"public"},{"constant":false,"functionSelector":"18160ddd","id":12,"mutability":"mutable","name":"totalSupply","nameLocation":"200:11:0","nodeType":"VariableDeclaration","scope":220,"src":"185:26:0","stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":11,"name":"uint256","nodeType":"ElementaryTypeName","src":"185:7:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"public"},{"constant":false,"functionSelector":"70a08231","id":16,"mutability":"mutable","name":"balanceOf","nameLocation":"252:9:0","nodeType":"VariableDeclaration","scope":220,"src":"217:44:0","stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_uint256_$","typeString":"mapping(address => uint256)"},"typeName":{"id":15,"keyName":"","keyNameLocation":"-1:-1:-1","keyType":{"id":13,"name":"address","nodeType":"ElementaryTypeName","src":"225:7:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Mapping","src":"217:27:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_uint256_$","typeString":"mapping(address => uint256)"},"valueName":"","valueNameLocation":"-1:-1:-1","valueType":{"id":14,"name":"uint256","nodeType":"ElementaryTypeName","src":"236:7:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}},"visibility":"public"},{"constant":false,"functionSelector":"dd62ed3e","id":22,"mutability":"mutable","name":"allowance","nameLocation":"322:9:0","nodeType":"VariableDeclaration","scope":220,"src":"267:64:0","stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_uint256_$_$","typeString":"mapping(address => mapping(address => uint256))"},"typeName":{"id":21,"keyName":"","keyNameLocation":"-1:-1:-1","keyType":{"id":17,"name":"address","nodeType":"ElementaryTypeName","src":"275:7:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Mapping","src":"267:47:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_uint256_$_$","typeString":"mapping(address => mapping(address => uint256))"},"valueName":"","valueNameLocation":"-1:-1:-1","valueType":{"id":20,"keyName":"","keyNameLocation":"-1:-1:-1","keyType":{"id":18,"name":"address","nodeType":"ElementaryTypeName","src":"294:7:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Mapping","src":"286:27:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_uint256_$","typeString":"mapping(address => uint256)"},"valueName":"","valueNameLocation":"-1:-1:-1","valueType":{"id":19,"name":"uint256","nodeType":"ElementaryTypeName","src":"305:7:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}}},"visibility":"public"},{"anonymous":false,"eventSelector":"ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef","id":30,"name":"Transfer","nameLocation":"344:8:0","nodeType":"EventDefinition","parameters":{"id":29,"nodeType":"ParameterList","parameters":[{"constant":false,"id":24,"indexed":true,"mutability":"mutable","name":"from","nameLocation":"369:4:0","nodeType":"VariableDeclaration","scope":30,"src":"353:20:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":23,"name":"address","nodeType":"ElementaryTypeName","src":"353:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":26,"indexed":true,"mutability":"mutable","name":"to","nameLocation":"391:2:0","nodeType":"VariableDeclaration","scope":30,"src":"375:18:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":25,"name":"address","nodeType":"ElementaryTypeName","src":"375:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":28,"indexed":false,"mutability":"mutable","name":"value","nameLocation":"403:5:0","nodeType":"VariableDeclaration","scope":30,"src":"395:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":27,"name":"uint256","nodeType":"ElementaryTypeName","src":"395:7:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"352:57:0"},"src":"338:72:0"},{"anonymous":false,"eventSelector":"8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925","id":38,"name":"Approval","nameLocation":"421:8:0","nodeType":"EventDefinition","parameters":{"id":37,"nodeType":"ParameterList","parameters":[{"constant":false,"id":32,"indexed":true,"mutability":"mutable","name":"owner","nameLocation":"446:5:0","nodeType":"VariableDeclaration","scope":38,"src":"430:21:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":31,"name":"address","nodeType":"ElementaryTypeName","src":"430:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":34,"indexed":true,"mutability":"mutable","name":"spender","nameLocation":"469:7:0","nodeType":"VariableDeclaration","scope":38,"src":"453:23:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":33,"name":"address","nodeType":"ElementaryTypeName","src":"453:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":36,"indexed":false,"mutability":"mutable","name":"value","nameLocation":"486:5:0","nodeType":"VariableDeclaration","scope":38,"src":"478:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":35,"name":"uint256","nodeType":"ElementaryTypeName","src":"478:7:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"429:63:0"},"src":"415:78:0"},{"body":{"id":59,"nodeType":"Block","src":"513:107:0","statements":[{"expression":{"id":50,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":41,"name":"totalSupply","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":12,"src":"523:11:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":49,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"hexValue":"31303030303030","id":42,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"537:7:0","typeDescriptions":{"typeIdentifier":"t_rational_1000000_by_1","typeString":"int_const 1000000"},"value":"1000000"},"nodeType":"BinaryOperation","operator":"*","rightExpression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":48,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"hexValue":"3130","id":43,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"547:2:0","typeDescriptions":{"typeIdentifier":"t_rational_10_by_1","typeString":"int_const 10"},"value":"10"},"nodeType":"BinaryOperation","operator":"**","rightExpression":{"arguments":[{"id":46,"name":"decimals","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":10,"src":"559:8:0","typeDescriptions":{"typeIdentifier":"t_uint8","typeString":"uint8"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint8","typeString":"uint8"}],"id":45,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"551:7:0","typeDescriptions":{"typeIdentifier":"t_type$_t_uint256_$","typeString":"type(uint256)"},"typeName":{"id":44,"name":"uint256","nodeType":"ElementaryTypeName","src":"551:7:0","typeDescriptions":{}}},"id":47,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"551:17:0","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"547:21:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"537:31:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"523:45:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":51,"nodeType":"ExpressionStatement","src":"523:45:0"},{"expression":{"id":57,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"baseExpression":{"id":52,"name":"balanceOf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":16,"src":"578:9:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_uint256_$","typeString":"mapping(address => uint256)"}},"id":55,"indexExpression":{"expression":{"id":53,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"588:3:0","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":54,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"592:6:0","memberName":"sender","nodeType":"MemberAccess","src":"588:10:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"578:21:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"id":56,"name":"totalSupply","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":12,"src":"602:11:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"578:35:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":58,"nodeType":"ExpressionStatement","src":"578:35:0"}]},"id":60,"implemented":true,"kind":"constructor","modifiers":[],"name":"","nameLocation":"-1:-1:-1","nodeType":"FunctionDefinition","parameters":{"id":39,"nodeType":"ParameterList","parameters":[],"src":"510:2:0"},"returnParameters":{"id":40,"nodeType":"ParameterList","parameters":[],"src":"513:0:0"},"scope":220,"src":"499:121:0","stateMutability":"nonpayable","virtual":false,"visibility":"public"},{"body":{"id":101,"nodeType":"Block","src":"701:219:0","statements":[{"expression":{"arguments":[{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":75,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"baseExpression":{"id":70,"name":"balanceOf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":16,"src":"719:9:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_uint256_$","typeString":"mapping(address => uint256)"}},"id":73,"indexExpression":{"expression":{"id":71,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"729:3:0","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":72,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"733:6:0","memberName":"sender","nodeType":"MemberAccess","src":"729:10:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"719:21:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">=","rightExpression":{"id":74,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":64,"src":"744:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"719:30:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},{"hexValue":"696e73756666696369656e742062616c616e6365","id":76,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"751:22:0","typeDescriptions":{"typeIdentifier":"t_stringliteral_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee","typeString":"literal_string \"insufficient balance\""},"value":"insufficient balance"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bool","typeString":"bool"},{"typeIdentifier":"t_stringliteral_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee","typeString":"literal_string \"insufficient balance\""}],"id":69,"name":"require","nodeType":"Identifier","overloadedDeclarations":[-18,-18],"referencedDeclaration":-18,"src":"711:7:0","typeDescriptions":{"typeIdentifier":"t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$","typeString":"function (bool,string memory) pure"}},"id":77,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"711:63:0","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":78,"nodeType":"ExpressionStatement","src":"711:63:0"},{"expression":{"id":84,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"baseExpression":{"id":79,"name":"balanceOf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":16,"src":"784:9:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_uint256_$","typeString":"mapping(address => uint256)"}},"id":82,"indexExpression":{"expression":{"id":80,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"794:3:0","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":81,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"798:6:0","memberName":"sender","nodeType":"MemberAccess","src":"794:10:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"784:21:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"-=","rightHandSide":{"id":83,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":64,"src":"809:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"784:30:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":85,"nodeType":"ExpressionStatement","src":"784:30:0"},{"expression":{"id":90,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"baseExpression":{"id":86,"name":"balanceOf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":16,"src":"824:9:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_uint256_$","typeString":"mapping(address => uint256)"}},"id":88,"indexExpression":{"id":87,"name":"to","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":62,"src":"834:2:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"824:13:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"+=","rightHandSide":{"id":89,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":64,"src":"841:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"824:22:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":91,"nodeType":"ExpressionStatement","src":"824:22:0"},{"eventCall":{"arguments":[{"expression":{"id":93,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"870:3:0","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":94,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"874:6:0","memberName":"sender","nodeType":"MemberAccess","src":"870:10:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":95,"name":"to","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":62,"src":"882:2:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":96,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":64,"src":"886:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":92,"name":"Transfer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":30,"src":"861:8:0","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_address_$_t_address_$_t_uint256_$returns$__$","typeString":"function (address,address,uint256)"}},"id":97,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"861:31:0","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":98,"nodeType":"EmitStatement","src":"856:36:0"},{"expression":{"hexValue":"74727565","id":99,"isConstant":false,"isLValue":false,"isPure":true,"kind":"bool","lValueRequested":false,"nodeType":"Literal","src":"909:4:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"value":"true"},"functionReturnParameters":68,"id":100,"nodeType":"Return","src":"902:11:0"}]},"functionSelector":"a9059cbb","id":102,"implemented":true,"kind":"function","modifiers":[],"name":"transfer","nameLocation":"635:8:0","nodeType":"FunctionDefinition","parameters":{"id":65,"nodeType":"ParameterList","parameters":[{"constant":false,"id":62,"mutability":"mutable","name":"to","nameLocation":"652:2:0","nodeType":"VariableDeclaration","scope":102,"src":"644:10:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":61,"name":"address","nodeType":"ElementaryTypeName","src":"644:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":64,"mutability":"mutable","name":"value","nameLocation":"664:5:0","nodeType":"VariableDeclaration","scope":102,"src":"656:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":63,"name":"uint256","nodeType":"ElementaryTypeName","src":"656:7:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"643:27:0"},"returnParameters":{"id":68,"nodeType":"ParameterList","parameters":[{"constant":false,"id":67,"mutability":"mutable","name":"success","nameLocation":"692:7:0","nodeType":"VariableDeclaration","scope":102,"src":"687:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":66,"name":"bool","nodeType":"ElementaryTypeName","src":"687:4:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"686:14:0"},"scope":220,"src":"626:294:0","stateMutability":"nonpayable","virtual":false,"visibility":"public"},{"body":{"id":129,"nodeType":"Block","src":"1005:127:0","statements":[{"expression":{"id":118,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"baseExpression":{"baseExpression":{"id":111,"name":"allowance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":22,"src":"1015:9:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_uint256_$_$","typeString":"mapping(address => mapping(address => uint256))"}},"id":115,"indexExpression":{"expression":{"id":112,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"1025:3:0","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":113,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1029:6:0","memberName":"sender","nodeType":"MemberAccess","src":"1025:10:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"1015:21:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_uint256_$","typeString":"mapping(address => uint256)"}},"id":116,"indexExpression":{"id":114,"name":"spender","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":104,"src":"1037:7:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"1015:30:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"id":117,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":106,"src":"1048:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"1015:38:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":119,"nodeType":"ExpressionStatement","src":"1015:38:0"},{"eventCall":{"arguments":[{"expression":{"id":121,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"1077:3:0","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":122,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1081:6:0","memberName":"sender","nodeType":"MemberAccess","src":"1077:10:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":123,"name":"spender","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":104,"src":"1089:7:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":124,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":106,"src":"1098:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":120,"name":"Approval","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":38,"src":"1068:8:0","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_address_$_t_address_$_t_uint256_$returns$__$","typeString":"function (address,address,uint256)"}},"id":125,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1068:36:0","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":126,"nodeType":"EmitStatement","src":"1063:41:0"},{"expression":{"hexValue":"74727565","id":127,"isConstant":false,"isLValue":false,"isPure":true,"kind":"bool","lValueRequested":false,"nodeType":"Literal","src":"1121:4:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"value":"true"},"functionReturnParameters":110,"id":128,"nodeType":"Return","src":"1114:11:0"}]},"functionSelector":"095ea7b3","id":130,"implemented":true,"kind":"function","modifiers":[],"name":"approve","nameLocation":"935:7:0","nodeType":"FunctionDefinition","parameters":{"id":107,"nodeType":"ParameterList","parameters":[{"constant":false,"id":104,"mutability":"mutable","name":"spender","nameLocation":"951:7:0","nodeType":"VariableDeclaration","scope":130,"src":"943:15:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":103,"name":"address","nodeType":"ElementaryTypeName","src":"943:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":106,"mutability":"mutable","name":"value","nameLocation":"968:5:0","nodeType":"VariableDeclaration","scope":130,"src":"960:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":105,"name":"uint256","nodeType":"ElementaryTypeName","src":"960:7:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"942:32:0"},"returnParameters":{"id":110,"nodeType":"ParameterList","parameters":[{"constant":false,"id":109,"mutability":"mutable","name":"success","nameLocation":"996:7:0","nodeType":"VariableDeclaration","scope":130,"src":"991:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":108,"name":"bool","nodeType":"ElementaryTypeName","src":"991:4:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"990:14:0"},"scope":220,"src":"926:206:0","stateMutability":"nonpayable","virtual":false,"visibility":"public"},{"body":{"id":191,"nodeType":"Block","src":"1231:323:0","statements":[{"expression":{"arguments":[{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":146,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"baseExpression":{"id":142,"name":"balanceOf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":16,"src":"1249:9:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_uint256_$","typeString":"mapping(address => uint256)"}},"id":144,"indexExpression":{"id":143,"name":"from","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":132,"src":"1259:4:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"1249:15:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">=","rightExpression":{"id":145,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":136,"src":"1268:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"1249:24:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},{"hexValue":"696e73756666696369656e742062616c616e6365","id":147,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"1275:22:0","typeDescriptions":{"typeIdentifier":"t_stringliteral_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee","typeString":"literal_string \"insufficient balance\""},"value":"insufficient balance"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bool","typeString":"bool"},{"typeIdentifier":"t_stringliteral_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee","typeString":"literal_string \"insufficient balance\""}],"id":141,"name":"require","nodeType":"Identifier","overloadedDeclarations":[-18,-18],"referencedDeclaration":-18,"src":"1241:7:0","typeDescriptions":{"typeIdentifier":"t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$","typeString":"function (bool,string memory) pure"}},"id":148,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1241:57:0","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":149,"nodeType":"ExpressionStatement","src":"1241:57:0"},{"expression":{"arguments":[{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":158,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"baseExpression":{"baseExpression":{"id":151,"name":"allowance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":22,"src":"1316:9:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_uint256_$_$","typeString":"mapping(address => mapping(address => uint256))"}},"id":153,"indexExpression":{"id":152,"name":"from","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":132,"src":"1326:4:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"1316:15:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_uint256_$","typeString":"mapping(address => uint256)"}},"id":156,"indexExpression":{"expression":{"id":154,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"1332:3:0","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":155,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1336:6:0","memberName":"sender","nodeType":"MemberAccess","src":"1332:10:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"1316:27:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":">=","rightExpression":{"id":157,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":136,"src":"1347:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"1316:36:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},{"hexValue":"6578636565647320616c6c6f77616e6365","id":159,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"1354:19:0","typeDescriptions":{"typeIdentifier":"t_stringliteral_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618","typeString":"literal_string \"exceeds allowance\""},"value":"exceeds allowance"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bool","typeString":"bool"},{"typeIdentifier":"t_stringliteral_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618","typeString":"literal_string \"exceeds allowance\""}],"id":150,"name":"require","nodeType":"Identifier","overloadedDeclarations":[-18,-18],"referencedDeclaration":-18,"src":"1308:7:0","typeDescriptions":{"typeIdentifier":"t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$","typeString":"function (bool,string memory) pure"}},"id":160,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1308:66:0","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":161,"nodeType":"ExpressionStatement","src":"1308:66:0"},{"expression":{"id":166,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"baseExpression":{"id":162,"name":"balanceOf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":16,"src":"1384:9:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_uint256_$","typeString":"mapping(address => uint256)"}},"id":164,"indexExpression":{"id":163,"name":"from","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":132,"src":"1394:4:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"1384:15:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"-=","rightHandSide":{"id":165,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":136,"src":"1403:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"1384:24:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":167,"nodeType":"ExpressionStatement","src":"1384:24:0"},{"expression":{"id":172,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"baseExpression":{"id":168,"name":"balanceOf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":16,"src":"1418:9:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_uint256_$","typeString":"mapping(address => uint256)"}},"id":170,"indexExpression":{"id":169,"name":"to","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":134,"src":"1428:2:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"1418:13:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"+=","rightHandSide":{"id":171,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":136,"src":"1435:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"1418:22:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":173,"nodeType":"ExpressionStatement","src":"1418:22:0"},{"expression":{"id":181,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"baseExpression":{"baseExpression":{"id":174,"name":"allowance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":22,"src":"1450:9:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_uint256_$_$","typeString":"mapping(address => mapping(address => uint256))"}},"id":178,"indexExpression":{"id":175,"name":"from","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":132,"src":"1460:4:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"1450:15:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_uint256_$","typeString":"mapping(address => uint256)"}},"id":179,"indexExpression":{"expression":{"id":176,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"1466:3:0","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":177,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1470:6:0","memberName":"sender","nodeType":"MemberAccess","src":"1466:10:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"1450:27:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"-=","rightHandSide":{"id":180,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":136,"src":"1481:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"1450:36:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":182,"nodeType":"ExpressionStatement","src":"1450:36:0"},{"eventCall":{"arguments":[{"id":184,"name":"from","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":132,"src":"1510:4:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":185,"name":"to","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":134,"src":"1516:2:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":186,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":136,"src":"1520:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":183,"name":"Transfer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":30,"src":"1501:8:0","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_address_$_t_address_$_t_uint256_$returns$__$","typeString":"function (address,address,uint256)"}},"id":187,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1501:25:0","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":188,"nodeType":"EmitStatement","src":"1496:30:0"},{"expression":{"hexValue":"74727565","id":189,"isConstant":false,"isLValue":false,"isPure":true,"kind":"bool","lValueRequested":false,"nodeType":"Literal","src":"1543:4:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"value":"true"},"functionReturnParameters":140,"id":190,"nodeType":"Return","src":"1536:11:0"}]},"functionSelector":"23b872dd","id":192,"implemented":true,"kind":"function","modifiers":[],"name":"transferFrom","nameLocation":"1147:12:0","nodeType":"FunctionDefinition","parameters":{"id":137,"nodeType":"ParameterList","parameters":[{"constant":false,"id":132,"mutability":"mutable","name":"from","nameLocation":"1168:4:0","nodeType":"VariableDeclaration","scope":192,"src":"1160:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":131,"name":"address","nodeType":"ElementaryTypeName","src":"1160:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":134,"mutability":"mutable","name":"to","nameLocation":"1182:2:0","nodeType":"VariableDeclaration","scope":192,"src":"1174:10:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":133,"name":"address","nodeType":"ElementaryTypeName","src":"1174:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":136,"mutability":"mutable","name":"value","nameLocation":"1194:5:0","nodeType":"VariableDeclaration","scope":192,"src":"1186:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":135,"name":"uint256","nodeType":"ElementaryTypeName","src":"1186:7:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"1159:41:0"},"returnParameters":{"id":140,"nodeType":"ParameterList","parameters":[{"constant":false,"id":139,"mutability":"mutable","name":"success","nameLocation":"1222:7:0","nodeType":"VariableDeclaration","scope":192,"src":"1217:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":138,"name":"bool","nodeType":"ElementaryTypeName","src":"1217:4:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"1216:14:0"},"scope":220,"src":"1138:416:0","stateMutability":"nonpayable","virtual":false,"visibility":"public"},{"body":{"id":218,"nodeType":"Block","src":"1608:115:0","statements":[{"expression":{"id":203,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"baseExpression":{"id":199,"name":"balanceOf","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":16,"src":"1618:9:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_uint256_$","typeString":"mapping(address => uint256)"}},"id":201,"indexExpression":{"id":200,"name":"to","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":194,"src":"1628:2:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"1618:13:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"+=","rightHandSide":{"id":202,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":196,"src":"1635:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"1618:22:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":204,"nodeType":"ExpressionStatement","src":"1618:22:0"},{"expression":{"id":207,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"id":205,"name":"totalSupply","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":12,"src":"1650:11:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"Assignment","operator":"+=","rightHandSide":{"id":206,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":196,"src":"1665:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"1650:20:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":208,"nodeType":"ExpressionStatement","src":"1650:20:0"},{"eventCall":{"arguments":[{"arguments":[{"hexValue":"30","id":212,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"1702:1:0","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":211,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"1694:7:0","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":210,"name":"address","nodeType":"ElementaryTypeName","src":"1694:7:0","typeDescriptions":{}}},"id":213,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1694:10:0","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":214,"name":"to","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":194,"src":"1706:2:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":215,"name":"value","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":196,"src":"1710:5:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":209,"name":"Transfer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":30,"src":"1685:8:0","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_address_$_t_address_$_t_uint256_$returns$__$","typeString":"function (address,address,uint256)"}},"id":216,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1685:31:0","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":217,"nodeType":"EmitStatement","src":"1680:36:0"}]},"functionSelector":"40c10f19","id":219,"implemented":true,"kind":"function","modifiers":[],"name":"mint","nameLocation":"1569:4:0","nodeType":"FunctionDefinition","parameters":{"id":197,"nodeType":"ParameterList","parameters":[{"constant":false,"id":194,"mutability":"mutable","name":"to","nameLocation":"1582:2:0","nodeType":"VariableDeclaration","scope":219,"src":"1574:10:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":193,"name":"address","nodeType":"ElementaryTypeName","src":"1574:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":196,"mutability":"mutable","name":"value","nameLocation":"1594:5:0","nodeType":"VariableDeclaration","scope":219,"src":"1586:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":195,"name":"uint256","nodeType":"ElementaryTypeName","src":"1586:7:0","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"1573:27:0"},"returnParameters":{"id":198,"nodeType":"ParameterList","parameters":[],"src":"1608:0:0"},"scope":220,"src":"1560:163:0","stateMutability":"nonpayable","virtual":false,"visibility":"public"}],"scope":221,"src":"58:1667:0","usedErrors":[],"usedEvents":[30,38]}],"src":"32:1694:0"},"id":0}},"contracts":{"contracts/TestToken.sol":{"TestToken":{"abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"}],"evm":{"bytecode":{"functionDebugData":{"@_60":{"entryPoint":null,"id":60,"parameterSlots":0,"returnSlots":0},"array_dataslot_t_string_storage":{"entryPoint":477,"id":null,"parameterSlots":1,"returnSlots":1},"array_length_t_string_memory_ptr":{"entryPoint":319,"id":null,"parameterSlots":1,"returnSlots":1},"checked_exp_helper":{"entryPoint":1244,"id":null,"parameterSlots":4,"returnSlots":2},"checked_exp_t_uint256_t_uint256":{"entryPoint":1571,"id":null,"parameterSlots":2,"returnSlots":1},"checked_exp_unsigned":{"entryPoint":1335,"id":null,"parameterSlots":3,"returnSlots":1},"checked_mul_t_uint256":{"entryPoint":1652,"id":null,"parameterSlots":2,"returnSlots":1},"clean_up_bytearray_end_slots_t_string_storage":{"entryPoint":798,"id":null,"parameterSlots":3,"returnSlots":0},"cleanup_t_uint256":{"entryPoint":613,"id":null,"parameterSlots":1,"returnSlots":1},"clear_storage_range_t_bytes1":{"entryPoint":759,"id":null,"parameterSlots":2,"returnSlots":0},"convert_t_uint256_to_t_uint256":{"entryPoint":633,"id":null,"parameterSlots":1,"returnSlots":1},"copy_byte_array_to_storage_from_t_string_memory_ptr_to_t_string_storage":{"entryPoint":953,"id":null,"parameterSlots":2,"returnSlots":0},"divide_by_32_ceil":{"entryPoint":498,"id":null,"parameterSlots":1,"returnSlots":1},"extract_byte_array_length":{"entryPoint":424,"id":null,"parameterSlots":1,"returnSlots":1},"extract_used_part_and_set_length_of_short_byte_array":{"entryPoint":923,"id":null,"parameterSlots":2,"returnSlots":1},"identity":{"entryPoint":623,"id":null,"parameterSlots":1,"returnSlots":1},"mask_bytes_dynamic":{"entryPoint":891,"id":null,"parameterSlots":2,"returnSlots":1},"panic_error_0x11":{"entryPoint":1184,"id":null,"parameterSlots":0,"returnSlots":0},"panic_error_0x22":{"entryPoint":377,"id":null,"parameterSlots":0,"returnSlots":0},"panic_error_0x41":{"entryPoint":330,"id":null,"parameterSlots":0,"returnSlots":0},"prepare_store_t_uint256":{"entryPoint":673,"id":null,"parameterSlots":1,"returnSlots":1},"shift_left_dynamic":{"entryPoint":514,"id":null,"parameterSlots":2,"returnSlots":1},"shift_right_1_unsigned":{"entryPoint":1231,"id":null,"parameterSlots":1,"returnSlots":1},"shift_right_unsigned_dynamic":{"entryPoint":878,"id":null,"parameterSlots":2,"returnSlots":1},"storage_set_to_zero_t_uint256":{"entryPoint":731,"id":null,"parameterSlots":2,"returnSlots":0},"update_byte_slice_dynamic32":{"entryPoint":527,"id":null,"parameterSlots":3,"returnSlots":1},"update_storage_value_t_uint256_to_t_uint256":{"entryPoint":683,"id":null,"parameterSlots":3,"returnSlots":0},"zero_value_for_split_t_uint256":{"entryPoint":726,"id":null,"parameterSlots":0,"returnSlots":1}},"generatedSources":[{"ast":{"nativeSrc":"0:8165:1","nodeType":"YulBlock","src":"0:8165:1","statements":[{"body":{"nativeSrc":"66:40:1","nodeType":"YulBlock","src":"66:40:1","statements":[{"nativeSrc":"77:22:1","nodeType":"YulAssignment","src":"77:22:1","value":{"arguments":[{"name":"value","nativeSrc":"93:5:1","nodeType":"YulIdentifier","src":"93:5:1"}],"functionName":{"name":"mload","nativeSrc":"87:5:1","nodeType":"YulIdentifier","src":"87:5:1"},"nativeSrc":"87:12:1","nodeType":"YulFunctionCall","src":"87:12:1"},"variableNames":[{"name":"length","nativeSrc":"77:6:1","nodeType":"YulIdentifier","src":"77:6:1"}]}]},"name":"array_length_t_string_memory_ptr","nativeSrc":"7:99:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"49:5:1","nodeType":"YulTypedName","src":"49:5:1","type":""}],"returnVariables":[{"name":"length","nativeSrc":"59:6:1","nodeType":"YulTypedName","src":"59:6:1","type":""}],"src":"7:99:1"},{"body":{"nativeSrc":"140:152:1","nodeType":"YulBlock","src":"140:152:1","statements":[{"expression":{"arguments":[{"kind":"number","nativeSrc":"157:1:1","nodeType":"YulLiteral","src":"157:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"160:77:1","nodeType":"YulLiteral","src":"160:77:1","type":"","value":"35408467139433450592217433187231851964531694900788300625387963629091585785856"}],"functionName":{"name":"mstore","nativeSrc":"150:6:1","nodeType":"YulIdentifier","src":"150:6:1"},"nativeSrc":"150:88:1","nodeType":"YulFunctionCall","src":"150:88:1"},"nativeSrc":"150:88:1","nodeType":"YulExpressionStatement","src":"150:88:1"},{"expression":{"arguments":[{"kind":"number","nativeSrc":"254:1:1","nodeType":"YulLiteral","src":"254:1:1","type":"","value":"4"},{"kind":"number","nativeSrc":"257:4:1","nodeType":"YulLiteral","src":"257:4:1","type":"","value":"0x41"}],"functionName":{"name":"mstore","nativeSrc":"247:6:1","nodeType":"YulIdentifier","src":"247:6:1"},"nativeSrc":"247:15:1","nodeType":"YulFunctionCall","src":"247:15:1"},"nativeSrc":"247:15:1","nodeType":"YulExpressionStatement","src":"247:15:1"},{"expression":{"arguments":[{"kind":"number","nativeSrc":"278:1:1","nodeType":"YulLiteral","src":"278:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"281:4:1","nodeType":"YulLiteral","src":"281:4:1","type":"","value":"0x24"}],"functionName":{"name":"revert","nativeSrc":"271:6:1","nodeType":"YulIdentifier","src":"271:6:1"},"nativeSrc":"271:15:1","nodeType":"YulFunctionCall","src":"271:15:1"},"nativeSrc":"271:15:1","nodeType":"YulExpressionStatement","src":"271:15:1"}]},"name":"panic_error_0x41","nativeSrc":"112:180:1","nodeType":"YulFunctionDefinition","src":"112:180:1"},{"body":{"nativeSrc":"326:152:1","nodeType":"YulBlock","src":"326:152:1","statements":[{"expression":{"arguments":[{"kind":"number","nativeSrc":"343:1:1","nodeType":"YulLiteral","src":"343:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"346:77:1","nodeType":"YulLiteral","src":"346:77:1","type":"","value":"35408467139433450592217433187231851964531694900788300625387963629091585785856"}],"functionName":{"name":"mstore","nativeSrc":"336:6:1","nodeType":"YulIdentifier","src":"336:6:1"},"nativeSrc":"336:88:1","nodeType":"YulFunctionCall","src":"336:88:1"},"nativeSrc":"336:88:1","nodeType":"YulExpressionStatement","src":"336:88:1"},{"expression":{"arguments":[{"kind":"number","nativeSrc":"440:1:1","nodeType":"YulLiteral","src":"440:1:1","type":"","value":"4"},{"kind":"number","nativeSrc":"443:4:1","nodeType":"YulLiteral","src":"443:4:1","type":"","value":"0x22"}],"functionName":{"name":"mstore","nativeSrc":"433:6:1","nodeType":"YulIdentifier","src":"433:6:1"},"nativeSrc":"433:15:1","nodeType":"YulFunctionCall","src":"433:15:1"},"nativeSrc":"433:15:1","nodeType":"YulExpressionStatement","src":"433:15:1"},{"expression":{"arguments":[{"kind":"number","nativeSrc":"464:1:1","nodeType":"YulLiteral","src":"464:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"467:4:1","nodeType":"YulLiteral","src":"467:4:1","type":"","value":"0x24"}],"functionName":{"name":"revert","nativeSrc":"457:6:1","nodeType":"YulIdentifier","src":"457:6:1"},"nativeSrc":"457:15:1","nodeType":"YulFunctionCall","src":"457:15:1"},"nativeSrc":"457:15:1","nodeType":"YulExpressionStatement","src":"457:15:1"}]},"name":"panic_error_0x22","nativeSrc":"298:180:1","nodeType":"YulFunctionDefinition","src":"298:180:1"},{"body":{"nativeSrc":"535:269:1","nodeType":"YulBlock","src":"535:269:1","statements":[{"nativeSrc":"545:22:1","nodeType":"YulAssignment","src":"545:22:1","value":{"arguments":[{"name":"data","nativeSrc":"559:4:1","nodeType":"YulIdentifier","src":"559:4:1"},{"kind":"number","nativeSrc":"565:1:1","nodeType":"YulLiteral","src":"565:1:1","type":"","value":"2"}],"functionName":{"name":"div","nativeSrc":"555:3:1","nodeType":"YulIdentifier","src":"555:3:1"},"nativeSrc":"555:12:1","nodeType":"YulFunctionCall","src":"555:12:1"},"variableNames":[{"name":"length","nativeSrc":"545:6:1","nodeType":"YulIdentifier","src":"545:6:1"}]},{"nativeSrc":"576:38:1","nodeType":"YulVariableDeclaration","src":"576:38:1","value":{"arguments":[{"name":"data","nativeSrc":"606:4:1","nodeType":"YulIdentifier","src":"606:4:1"},{"kind":"number","nativeSrc":"612:1:1","nodeType":"YulLiteral","src":"612:1:1","type":"","value":"1"}],"functionName":{"name":"and","nativeSrc":"602:3:1","nodeType":"YulIdentifier","src":"602:3:1"},"nativeSrc":"602:12:1","nodeType":"YulFunctionCall","src":"602:12:1"},"variables":[{"name":"outOfPlaceEncoding","nativeSrc":"580:18:1","nodeType":"YulTypedName","src":"580:18:1","type":""}]},{"body":{"nativeSrc":"653:51:1","nodeType":"YulBlock","src":"653:51:1","statements":[{"nativeSrc":"667:27:1","nodeType":"YulAssignment","src":"667:27:1","value":{"arguments":[{"name":"length","nativeSrc":"681:6:1","nodeType":"YulIdentifier","src":"681:6:1"},{"kind":"number","nativeSrc":"689:4:1","nodeType":"YulLiteral","src":"689:4:1","type":"","value":"0x7f"}],"functionName":{"name":"and","nativeSrc":"677:3:1","nodeType":"YulIdentifier","src":"677:3:1"},"nativeSrc":"677:17:1","nodeType":"YulFunctionCall","src":"677:17:1"},"variableNames":[{"name":"length","nativeSrc":"667:6:1","nodeType":"YulIdentifier","src":"667:6:1"}]}]},"condition":{"arguments":[{"name":"outOfPlaceEncoding","nativeSrc":"633:18:1","nodeType":"YulIdentifier","src":"633:18:1"}],"functionName":{"name":"iszero","nativeSrc":"626:6:1","nodeType":"YulIdentifier","src":"626:6:1"},"nativeSrc":"626:26:1","nodeType":"YulFunctionCall","src":"626:26:1"},"nativeSrc":"623:81:1","nodeType":"YulIf","src":"623:81:1"},{"body":{"nativeSrc":"756:42:1","nodeType":"YulBlock","src":"756:42:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x22","nativeSrc":"770:16:1","nodeType":"YulIdentifier","src":"770:16:1"},"nativeSrc":"770:18:1","nodeType":"YulFunctionCall","src":"770:18:1"},"nativeSrc":"770:18:1","nodeType":"YulExpressionStatement","src":"770:18:1"}]},"condition":{"arguments":[{"name":"outOfPlaceEncoding","nativeSrc":"720:18:1","nodeType":"YulIdentifier","src":"720:18:1"},{"arguments":[{"name":"length","nativeSrc":"743:6:1","nodeType":"YulIdentifier","src":"743:6:1"},{"kind":"number","nativeSrc":"751:2:1","nodeType":"YulLiteral","src":"751:2:1","type":"","value":"32"}],"functionName":{"name":"lt","nativeSrc":"740:2:1","nodeType":"YulIdentifier","src":"740:2:1"},"nativeSrc":"740:14:1","nodeType":"YulFunctionCall","src":"740:14:1"}],"functionName":{"name":"eq","nativeSrc":"717:2:1","nodeType":"YulIdentifier","src":"717:2:1"},"nativeSrc":"717:38:1","nodeType":"YulFunctionCall","src":"717:38:1"},"nativeSrc":"714:84:1","nodeType":"YulIf","src":"714:84:1"}]},"name":"extract_byte_array_length","nativeSrc":"484:320:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"data","nativeSrc":"519:4:1","nodeType":"YulTypedName","src":"519:4:1","type":""}],"returnVariables":[{"name":"length","nativeSrc":"528:6:1","nodeType":"YulTypedName","src":"528:6:1","type":""}],"src":"484:320:1"},{"body":{"nativeSrc":"864:87:1","nodeType":"YulBlock","src":"864:87:1","statements":[{"nativeSrc":"874:11:1","nodeType":"YulAssignment","src":"874:11:1","value":{"name":"ptr","nativeSrc":"882:3:1","nodeType":"YulIdentifier","src":"882:3:1"},"variableNames":[{"name":"data","nativeSrc":"874:4:1","nodeType":"YulIdentifier","src":"874:4:1"}]},{"expression":{"arguments":[{"kind":"number","nativeSrc":"902:1:1","nodeType":"YulLiteral","src":"902:1:1","type":"","value":"0"},{"name":"ptr","nativeSrc":"905:3:1","nodeType":"YulIdentifier","src":"905:3:1"}],"functionName":{"name":"mstore","nativeSrc":"895:6:1","nodeType":"YulIdentifier","src":"895:6:1"},"nativeSrc":"895:14:1","nodeType":"YulFunctionCall","src":"895:14:1"},"nativeSrc":"895:14:1","nodeType":"YulExpressionStatement","src":"895:14:1"},{"nativeSrc":"918:26:1","nodeType":"YulAssignment","src":"918:26:1","value":{"arguments":[{"kind":"number","nativeSrc":"936:1:1","nodeType":"YulLiteral","src":"936:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"939:4:1","nodeType":"YulLiteral","src":"939:4:1","type":"","value":"0x20"}],"functionName":{"name":"keccak256","nativeSrc":"926:9:1","nodeType":"YulIdentifier","src":"926:9:1"},"nativeSrc":"926:18:1","nodeType":"YulFunctionCall","src":"926:18:1"},"variableNames":[{"name":"data","nativeSrc":"918:4:1","nodeType":"YulIdentifier","src":"918:4:1"}]}]},"name":"array_dataslot_t_string_storage","nativeSrc":"810:141:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"ptr","nativeSrc":"851:3:1","nodeType":"YulTypedName","src":"851:3:1","type":""}],"returnVariables":[{"name":"data","nativeSrc":"859:4:1","nodeType":"YulTypedName","src":"859:4:1","type":""}],"src":"810:141:1"},{"body":{"nativeSrc":"1001:49:1","nodeType":"YulBlock","src":"1001:49:1","statements":[{"nativeSrc":"1011:33:1","nodeType":"YulAssignment","src":"1011:33:1","value":{"arguments":[{"arguments":[{"name":"value","nativeSrc":"1029:5:1","nodeType":"YulIdentifier","src":"1029:5:1"},{"kind":"number","nativeSrc":"1036:2:1","nodeType":"YulLiteral","src":"1036:2:1","type":"","value":"31"}],"functionName":{"name":"add","nativeSrc":"1025:3:1","nodeType":"YulIdentifier","src":"1025:3:1"},"nativeSrc":"1025:14:1","nodeType":"YulFunctionCall","src":"1025:14:1"},{"kind":"number","nativeSrc":"1041:2:1","nodeType":"YulLiteral","src":"1041:2:1","type":"","value":"32"}],"functionName":{"name":"div","nativeSrc":"1021:3:1","nodeType":"YulIdentifier","src":"1021:3:1"},"nativeSrc":"1021:23:1","nodeType":"YulFunctionCall","src":"1021:23:1"},"variableNames":[{"name":"result","nativeSrc":"1011:6:1","nodeType":"YulIdentifier","src":"1011:6:1"}]}]},"name":"divide_by_32_ceil","nativeSrc":"957:93:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"984:5:1","nodeType":"YulTypedName","src":"984:5:1","type":""}],"returnVariables":[{"name":"result","nativeSrc":"994:6:1","nodeType":"YulTypedName","src":"994:6:1","type":""}],"src":"957:93:1"},{"body":{"nativeSrc":"1109:54:1","nodeType":"YulBlock","src":"1109:54:1","statements":[{"nativeSrc":"1119:37:1","nodeType":"YulAssignment","src":"1119:37:1","value":{"arguments":[{"name":"bits","nativeSrc":"1144:4:1","nodeType":"YulIdentifier","src":"1144:4:1"},{"name":"value","nativeSrc":"1150:5:1","nodeType":"YulIdentifier","src":"1150:5:1"}],"functionName":{"name":"shl","nativeSrc":"1140:3:1","nodeType":"YulIdentifier","src":"1140:3:1"},"nativeSrc":"1140:16:1","nodeType":"YulFunctionCall","src":"1140:16:1"},"variableNames":[{"name":"newValue","nativeSrc":"1119:8:1","nodeType":"YulIdentifier","src":"1119:8:1"}]}]},"name":"shift_left_dynamic","nativeSrc":"1056:107:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"bits","nativeSrc":"1084:4:1","nodeType":"YulTypedName","src":"1084:4:1","type":""},{"name":"value","nativeSrc":"1090:5:1","nodeType":"YulTypedName","src":"1090:5:1","type":""}],"returnVariables":[{"name":"newValue","nativeSrc":"1100:8:1","nodeType":"YulTypedName","src":"1100:8:1","type":""}],"src":"1056:107:1"},{"body":{"nativeSrc":"1245:317:1","nodeType":"YulBlock","src":"1245:317:1","statements":[{"nativeSrc":"1255:35:1","nodeType":"YulVariableDeclaration","src":"1255:35:1","value":{"arguments":[{"name":"shiftBytes","nativeSrc":"1276:10:1","nodeType":"YulIdentifier","src":"1276:10:1"},{"kind":"number","nativeSrc":"1288:1:1","nodeType":"YulLiteral","src":"1288:1:1","type":"","value":"8"}],"functionName":{"name":"mul","nativeSrc":"1272:3:1","nodeType":"YulIdentifier","src":"1272:3:1"},"nativeSrc":"1272:18:1","nodeType":"YulFunctionCall","src":"1272:18:1"},"variables":[{"name":"shiftBits","nativeSrc":"1259:9:1","nodeType":"YulTypedName","src":"1259:9:1","type":""}]},{"nativeSrc":"1299:109:1","nodeType":"YulVariableDeclaration","src":"1299:109:1","value":{"arguments":[{"name":"shiftBits","nativeSrc":"1330:9:1","nodeType":"YulIdentifier","src":"1330:9:1"},{"kind":"number","nativeSrc":"1341:66:1","nodeType":"YulLiteral","src":"1341:66:1","type":"","value":"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"}],"functionName":{"name":"shift_left_dynamic","nativeSrc":"1311:18:1","nodeType":"YulIdentifier","src":"1311:18:1"},"nativeSrc":"1311:97:1","nodeType":"YulFunctionCall","src":"1311:97:1"},"variables":[{"name":"mask","nativeSrc":"1303:4:1","nodeType":"YulTypedName","src":"1303:4:1","type":""}]},{"nativeSrc":"1417:51:1","nodeType":"YulAssignment","src":"1417:51:1","value":{"arguments":[{"name":"shiftBits","nativeSrc":"1448:9:1","nodeType":"YulIdentifier","src":"1448:9:1"},{"name":"toInsert","nativeSrc":"1459:8:1","nodeType":"YulIdentifier","src":"1459:8:1"}],"functionName":{"name":"shift_left_dynamic","nativeSrc":"1429:18:1","nodeType":"YulIdentifier","src":"1429:18:1"},"nativeSrc":"1429:39:1","nodeType":"YulFunctionCall","src":"1429:39:1"},"variableNames":[{"name":"toInsert","nativeSrc":"1417:8:1","nodeType":"YulIdentifier","src":"1417:8:1"}]},{"nativeSrc":"1477:30:1","nodeType":"YulAssignment","src":"1477:30:1","value":{"arguments":[{"name":"value","nativeSrc":"1490:5:1","nodeType":"YulIdentifier","src":"1490:5:1"},{"arguments":[{"name":"mask","nativeSrc":"1501:4:1","nodeType":"YulIdentifier","src":"1501:4:1"}],"functionName":{"name":"not","nativeSrc":"1497:3:1","nodeType":"YulIdentifier","src":"1497:3:1"},"nativeSrc":"1497:9:1","nodeType":"YulFunctionCall","src":"1497:9:1"}],"functionName":{"name":"and","nativeSrc":"1486:3:1","nodeType":"YulIdentifier","src":"1486:3:1"},"nativeSrc":"1486:21:1","nodeType":"YulFunctionCall","src":"1486:21:1"},"variableNames":[{"name":"value","nativeSrc":"1477:5:1","nodeType":"YulIdentifier","src":"1477:5:1"}]},{"nativeSrc":"1516:40:1","nodeType":"YulAssignment","src":"1516:40:1","value":{"arguments":[{"name":"value","nativeSrc":"1529:5:1","nodeType":"YulIdentifier","src":"1529:5:1"},{"arguments":[{"name":"toInsert","nativeSrc":"1540:8:1","nodeType":"YulIdentifier","src":"1540:8:1"},{"name":"mask","nativeSrc":"1550:4:1","nodeType":"YulIdentifier","src":"1550:4:1"}],"functionName":{"name":"and","nativeSrc":"1536:3:1","nodeType":"YulIdentifier","src":"1536:3:1"},"nativeSrc":"1536:19:1","nodeType":"YulFunctionCall","src":"1536:19:1"}],"functionName":{"name":"or","nativeSrc":"1526:2:1","nodeType":"YulIdentifier","src":"1526:2:1"},"nativeSrc":"1526:30:1","nodeType":"YulFunctionCall","src":"1526:30:1"},"variableNames":[{"name":"result","nativeSrc":"1516:6:1","nodeType":"YulIdentifier","src":"1516:6:1"}]}]},"name":"update_byte_slice_dynamic32","nativeSrc":"1169:393:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"1206:5:1","nodeType":"YulTypedName","src":"1206:5:1","type":""},{"name":"shiftBytes","nativeSrc":"1213:10:1","nodeType":"YulTypedName","src":"1213:10:1","type":""},{"name":"toInsert","nativeSrc":"1225:8:1","nodeType":"YulTypedName","src":"1225:8:1","type":""}],"returnVariables":[{"name":"result","nativeSrc":"1238:6:1","nodeType":"YulTypedName","src":"1238:6:1","type":""}],"src":"1169:393:1"},{"body":{"nativeSrc":"1613:32:1","nodeType":"YulBlock","src":"1613:32:1","statements":[{"nativeSrc":"1623:16:1","nodeType":"YulAssignment","src":"1623:16:1","value":{"name":"value","nativeSrc":"1634:5:1","nodeType":"YulIdentifier","src":"1634:5:1"},"variableNames":[{"name":"cleaned","nativeSrc":"1623:7:1","nodeType":"YulIdentifier","src":"1623:7:1"}]}]},"name":"cleanup_t_uint256","nativeSrc":"1568:77:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"1595:5:1","nodeType":"YulTypedName","src":"1595:5:1","type":""}],"returnVariables":[{"name":"cleaned","nativeSrc":"1605:7:1","nodeType":"YulTypedName","src":"1605:7:1","type":""}],"src":"1568:77:1"},{"body":{"nativeSrc":"1683:28:1","nodeType":"YulBlock","src":"1683:28:1","statements":[{"nativeSrc":"1693:12:1","nodeType":"YulAssignment","src":"1693:12:1","value":{"name":"value","nativeSrc":"1700:5:1","nodeType":"YulIdentifier","src":"1700:5:1"},"variableNames":[{"name":"ret","nativeSrc":"1693:3:1","nodeType":"YulIdentifier","src":"1693:3:1"}]}]},"name":"identity","nativeSrc":"1651:60:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"1669:5:1","nodeType":"YulTypedName","src":"1669:5:1","type":""}],"returnVariables":[{"name":"ret","nativeSrc":"1679:3:1","nodeType":"YulTypedName","src":"1679:3:1","type":""}],"src":"1651:60:1"},{"body":{"nativeSrc":"1777:82:1","nodeType":"YulBlock","src":"1777:82:1","statements":[{"nativeSrc":"1787:66:1","nodeType":"YulAssignment","src":"1787:66:1","value":{"arguments":[{"arguments":[{"arguments":[{"name":"value","nativeSrc":"1845:5:1","nodeType":"YulIdentifier","src":"1845:5:1"}],"functionName":{"name":"cleanup_t_uint256","nativeSrc":"1827:17:1","nodeType":"YulIdentifier","src":"1827:17:1"},"nativeSrc":"1827:24:1","nodeType":"YulFunctionCall","src":"1827:24:1"}],"functionName":{"name":"identity","nativeSrc":"1818:8:1","nodeType":"YulIdentifier","src":"1818:8:1"},"nativeSrc":"1818:34:1","nodeType":"YulFunctionCall","src":"1818:34:1"}],"functionName":{"name":"cleanup_t_uint256","nativeSrc":"1800:17:1","nodeType":"YulIdentifier","src":"1800:17:1"},"nativeSrc":"1800:53:1","nodeType":"YulFunctionCall","src":"1800:53:1"},"variableNames":[{"name":"converted","nativeSrc":"1787:9:1","nodeType":"YulIdentifier","src":"1787:9:1"}]}]},"name":"convert_t_uint256_to_t_uint256","nativeSrc":"1717:142:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"1757:5:1","nodeType":"YulTypedName","src":"1757:5:1","type":""}],"returnVariables":[{"name":"converted","nativeSrc":"1767:9:1","nodeType":"YulTypedName","src":"1767:9:1","type":""}],"src":"1717:142:1"},{"body":{"nativeSrc":"1912:28:1","nodeType":"YulBlock","src":"1912:28:1","statements":[{"nativeSrc":"1922:12:1","nodeType":"YulAssignment","src":"1922:12:1","value":{"name":"value","nativeSrc":"1929:5:1","nodeType":"YulIdentifier","src":"1929:5:1"},"variableNames":[{"name":"ret","nativeSrc":"1922:3:1","nodeType":"YulIdentifier","src":"1922:3:1"}]}]},"name":"prepare_store_t_uint256","nativeSrc":"1865:75:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"1898:5:1","nodeType":"YulTypedName","src":"1898:5:1","type":""}],"returnVariables":[{"name":"ret","nativeSrc":"1908:3:1","nodeType":"YulTypedName","src":"1908:3:1","type":""}],"src":"1865:75:1"},{"body":{"nativeSrc":"2022:193:1","nodeType":"YulBlock","src":"2022:193:1","statements":[{"nativeSrc":"2032:63:1","nodeType":"YulVariableDeclaration","src":"2032:63:1","value":{"arguments":[{"name":"value_0","nativeSrc":"2087:7:1","nodeType":"YulIdentifier","src":"2087:7:1"}],"functionName":{"name":"convert_t_uint256_to_t_uint256","nativeSrc":"2056:30:1","nodeType":"YulIdentifier","src":"2056:30:1"},"nativeSrc":"2056:39:1","nodeType":"YulFunctionCall","src":"2056:39:1"},"variables":[{"name":"convertedValue_0","nativeSrc":"2036:16:1","nodeType":"YulTypedName","src":"2036:16:1","type":""}]},{"expression":{"arguments":[{"name":"slot","nativeSrc":"2111:4:1","nodeType":"YulIdentifier","src":"2111:4:1"},{"arguments":[{"arguments":[{"name":"slot","nativeSrc":"2151:4:1","nodeType":"YulIdentifier","src":"2151:4:1"}],"functionName":{"name":"sload","nativeSrc":"2145:5:1","nodeType":"YulIdentifier","src":"2145:5:1"},"nativeSrc":"2145:11:1","nodeType":"YulFunctionCall","src":"2145:11:1"},{"name":"offset","nativeSrc":"2158:6:1","nodeType":"YulIdentifier","src":"2158:6:1"},{"arguments":[{"name":"convertedValue_0","nativeSrc":"2190:16:1","nodeType":"YulIdentifier","src":"2190:16:1"}],"functionName":{"name":"prepare_store_t_uint256","nativeSrc":"2166:23:1","nodeType":"YulIdentifier","src":"2166:23:1"},"nativeSrc":"2166:41:1","nodeType":"YulFunctionCall","src":"2166:41:1"}],"functionName":{"name":"update_byte_slice_dynamic32","nativeSrc":"2117:27:1","nodeType":"YulIdentifier","src":"2117:27:1"},"nativeSrc":"2117:91:1","nodeType":"YulFunctionCall","src":"2117:91:1"}],"functionName":{"name":"sstore","nativeSrc":"2104:6:1","nodeType":"YulIdentifier","src":"2104:6:1"},"nativeSrc":"2104:105:1","nodeType":"YulFunctionCall","src":"2104:105:1"},"nativeSrc":"2104:105:1","nodeType":"YulExpressionStatement","src":"2104:105:1"}]},"name":"update_storage_value_t_uint256_to_t_uint256","nativeSrc":"1946:269:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"slot","nativeSrc":"1999:4:1","nodeType":"YulTypedName","src":"1999:4:1","type":""},{"name":"offset","nativeSrc":"2005:6:1","nodeType":"YulTypedName","src":"2005:6:1","type":""},{"name":"value_0","nativeSrc":"2013:7:1","nodeType":"YulTypedName","src":"2013:7:1","type":""}],"src":"1946:269:1"},{"body":{"nativeSrc":"2270:24:1","nodeType":"YulBlock","src":"2270:24:1","statements":[{"nativeSrc":"2280:8:1","nodeType":"YulAssignment","src":"2280:8:1","value":{"kind":"number","nativeSrc":"2287:1:1","nodeType":"YulLiteral","src":"2287:1:1","type":"","value":"0"},"variableNames":[{"name":"ret","nativeSrc":"2280:3:1","nodeType":"YulIdentifier","src":"2280:3:1"}]}]},"name":"zero_value_for_split_t_uint256","nativeSrc":"2221:73:1","nodeType":"YulFunctionDefinition","returnVariables":[{"name":"ret","nativeSrc":"2266:3:1","nodeType":"YulTypedName","src":"2266:3:1","type":""}],"src":"2221:73:1"},{"body":{"nativeSrc":"2353:136:1","nodeType":"YulBlock","src":"2353:136:1","statements":[{"nativeSrc":"2363:46:1","nodeType":"YulVariableDeclaration","src":"2363:46:1","value":{"arguments":[],"functionName":{"name":"zero_value_for_split_t_uint256","nativeSrc":"2377:30:1","nodeType":"YulIdentifier","src":"2377:30:1"},"nativeSrc":"2377:32:1","nodeType":"YulFunctionCall","src":"2377:32:1"},"variables":[{"name":"zero_0","nativeSrc":"2367:6:1","nodeType":"YulTypedName","src":"2367:6:1","type":""}]},{"expression":{"arguments":[{"name":"slot","nativeSrc":"2462:4:1","nodeType":"YulIdentifier","src":"2462:4:1"},{"name":"offset","nativeSrc":"2468:6:1","nodeType":"YulIdentifier","src":"2468:6:1"},{"name":"zero_0","nativeSrc":"2476:6:1","nodeType":"YulIdentifier","src":"2476:6:1"}],"functionName":{"name":"update_storage_value_t_uint256_to_t_uint256","nativeSrc":"2418:43:1","nodeType":"YulIdentifier","src":"2418:43:1"},"nativeSrc":"2418:65:1","nodeType":"YulFunctionCall","src":"2418:65:1"},"nativeSrc":"2418:65:1","nodeType":"YulExpressionStatement","src":"2418:65:1"}]},"name":"storage_set_to_zero_t_uint256","nativeSrc":"2300:189:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"slot","nativeSrc":"2339:4:1","nodeType":"YulTypedName","src":"2339:4:1","type":""},{"name":"offset","nativeSrc":"2345:6:1","nodeType":"YulTypedName","src":"2345:6:1","type":""}],"src":"2300:189:1"},{"body":{"nativeSrc":"2545:136:1","nodeType":"YulBlock","src":"2545:136:1","statements":[{"body":{"nativeSrc":"2612:63:1","nodeType":"YulBlock","src":"2612:63:1","statements":[{"expression":{"arguments":[{"name":"start","nativeSrc":"2656:5:1","nodeType":"YulIdentifier","src":"2656:5:1"},{"kind":"number","nativeSrc":"2663:1:1","nodeType":"YulLiteral","src":"2663:1:1","type":"","value":"0"}],"functionName":{"name":"storage_set_to_zero_t_uint256","nativeSrc":"2626:29:1","nodeType":"YulIdentifier","src":"2626:29:1"},"nativeSrc":"2626:39:1","nodeType":"YulFunctionCall","src":"2626:39:1"},"nativeSrc":"2626:39:1","nodeType":"YulExpressionStatement","src":"2626:39:1"}]},"condition":{"arguments":[{"name":"start","nativeSrc":"2565:5:1","nodeType":"YulIdentifier","src":"2565:5:1"},{"name":"end","nativeSrc":"2572:3:1","nodeType":"YulIdentifier","src":"2572:3:1"}],"functionName":{"name":"lt","nativeSrc":"2562:2:1","nodeType":"YulIdentifier","src":"2562:2:1"},"nativeSrc":"2562:14:1","nodeType":"YulFunctionCall","src":"2562:14:1"},"nativeSrc":"2555:120:1","nodeType":"YulForLoop","post":{"nativeSrc":"2577:26:1","nodeType":"YulBlock","src":"2577:26:1","statements":[{"nativeSrc":"2579:22:1","nodeType":"YulAssignment","src":"2579:22:1","value":{"arguments":[{"name":"start","nativeSrc":"2592:5:1","nodeType":"YulIdentifier","src":"2592:5:1"},{"kind":"number","nativeSrc":"2599:1:1","nodeType":"YulLiteral","src":"2599:1:1","type":"","value":"1"}],"functionName":{"name":"add","nativeSrc":"2588:3:1","nodeType":"YulIdentifier","src":"2588:3:1"},"nativeSrc":"2588:13:1","nodeType":"YulFunctionCall","src":"2588:13:1"},"variableNames":[{"name":"start","nativeSrc":"2579:5:1","nodeType":"YulIdentifier","src":"2579:5:1"}]}]},"pre":{"nativeSrc":"2559:2:1","nodeType":"YulBlock","src":"2559:2:1","statements":[]},"src":"2555:120:1"}]},"name":"clear_storage_range_t_bytes1","nativeSrc":"2495:186:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"start","nativeSrc":"2533:5:1","nodeType":"YulTypedName","src":"2533:5:1","type":""},{"name":"end","nativeSrc":"2540:3:1","nodeType":"YulTypedName","src":"2540:3:1","type":""}],"src":"2495:186:1"},{"body":{"nativeSrc":"2766:464:1","nodeType":"YulBlock","src":"2766:464:1","statements":[{"body":{"nativeSrc":"2792:431:1","nodeType":"YulBlock","src":"2792:431:1","statements":[{"nativeSrc":"2806:54:1","nodeType":"YulVariableDeclaration","src":"2806:54:1","value":{"arguments":[{"name":"array","nativeSrc":"2854:5:1","nodeType":"YulIdentifier","src":"2854:5:1"}],"functionName":{"name":"array_dataslot_t_string_storage","nativeSrc":"2822:31:1","nodeType":"YulIdentifier","src":"2822:31:1"},"nativeSrc":"2822:38:1","nodeType":"YulFunctionCall","src":"2822:38:1"},"variables":[{"name":"dataArea","nativeSrc":"2810:8:1","nodeType":"YulTypedName","src":"2810:8:1","type":""}]},{"nativeSrc":"2873:63:1","nodeType":"YulVariableDeclaration","src":"2873:63:1","value":{"arguments":[{"name":"dataArea","nativeSrc":"2896:8:1","nodeType":"YulIdentifier","src":"2896:8:1"},{"arguments":[{"name":"startIndex","nativeSrc":"2924:10:1","nodeType":"YulIdentifier","src":"2924:10:1"}],"functionName":{"name":"divide_by_32_ceil","nativeSrc":"2906:17:1","nodeType":"YulIdentifier","src":"2906:17:1"},"nativeSrc":"2906:29:1","nodeType":"YulFunctionCall","src":"2906:29:1"}],"functionName":{"name":"add","nativeSrc":"2892:3:1","nodeType":"YulIdentifier","src":"2892:3:1"},"nativeSrc":"2892:44:1","nodeType":"YulFunctionCall","src":"2892:44:1"},"variables":[{"name":"deleteStart","nativeSrc":"2877:11:1","nodeType":"YulTypedName","src":"2877:11:1","type":""}]},{"body":{"nativeSrc":"3093:27:1","nodeType":"YulBlock","src":"3093:27:1","statements":[{"nativeSrc":"3095:23:1","nodeType":"YulAssignment","src":"3095:23:1","value":{"name":"dataArea","nativeSrc":"3110:8:1","nodeType":"YulIdentifier","src":"3110:8:1"},"variableNames":[{"name":"deleteStart","nativeSrc":"3095:11:1","nodeType":"YulIdentifier","src":"3095:11:1"}]}]},"condition":{"arguments":[{"name":"startIndex","nativeSrc":"3077:10:1","nodeType":"YulIdentifier","src":"3077:10:1"},{"kind":"number","nativeSrc":"3089:2:1","nodeType":"YulLiteral","src":"3089:2:1","type":"","value":"32"}],"functionName":{"name":"lt","nativeSrc":"3074:2:1","nodeType":"YulIdentifier","src":"3074:2:1"},"nativeSrc":"3074:18:1","nodeType":"YulFunctionCall","src":"3074:18:1"},"nativeSrc":"3071:49:1","nodeType":"YulIf","src":"3071:49:1"},{"expression":{"arguments":[{"name":"deleteStart","nativeSrc":"3162:11:1","nodeType":"YulIdentifier","src":"3162:11:1"},{"arguments":[{"name":"dataArea","nativeSrc":"3179:8:1","nodeType":"YulIdentifier","src":"3179:8:1"},{"arguments":[{"name":"len","nativeSrc":"3207:3:1","nodeType":"YulIdentifier","src":"3207:3:1"}],"functionName":{"name":"divide_by_32_ceil","nativeSrc":"3189:17:1","nodeType":"YulIdentifier","src":"3189:17:1"},"nativeSrc":"3189:22:1","nodeType":"YulFunctionCall","src":"3189:22:1"}],"functionName":{"name":"add","nativeSrc":"3175:3:1","nodeType":"YulIdentifier","src":"3175:3:1"},"nativeSrc":"3175:37:1","nodeType":"YulFunctionCall","src":"3175:37:1"}],"functionName":{"name":"clear_storage_range_t_bytes1","nativeSrc":"3133:28:1","nodeType":"YulIdentifier","src":"3133:28:1"},"nativeSrc":"3133:80:1","nodeType":"YulFunctionCall","src":"3133:80:1"},"nativeSrc":"3133:80:1","nodeType":"YulExpressionStatement","src":"3133:80:1"}]},"condition":{"arguments":[{"name":"len","nativeSrc":"2783:3:1","nodeType":"YulIdentifier","src":"2783:3:1"},{"kind":"number","nativeSrc":"2788:2:1","nodeType":"YulLiteral","src":"2788:2:1","type":"","value":"31"}],"functionName":{"name":"gt","nativeSrc":"2780:2:1","nodeType":"YulIdentifier","src":"2780:2:1"},"nativeSrc":"2780:11:1","nodeType":"YulFunctionCall","src":"2780:11:1"},"nativeSrc":"2777:446:1","nodeType":"YulIf","src":"2777:446:1"}]},"name":"clean_up_bytearray_end_slots_t_string_storage","nativeSrc":"2687:543:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"array","nativeSrc":"2742:5:1","nodeType":"YulTypedName","src":"2742:5:1","type":""},{"name":"len","nativeSrc":"2749:3:1","nodeType":"YulTypedName","src":"2749:3:1","type":""},{"name":"startIndex","nativeSrc":"2754:10:1","nodeType":"YulTypedName","src":"2754:10:1","type":""}],"src":"2687:543:1"},{"body":{"nativeSrc":"3299:54:1","nodeType":"YulBlock","src":"3299:54:1","statements":[{"nativeSrc":"3309:37:1","nodeType":"YulAssignment","src":"3309:37:1","value":{"arguments":[{"name":"bits","nativeSrc":"3334:4:1","nodeType":"YulIdentifier","src":"3334:4:1"},{"name":"value","nativeSrc":"3340:5:1","nodeType":"YulIdentifier","src":"3340:5:1"}],"functionName":{"name":"shr","nativeSrc":"3330:3:1","nodeType":"YulIdentifier","src":"3330:3:1"},"nativeSrc":"3330:16:1","nodeType":"YulFunctionCall","src":"3330:16:1"},"variableNames":[{"name":"newValue","nativeSrc":"3309:8:1","nodeType":"YulIdentifier","src":"3309:8:1"}]}]},"name":"shift_right_unsigned_dynamic","nativeSrc":"3236:117:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"bits","nativeSrc":"3274:4:1","nodeType":"YulTypedName","src":"3274:4:1","type":""},{"name":"value","nativeSrc":"3280:5:1","nodeType":"YulTypedName","src":"3280:5:1","type":""}],"returnVariables":[{"name":"newValue","nativeSrc":"3290:8:1","nodeType":"YulTypedName","src":"3290:8:1","type":""}],"src":"3236:117:1"},{"body":{"nativeSrc":"3410:118:1","nodeType":"YulBlock","src":"3410:118:1","statements":[{"nativeSrc":"3420:68:1","nodeType":"YulVariableDeclaration","src":"3420:68:1","value":{"arguments":[{"arguments":[{"arguments":[{"kind":"number","nativeSrc":"3469:1:1","nodeType":"YulLiteral","src":"3469:1:1","type":"","value":"8"},{"name":"bytes","nativeSrc":"3472:5:1","nodeType":"YulIdentifier","src":"3472:5:1"}],"functionName":{"name":"mul","nativeSrc":"3465:3:1","nodeType":"YulIdentifier","src":"3465:3:1"},"nativeSrc":"3465:13:1","nodeType":"YulFunctionCall","src":"3465:13:1"},{"arguments":[{"kind":"number","nativeSrc":"3484:1:1","nodeType":"YulLiteral","src":"3484:1:1","type":"","value":"0"}],"functionName":{"name":"not","nativeSrc":"3480:3:1","nodeType":"YulIdentifier","src":"3480:3:1"},"nativeSrc":"3480:6:1","nodeType":"YulFunctionCall","src":"3480:6:1"}],"functionName":{"name":"shift_right_unsigned_dynamic","nativeSrc":"3436:28:1","nodeType":"YulIdentifier","src":"3436:28:1"},"nativeSrc":"3436:51:1","nodeType":"YulFunctionCall","src":"3436:51:1"}],"functionName":{"name":"not","nativeSrc":"3432:3:1","nodeType":"YulIdentifier","src":"3432:3:1"},"nativeSrc":"3432:56:1","nodeType":"YulFunctionCall","src":"3432:56:1"},"variables":[{"name":"mask","nativeSrc":"3424:4:1","nodeType":"YulTypedName","src":"3424:4:1","type":""}]},{"nativeSrc":"3497:25:1","nodeType":"YulAssignment","src":"3497:25:1","value":{"arguments":[{"name":"data","nativeSrc":"3511:4:1","nodeType":"YulIdentifier","src":"3511:4:1"},{"name":"mask","nativeSrc":"3517:4:1","nodeType":"YulIdentifier","src":"3517:4:1"}],"functionName":{"name":"and","nativeSrc":"3507:3:1","nodeType":"YulIdentifier","src":"3507:3:1"},"nativeSrc":"3507:15:1","nodeType":"YulFunctionCall","src":"3507:15:1"},"variableNames":[{"name":"result","nativeSrc":"3497:6:1","nodeType":"YulIdentifier","src":"3497:6:1"}]}]},"name":"mask_bytes_dynamic","nativeSrc":"3359:169:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"data","nativeSrc":"3387:4:1","nodeType":"YulTypedName","src":"3387:4:1","type":""},{"name":"bytes","nativeSrc":"3393:5:1","nodeType":"YulTypedName","src":"3393:5:1","type":""}],"returnVariables":[{"name":"result","nativeSrc":"3403:6:1","nodeType":"YulTypedName","src":"3403:6:1","type":""}],"src":"3359:169:1"},{"body":{"nativeSrc":"3614:214:1","nodeType":"YulBlock","src":"3614:214:1","statements":[{"nativeSrc":"3747:37:1","nodeType":"YulAssignment","src":"3747:37:1","value":{"arguments":[{"name":"data","nativeSrc":"3774:4:1","nodeType":"YulIdentifier","src":"3774:4:1"},{"name":"len","nativeSrc":"3780:3:1","nodeType":"YulIdentifier","src":"3780:3:1"}],"functionName":{"name":"mask_bytes_dynamic","nativeSrc":"3755:18:1","nodeType":"YulIdentifier","src":"3755:18:1"},"nativeSrc":"3755:29:1","nodeType":"YulFunctionCall","src":"3755:29:1"},"variableNames":[{"name":"data","nativeSrc":"3747:4:1","nodeType":"YulIdentifier","src":"3747:4:1"}]},{"nativeSrc":"3793:29:1","nodeType":"YulAssignment","src":"3793:29:1","value":{"arguments":[{"name":"data","nativeSrc":"3804:4:1","nodeType":"YulIdentifier","src":"3804:4:1"},{"arguments":[{"kind":"number","nativeSrc":"3814:1:1","nodeType":"YulLiteral","src":"3814:1:1","type":"","value":"2"},{"name":"len","nativeSrc":"3817:3:1","nodeType":"YulIdentifier","src":"3817:3:1"}],"functionName":{"name":"mul","nativeSrc":"3810:3:1","nodeType":"YulIdentifier","src":"3810:3:1"},"nativeSrc":"3810:11:1","nodeType":"YulFunctionCall","src":"3810:11:1"}],"functionName":{"name":"or","nativeSrc":"3801:2:1","nodeType":"YulIdentifier","src":"3801:2:1"},"nativeSrc":"3801:21:1","nodeType":"YulFunctionCall","src":"3801:21:1"},"variableNames":[{"name":"used","nativeSrc":"3793:4:1","nodeType":"YulIdentifier","src":"3793:4:1"}]}]},"name":"extract_used_part_and_set_length_of_short_byte_array","nativeSrc":"3533:295:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"data","nativeSrc":"3595:4:1","nodeType":"YulTypedName","src":"3595:4:1","type":""},{"name":"len","nativeSrc":"3601:3:1","nodeType":"YulTypedName","src":"3601:3:1","type":""}],"returnVariables":[{"name":"used","nativeSrc":"3609:4:1","nodeType":"YulTypedName","src":"3609:4:1","type":""}],"src":"3533:295:1"},{"body":{"nativeSrc":"3925:1303:1","nodeType":"YulBlock","src":"3925:1303:1","statements":[{"nativeSrc":"3936:51:1","nodeType":"YulVariableDeclaration","src":"3936:51:1","value":{"arguments":[{"name":"src","nativeSrc":"3983:3:1","nodeType":"YulIdentifier","src":"3983:3:1"}],"functionName":{"name":"array_length_t_string_memory_ptr","nativeSrc":"3950:32:1","nodeType":"YulIdentifier","src":"3950:32:1"},"nativeSrc":"3950:37:1","nodeType":"YulFunctionCall","src":"3950:37:1"},"variables":[{"name":"newLen","nativeSrc":"3940:6:1","nodeType":"YulTypedName","src":"3940:6:1","type":""}]},{"body":{"nativeSrc":"4072:22:1","nodeType":"YulBlock","src":"4072:22:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x41","nativeSrc":"4074:16:1","nodeType":"YulIdentifier","src":"4074:16:1"},"nativeSrc":"4074:18:1","nodeType":"YulFunctionCall","src":"4074:18:1"},"nativeSrc":"4074:18:1","nodeType":"YulExpressionStatement","src":"4074:18:1"}]},"condition":{"arguments":[{"name":"newLen","nativeSrc":"4044:6:1","nodeType":"YulIdentifier","src":"4044:6:1"},{"kind":"number","nativeSrc":"4052:18:1","nodeType":"YulLiteral","src":"4052:18:1","type":"","value":"0xffffffffffffffff"}],"functionName":{"name":"gt","nativeSrc":"4041:2:1","nodeType":"YulIdentifier","src":"4041:2:1"},"nativeSrc":"4041:30:1","nodeType":"YulFunctionCall","src":"4041:30:1"},"nativeSrc":"4038:56:1","nodeType":"YulIf","src":"4038:56:1"},{"nativeSrc":"4104:52:1","nodeType":"YulVariableDeclaration","src":"4104:52:1","value":{"arguments":[{"arguments":[{"name":"slot","nativeSrc":"4150:4:1","nodeType":"YulIdentifier","src":"4150:4:1"}],"functionName":{"name":"sload","nativeSrc":"4144:5:1","nodeType":"YulIdentifier","src":"4144:5:1"},"nativeSrc":"4144:11:1","nodeType":"YulFunctionCall","src":"4144:11:1"}],"functionName":{"name":"extract_byte_array_length","nativeSrc":"4118:25:1","nodeType":"YulIdentifier","src":"4118:25:1"},"nativeSrc":"4118:38:1","nodeType":"YulFunctionCall","src":"4118:38:1"},"variables":[{"name":"oldLen","nativeSrc":"4108:6:1","nodeType":"YulTypedName","src":"4108:6:1","type":""}]},{"expression":{"arguments":[{"name":"slot","nativeSrc":"4249:4:1","nodeType":"YulIdentifier","src":"4249:4:1"},{"name":"oldLen","nativeSrc":"4255:6:1","nodeType":"YulIdentifier","src":"4255:6:1"},{"name":"newLen","nativeSrc":"4263:6:1","nodeType":"YulIdentifier","src":"4263:6:1"}],"functionName":{"name":"clean_up_bytearray_end_slots_t_string_storage","nativeSrc":"4203:45:1","nodeType":"YulIdentifier","src":"4203:45:1"},"nativeSrc":"4203:67:1","nodeType":"YulFunctionCall","src":"4203:67:1"},"nativeSrc":"4203:67:1","nodeType":"YulExpressionStatement","src":"4203:67:1"},{"nativeSrc":"4280:18:1","nodeType":"YulVariableDeclaration","src":"4280:18:1","value":{"kind":"number","nativeSrc":"4297:1:1","nodeType":"YulLiteral","src":"4297:1:1","type":"","value":"0"},"variables":[{"name":"srcOffset","nativeSrc":"4284:9:1","nodeType":"YulTypedName","src":"4284:9:1","type":""}]},{"nativeSrc":"4308:17:1","nodeType":"YulAssignment","src":"4308:17:1","value":{"kind":"number","nativeSrc":"4321:4:1","nodeType":"YulLiteral","src":"4321:4:1","type":"","value":"0x20"},"variableNames":[{"name":"srcOffset","nativeSrc":"4308:9:1","nodeType":"YulIdentifier","src":"4308:9:1"}]},{"cases":[{"body":{"nativeSrc":"4372:611:1","nodeType":"YulBlock","src":"4372:611:1","statements":[{"nativeSrc":"4386:37:1","nodeType":"YulVariableDeclaration","src":"4386:37:1","value":{"arguments":[{"name":"newLen","nativeSrc":"4405:6:1","nodeType":"YulIdentifier","src":"4405:6:1"},{"arguments":[{"kind":"number","nativeSrc":"4417:4:1","nodeType":"YulLiteral","src":"4417:4:1","type":"","value":"0x1f"}],"functionName":{"name":"not","nativeSrc":"4413:3:1","nodeType":"YulIdentifier","src":"4413:3:1"},"nativeSrc":"4413:9:1","nodeType":"YulFunctionCall","src":"4413:9:1"}],"functionName":{"name":"and","nativeSrc":"4401:3:1","nodeType":"YulIdentifier","src":"4401:3:1"},"nativeSrc":"4401:22:1","nodeType":"YulFunctionCall","src":"4401:22:1"},"variables":[{"name":"loopEnd","nativeSrc":"4390:7:1","nodeType":"YulTypedName","src":"4390:7:1","type":""}]},{"nativeSrc":"4437:51:1","nodeType":"YulVariableDeclaration","src":"4437:51:1","value":{"arguments":[{"name":"slot","nativeSrc":"4483:4:1","nodeType":"YulIdentifier","src":"4483:4:1"}],"functionName":{"name":"array_dataslot_t_string_storage","nativeSrc":"4451:31:1","nodeType":"YulIdentifier","src":"4451:31:1"},"nativeSrc":"4451:37:1","nodeType":"YulFunctionCall","src":"4451:37:1"},"variables":[{"name":"dstPtr","nativeSrc":"4441:6:1","nodeType":"YulTypedName","src":"4441:6:1","type":""}]},{"nativeSrc":"4501:10:1","nodeType":"YulVariableDeclaration","src":"4501:10:1","value":{"kind":"number","nativeSrc":"4510:1:1","nodeType":"YulLiteral","src":"4510:1:1","type":"","value":"0"},"variables":[{"name":"i","nativeSrc":"4505:1:1","nodeType":"YulTypedName","src":"4505:1:1","type":""}]},{"body":{"nativeSrc":"4569:163:1","nodeType":"YulBlock","src":"4569:163:1","statements":[{"expression":{"arguments":[{"name":"dstPtr","nativeSrc":"4594:6:1","nodeType":"YulIdentifier","src":"4594:6:1"},{"arguments":[{"arguments":[{"name":"src","nativeSrc":"4612:3:1","nodeType":"YulIdentifier","src":"4612:3:1"},{"name":"srcOffset","nativeSrc":"4617:9:1","nodeType":"YulIdentifier","src":"4617:9:1"}],"functionName":{"name":"add","nativeSrc":"4608:3:1","nodeType":"YulIdentifier","src":"4608:3:1"},"nativeSrc":"4608:19:1","nodeType":"YulFunctionCall","src":"4608:19:1"}],"functionName":{"name":"mload","nativeSrc":"4602:5:1","nodeType":"YulIdentifier","src":"4602:5:1"},"nativeSrc":"4602:26:1","nodeType":"YulFunctionCall","src":"4602:26:1"}],"functionName":{"name":"sstore","nativeSrc":"4587:6:1","nodeType":"YulIdentifier","src":"4587:6:1"},"nativeSrc":"4587:42:1","nodeType":"YulFunctionCall","src":"4587:42:1"},"nativeSrc":"4587:42:1","nodeType":"YulExpressionStatement","src":"4587:42:1"},{"nativeSrc":"4646:24:1","nodeType":"YulAssignment","src":"4646:24:1","value":{"arguments":[{"name":"dstPtr","nativeSrc":"4660:6:1","nodeType":"YulIdentifier","src":"4660:6:1"},{"kind":"number","nativeSrc":"4668:1:1","nodeType":"YulLiteral","src":"4668:1:1","type":"","value":"1"}],"functionName":{"name":"add","nativeSrc":"4656:3:1","nodeType":"YulIdentifier","src":"4656:3:1"},"nativeSrc":"4656:14:1","nodeType":"YulFunctionCall","src":"4656:14:1"},"variableNames":[{"name":"dstPtr","nativeSrc":"4646:6:1","nodeType":"YulIdentifier","src":"4646:6:1"}]},{"nativeSrc":"4687:31:1","nodeType":"YulAssignment","src":"4687:31:1","value":{"arguments":[{"name":"srcOffset","nativeSrc":"4704:9:1","nodeType":"YulIdentifier","src":"4704:9:1"},{"kind":"number","nativeSrc":"4715:2:1","nodeType":"YulLiteral","src":"4715:2:1","type":"","value":"32"}],"functionName":{"name":"add","nativeSrc":"4700:3:1","nodeType":"YulIdentifier","src":"4700:3:1"},"nativeSrc":"4700:18:1","nodeType":"YulFunctionCall","src":"4700:18:1"},"variableNames":[{"name":"srcOffset","nativeSrc":"4687:9:1","nodeType":"YulIdentifier","src":"4687:9:1"}]}]},"condition":{"arguments":[{"name":"i","nativeSrc":"4535:1:1","nodeType":"YulIdentifier","src":"4535:1:1"},{"name":"loopEnd","nativeSrc":"4538:7:1","nodeType":"YulIdentifier","src":"4538:7:1"}],"functionName":{"name":"lt","nativeSrc":"4532:2:1","nodeType":"YulIdentifier","src":"4532:2:1"},"nativeSrc":"4532:14:1","nodeType":"YulFunctionCall","src":"4532:14:1"},"nativeSrc":"4524:208:1","nodeType":"YulForLoop","post":{"nativeSrc":"4547:21:1","nodeType":"YulBlock","src":"4547:21:1","statements":[{"nativeSrc":"4549:17:1","nodeType":"YulAssignment","src":"4549:17:1","value":{"arguments":[{"name":"i","nativeSrc":"4558:1:1","nodeType":"YulIdentifier","src":"4558:1:1"},{"kind":"number","nativeSrc":"4561:4:1","nodeType":"YulLiteral","src":"4561:4:1","type":"","value":"0x20"}],"functionName":{"name":"add","nativeSrc":"4554:3:1","nodeType":"YulIdentifier","src":"4554:3:1"},"nativeSrc":"4554:12:1","nodeType":"YulFunctionCall","src":"4554:12:1"},"variableNames":[{"name":"i","nativeSrc":"4549:1:1","nodeType":"YulIdentifier","src":"4549:1:1"}]}]},"pre":{"nativeSrc":"4528:3:1","nodeType":"YulBlock","src":"4528:3:1","statements":[]},"src":"4524:208:1"},{"body":{"nativeSrc":"4768:156:1","nodeType":"YulBlock","src":"4768:156:1","statements":[{"nativeSrc":"4786:43:1","nodeType":"YulVariableDeclaration","src":"4786:43:1","value":{"arguments":[{"arguments":[{"name":"src","nativeSrc":"4813:3:1","nodeType":"YulIdentifier","src":"4813:3:1"},{"name":"srcOffset","nativeSrc":"4818:9:1","nodeType":"YulIdentifier","src":"4818:9:1"}],"functionName":{"name":"add","nativeSrc":"4809:3:1","nodeType":"YulIdentifier","src":"4809:3:1"},"nativeSrc":"4809:19:1","nodeType":"YulFunctionCall","src":"4809:19:1"}],"functionName":{"name":"mload","nativeSrc":"4803:5:1","nodeType":"YulIdentifier","src":"4803:5:1"},"nativeSrc":"4803:26:1","nodeType":"YulFunctionCall","src":"4803:26:1"},"variables":[{"name":"lastValue","nativeSrc":"4790:9:1","nodeType":"YulTypedName","src":"4790:9:1","type":""}]},{"expression":{"arguments":[{"name":"dstPtr","nativeSrc":"4853:6:1","nodeType":"YulIdentifier","src":"4853:6:1"},{"arguments":[{"name":"lastValue","nativeSrc":"4880:9:1","nodeType":"YulIdentifier","src":"4880:9:1"},{"arguments":[{"name":"newLen","nativeSrc":"4895:6:1","nodeType":"YulIdentifier","src":"4895:6:1"},{"kind":"number","nativeSrc":"4903:4:1","nodeType":"YulLiteral","src":"4903:4:1","type":"","value":"0x1f"}],"functionName":{"name":"and","nativeSrc":"4891:3:1","nodeType":"YulIdentifier","src":"4891:3:1"},"nativeSrc":"4891:17:1","nodeType":"YulFunctionCall","src":"4891:17:1"}],"functionName":{"name":"mask_bytes_dynamic","nativeSrc":"4861:18:1","nodeType":"YulIdentifier","src":"4861:18:1"},"nativeSrc":"4861:48:1","nodeType":"YulFunctionCall","src":"4861:48:1"}],"functionName":{"name":"sstore","nativeSrc":"4846:6:1","nodeType":"YulIdentifier","src":"4846:6:1"},"nativeSrc":"4846:64:1","nodeType":"YulFunctionCall","src":"4846:64:1"},"nativeSrc":"4846:64:1","nodeType":"YulExpressionStatement","src":"4846:64:1"}]},"condition":{"arguments":[{"name":"loopEnd","nativeSrc":"4751:7:1","nodeType":"YulIdentifier","src":"4751:7:1"},{"name":"newLen","nativeSrc":"4760:6:1","nodeType":"YulIdentifier","src":"4760:6:1"}],"functionName":{"name":"lt","nativeSrc":"4748:2:1","nodeType":"YulIdentifier","src":"4748:2:1"},"nativeSrc":"4748:19:1","nodeType":"YulFunctionCall","src":"4748:19:1"},"nativeSrc":"4745:179:1","nodeType":"YulIf","src":"4745:179:1"},{"expression":{"arguments":[{"name":"slot","nativeSrc":"4944:4:1","nodeType":"YulIdentifier","src":"4944:4:1"},{"arguments":[{"arguments":[{"name":"newLen","nativeSrc":"4958:6:1","nodeType":"YulIdentifier","src":"4958:6:1"},{"kind":"number","nativeSrc":"4966:1:1","nodeType":"YulLiteral","src":"4966:1:1","type":"","value":"2"}],"functionName":{"name":"mul","nativeSrc":"4954:3:1","nodeType":"YulIdentifier","src":"4954:3:1"},"nativeSrc":"4954:14:1","nodeType":"YulFunctionCall","src":"4954:14:1"},{"kind":"number","nativeSrc":"4970:1:1","nodeType":"YulLiteral","src":"4970:1:1","type":"","value":"1"}],"functionName":{"name":"add","nativeSrc":"4950:3:1","nodeType":"YulIdentifier","src":"4950:3:1"},"nativeSrc":"4950:22:1","nodeType":"YulFunctionCall","src":"4950:22:1"}],"functionName":{"name":"sstore","nativeSrc":"4937:6:1","nodeType":"YulIdentifier","src":"4937:6:1"},"nativeSrc":"4937:36:1","nodeType":"YulFunctionCall","src":"4937:36:1"},"nativeSrc":"4937:36:1","nodeType":"YulExpressionStatement","src":"4937:36:1"}]},"nativeSrc":"4365:618:1","nodeType":"YulCase","src":"4365:618:1","value":{"kind":"number","nativeSrc":"4370:1:1","nodeType":"YulLiteral","src":"4370:1:1","type":"","value":"1"}},{"body":{"nativeSrc":"5000:222:1","nodeType":"YulBlock","src":"5000:222:1","statements":[{"nativeSrc":"5014:14:1","nodeType":"YulVariableDeclaration","src":"5014:14:1","value":{"kind":"number","nativeSrc":"5027:1:1","nodeType":"YulLiteral","src":"5027:1:1","type":"","value":"0"},"variables":[{"name":"value","nativeSrc":"5018:5:1","nodeType":"YulTypedName","src":"5018:5:1","type":""}]},{"body":{"nativeSrc":"5051:67:1","nodeType":"YulBlock","src":"5051:67:1","statements":[{"nativeSrc":"5069:35:1","nodeType":"YulAssignment","src":"5069:35:1","value":{"arguments":[{"arguments":[{"name":"src","nativeSrc":"5088:3:1","nodeType":"YulIdentifier","src":"5088:3:1"},{"name":"srcOffset","nativeSrc":"5093:9:1","nodeType":"YulIdentifier","src":"5093:9:1"}],"functionName":{"name":"add","nativeSrc":"5084:3:1","nodeType":"YulIdentifier","src":"5084:3:1"},"nativeSrc":"5084:19:1","nodeType":"YulFunctionCall","src":"5084:19:1"}],"functionName":{"name":"mload","nativeSrc":"5078:5:1","nodeType":"YulIdentifier","src":"5078:5:1"},"nativeSrc":"5078:26:1","nodeType":"YulFunctionCall","src":"5078:26:1"},"variableNames":[{"name":"value","nativeSrc":"5069:5:1","nodeType":"YulIdentifier","src":"5069:5:1"}]}]},"condition":{"name":"newLen","nativeSrc":"5044:6:1","nodeType":"YulIdentifier","src":"5044:6:1"},"nativeSrc":"5041:77:1","nodeType":"YulIf","src":"5041:77:1"},{"expression":{"arguments":[{"name":"slot","nativeSrc":"5138:4:1","nodeType":"YulIdentifier","src":"5138:4:1"},{"arguments":[{"name":"value","nativeSrc":"5197:5:1","nodeType":"YulIdentifier","src":"5197:5:1"},{"name":"newLen","nativeSrc":"5204:6:1","nodeType":"YulIdentifier","src":"5204:6:1"}],"functionName":{"name":"extract_used_part_and_set_length_of_short_byte_array","nativeSrc":"5144:52:1","nodeType":"YulIdentifier","src":"5144:52:1"},"nativeSrc":"5144:67:1","nodeType":"YulFunctionCall","src":"5144:67:1"}],"functionName":{"name":"sstore","nativeSrc":"5131:6:1","nodeType":"YulIdentifier","src":"5131:6:1"},"nativeSrc":"5131:81:1","nodeType":"YulFunctionCall","src":"5131:81:1"},"nativeSrc":"5131:81:1","nodeType":"YulExpressionStatement","src":"5131:81:1"}]},"nativeSrc":"4992:230:1","nodeType":"YulCase","src":"4992:230:1","value":"default"}],"expression":{"arguments":[{"name":"newLen","nativeSrc":"4345:6:1","nodeType":"YulIdentifier","src":"4345:6:1"},{"kind":"number","nativeSrc":"4353:2:1","nodeType":"YulLiteral","src":"4353:2:1","type":"","value":"31"}],"functionName":{"name":"gt","nativeSrc":"4342:2:1","nodeType":"YulIdentifier","src":"4342:2:1"},"nativeSrc":"4342:14:1","nodeType":"YulFunctionCall","src":"4342:14:1"},"nativeSrc":"4335:887:1","nodeType":"YulSwitch","src":"4335:887:1"}]},"name":"copy_byte_array_to_storage_from_t_string_memory_ptr_to_t_string_storage","nativeSrc":"3833:1395:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"slot","nativeSrc":"3914:4:1","nodeType":"YulTypedName","src":"3914:4:1","type":""},{"name":"src","nativeSrc":"3920:3:1","nodeType":"YulTypedName","src":"3920:3:1","type":""}],"src":"3833:1395:1"},{"body":{"nativeSrc":"5262:152:1","nodeType":"YulBlock","src":"5262:152:1","statements":[{"expression":{"arguments":[{"kind":"number","nativeSrc":"5279:1:1","nodeType":"YulLiteral","src":"5279:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"5282:77:1","nodeType":"YulLiteral","src":"5282:77:1","type":"","value":"35408467139433450592217433187231851964531694900788300625387963629091585785856"}],"functionName":{"name":"mstore","nativeSrc":"5272:6:1","nodeType":"YulIdentifier","src":"5272:6:1"},"nativeSrc":"5272:88:1","nodeType":"YulFunctionCall","src":"5272:88:1"},"nativeSrc":"5272:88:1","nodeType":"YulExpressionStatement","src":"5272:88:1"},{"expression":{"arguments":[{"kind":"number","nativeSrc":"5376:1:1","nodeType":"YulLiteral","src":"5376:1:1","type":"","value":"4"},{"kind":"number","nativeSrc":"5379:4:1","nodeType":"YulLiteral","src":"5379:4:1","type":"","value":"0x11"}],"functionName":{"name":"mstore","nativeSrc":"5369:6:1","nodeType":"YulIdentifier","src":"5369:6:1"},"nativeSrc":"5369:15:1","nodeType":"YulFunctionCall","src":"5369:15:1"},"nativeSrc":"5369:15:1","nodeType":"YulExpressionStatement","src":"5369:15:1"},{"expression":{"arguments":[{"kind":"number","nativeSrc":"5400:1:1","nodeType":"YulLiteral","src":"5400:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"5403:4:1","nodeType":"YulLiteral","src":"5403:4:1","type":"","value":"0x24"}],"functionName":{"name":"revert","nativeSrc":"5393:6:1","nodeType":"YulIdentifier","src":"5393:6:1"},"nativeSrc":"5393:15:1","nodeType":"YulFunctionCall","src":"5393:15:1"},"nativeSrc":"5393:15:1","nodeType":"YulExpressionStatement","src":"5393:15:1"}]},"name":"panic_error_0x11","nativeSrc":"5234:180:1","nodeType":"YulFunctionDefinition","src":"5234:180:1"},{"body":{"nativeSrc":"5471:51:1","nodeType":"YulBlock","src":"5471:51:1","statements":[{"nativeSrc":"5481:34:1","nodeType":"YulAssignment","src":"5481:34:1","value":{"arguments":[{"kind":"number","nativeSrc":"5506:1:1","nodeType":"YulLiteral","src":"5506:1:1","type":"","value":"1"},{"name":"value","nativeSrc":"5509:5:1","nodeType":"YulIdentifier","src":"5509:5:1"}],"functionName":{"name":"shr","nativeSrc":"5502:3:1","nodeType":"YulIdentifier","src":"5502:3:1"},"nativeSrc":"5502:13:1","nodeType":"YulFunctionCall","src":"5502:13:1"},"variableNames":[{"name":"newValue","nativeSrc":"5481:8:1","nodeType":"YulIdentifier","src":"5481:8:1"}]}]},"name":"shift_right_1_unsigned","nativeSrc":"5420:102:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"5452:5:1","nodeType":"YulTypedName","src":"5452:5:1","type":""}],"returnVariables":[{"name":"newValue","nativeSrc":"5462:8:1","nodeType":"YulTypedName","src":"5462:8:1","type":""}],"src":"5420:102:1"},{"body":{"nativeSrc":"5601:775:1","nodeType":"YulBlock","src":"5601:775:1","statements":[{"nativeSrc":"5611:15:1","nodeType":"YulAssignment","src":"5611:15:1","value":{"name":"_power","nativeSrc":"5620:6:1","nodeType":"YulIdentifier","src":"5620:6:1"},"variableNames":[{"name":"power","nativeSrc":"5611:5:1","nodeType":"YulIdentifier","src":"5611:5:1"}]},{"nativeSrc":"5635:14:1","nodeType":"YulAssignment","src":"5635:14:1","value":{"name":"_base","nativeSrc":"5644:5:1","nodeType":"YulIdentifier","src":"5644:5:1"},"variableNames":[{"name":"base","nativeSrc":"5635:4:1","nodeType":"YulIdentifier","src":"5635:4:1"}]},{"body":{"nativeSrc":"5693:677:1","nodeType":"YulBlock","src":"5693:677:1","statements":[{"body":{"nativeSrc":"5781:22:1","nodeType":"YulBlock","src":"5781:22:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x11","nativeSrc":"5783:16:1","nodeType":"YulIdentifier","src":"5783:16:1"},"nativeSrc":"5783:18:1","nodeType":"YulFunctionCall","src":"5783:18:1"},"nativeSrc":"5783:18:1","nodeType":"YulExpressionStatement","src":"5783:18:1"}]},"condition":{"arguments":[{"name":"base","nativeSrc":"5759:4:1","nodeType":"YulIdentifier","src":"5759:4:1"},{"arguments":[{"name":"max","nativeSrc":"5769:3:1","nodeType":"YulIdentifier","src":"5769:3:1"},{"name":"base","nativeSrc":"5774:4:1","nodeType":"YulIdentifier","src":"5774:4:1"}],"functionName":{"name":"div","nativeSrc":"5765:3:1","nodeType":"YulIdentifier","src":"5765:3:1"},"nativeSrc":"5765:14:1","nodeType":"YulFunctionCall","src":"5765:14:1"}],"functionName":{"name":"gt","nativeSrc":"5756:2:1","nodeType":"YulIdentifier","src":"5756:2:1"},"nativeSrc":"5756:24:1","nodeType":"YulFunctionCall","src":"5756:24:1"},"nativeSrc":"5753:50:1","nodeType":"YulIf","src":"5753:50:1"},{"body":{"nativeSrc":"5848:419:1","nodeType":"YulBlock","src":"5848:419:1","statements":[{"nativeSrc":"6228:25:1","nodeType":"YulAssignment","src":"6228:25:1","value":{"arguments":[{"name":"power","nativeSrc":"6241:5:1","nodeType":"YulIdentifier","src":"6241:5:1"},{"name":"base","nativeSrc":"6248:4:1","nodeType":"YulIdentifier","src":"6248:4:1"}],"functionName":{"name":"mul","nativeSrc":"6237:3:1","nodeType":"YulIdentifier","src":"6237:3:1"},"nativeSrc":"6237:16:1","nodeType":"YulFunctionCall","src":"6237:16:1"},"variableNames":[{"name":"power","nativeSrc":"6228:5:1","nodeType":"YulIdentifier","src":"6228:5:1"}]}]},"condition":{"arguments":[{"name":"exponent","nativeSrc":"5823:8:1","nodeType":"YulIdentifier","src":"5823:8:1"},{"kind":"number","nativeSrc":"5833:1:1","nodeType":"YulLiteral","src":"5833:1:1","type":"","value":"1"}],"functionName":{"name":"and","nativeSrc":"5819:3:1","nodeType":"YulIdentifier","src":"5819:3:1"},"nativeSrc":"5819:16:1","nodeType":"YulFunctionCall","src":"5819:16:1"},"nativeSrc":"5816:451:1","nodeType":"YulIf","src":"5816:451:1"},{"nativeSrc":"6280:23:1","nodeType":"YulAssignment","src":"6280:23:1","value":{"arguments":[{"name":"base","nativeSrc":"6292:4:1","nodeType":"YulIdentifier","src":"6292:4:1"},{"name":"base","nativeSrc":"6298:4:1","nodeType":"YulIdentifier","src":"6298:4:1"}],"functionName":{"name":"mul","nativeSrc":"6288:3:1","nodeType":"YulIdentifier","src":"6288:3:1"},"nativeSrc":"6288:15:1","nodeType":"YulFunctionCall","src":"6288:15:1"},"variableNames":[{"name":"base","nativeSrc":"6280:4:1","nodeType":"YulIdentifier","src":"6280:4:1"}]},{"nativeSrc":"6316:44:1","nodeType":"YulAssignment","src":"6316:44:1","value":{"arguments":[{"name":"exponent","nativeSrc":"6351:8:1","nodeType":"YulIdentifier","src":"6351:8:1"}],"functionName":{"name":"shift_right_1_unsigned","nativeSrc":"6328:22:1","nodeType":"YulIdentifier","src":"6328:22:1"},"nativeSrc":"6328:32:1","nodeType":"YulFunctionCall","src":"6328:32:1"},"variableNames":[{"name":"exponent","nativeSrc":"6316:8:1","nodeType":"YulIdentifier","src":"6316:8:1"}]}]},"condition":{"arguments":[{"name":"exponent","nativeSrc":"5669:8:1","nodeType":"YulIdentifier","src":"5669:8:1"},{"kind":"number","nativeSrc":"5679:1:1","nodeType":"YulLiteral","src":"5679:1:1","type":"","value":"1"}],"functionName":{"name":"gt","nativeSrc":"5666:2:1","nodeType":"YulIdentifier","src":"5666:2:1"},"nativeSrc":"5666:15:1","nodeType":"YulFunctionCall","src":"5666:15:1"},"nativeSrc":"5658:712:1","nodeType":"YulForLoop","post":{"nativeSrc":"5682:2:1","nodeType":"YulBlock","src":"5682:2:1","statements":[]},"pre":{"nativeSrc":"5662:3:1","nodeType":"YulBlock","src":"5662:3:1","statements":[]},"src":"5658:712:1"}]},"name":"checked_exp_helper","nativeSrc":"5528:848:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"_power","nativeSrc":"5556:6:1","nodeType":"YulTypedName","src":"5556:6:1","type":""},{"name":"_base","nativeSrc":"5564:5:1","nodeType":"YulTypedName","src":"5564:5:1","type":""},{"name":"exponent","nativeSrc":"5571:8:1","nodeType":"YulTypedName","src":"5571:8:1","type":""},{"name":"max","nativeSrc":"5581:3:1","nodeType":"YulTypedName","src":"5581:3:1","type":""}],"returnVariables":[{"name":"power","nativeSrc":"5589:5:1","nodeType":"YulTypedName","src":"5589:5:1","type":""},{"name":"base","nativeSrc":"5596:4:1","nodeType":"YulTypedName","src":"5596:4:1","type":""}],"src":"5528:848:1"},{"body":{"nativeSrc":"6442:1013:1","nodeType":"YulBlock","src":"6442:1013:1","statements":[{"body":{"nativeSrc":"6637:20:1","nodeType":"YulBlock","src":"6637:20:1","statements":[{"nativeSrc":"6639:10:1","nodeType":"YulAssignment","src":"6639:10:1","value":{"kind":"number","nativeSrc":"6648:1:1","nodeType":"YulLiteral","src":"6648:1:1","type":"","value":"1"},"variableNames":[{"name":"power","nativeSrc":"6639:5:1","nodeType":"YulIdentifier","src":"6639:5:1"}]},{"nativeSrc":"6650:5:1","nodeType":"YulLeave","src":"6650:5:1"}]},"condition":{"arguments":[{"name":"exponent","nativeSrc":"6627:8:1","nodeType":"YulIdentifier","src":"6627:8:1"}],"functionName":{"name":"iszero","nativeSrc":"6620:6:1","nodeType":"YulIdentifier","src":"6620:6:1"},"nativeSrc":"6620:16:1","nodeType":"YulFunctionCall","src":"6620:16:1"},"nativeSrc":"6617:40:1","nodeType":"YulIf","src":"6617:40:1"},{"body":{"nativeSrc":"6682:20:1","nodeType":"YulBlock","src":"6682:20:1","statements":[{"nativeSrc":"6684:10:1","nodeType":"YulAssignment","src":"6684:10:1","value":{"kind":"number","nativeSrc":"6693:1:1","nodeType":"YulLiteral","src":"6693:1:1","type":"","value":"0"},"variableNames":[{"name":"power","nativeSrc":"6684:5:1","nodeType":"YulIdentifier","src":"6684:5:1"}]},{"nativeSrc":"6695:5:1","nodeType":"YulLeave","src":"6695:5:1"}]},"condition":{"arguments":[{"name":"base","nativeSrc":"6676:4:1","nodeType":"YulIdentifier","src":"6676:4:1"}],"functionName":{"name":"iszero","nativeSrc":"6669:6:1","nodeType":"YulIdentifier","src":"6669:6:1"},"nativeSrc":"6669:12:1","nodeType":"YulFunctionCall","src":"6669:12:1"},"nativeSrc":"6666:36:1","nodeType":"YulIf","src":"6666:36:1"},{"cases":[{"body":{"nativeSrc":"6812:20:1","nodeType":"YulBlock","src":"6812:20:1","statements":[{"nativeSrc":"6814:10:1","nodeType":"YulAssignment","src":"6814:10:1","value":{"kind":"number","nativeSrc":"6823:1:1","nodeType":"YulLiteral","src":"6823:1:1","type":"","value":"1"},"variableNames":[{"name":"power","nativeSrc":"6814:5:1","nodeType":"YulIdentifier","src":"6814:5:1"}]},{"nativeSrc":"6825:5:1","nodeType":"YulLeave","src":"6825:5:1"}]},"nativeSrc":"6805:27:1","nodeType":"YulCase","src":"6805:27:1","value":{"kind":"number","nativeSrc":"6810:1:1","nodeType":"YulLiteral","src":"6810:1:1","type":"","value":"1"}},{"body":{"nativeSrc":"6856:176:1","nodeType":"YulBlock","src":"6856:176:1","statements":[{"body":{"nativeSrc":"6891:22:1","nodeType":"YulBlock","src":"6891:22:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x11","nativeSrc":"6893:16:1","nodeType":"YulIdentifier","src":"6893:16:1"},"nativeSrc":"6893:18:1","nodeType":"YulFunctionCall","src":"6893:18:1"},"nativeSrc":"6893:18:1","nodeType":"YulExpressionStatement","src":"6893:18:1"}]},"condition":{"arguments":[{"name":"exponent","nativeSrc":"6876:8:1","nodeType":"YulIdentifier","src":"6876:8:1"},{"kind":"number","nativeSrc":"6886:3:1","nodeType":"YulLiteral","src":"6886:3:1","type":"","value":"255"}],"functionName":{"name":"gt","nativeSrc":"6873:2:1","nodeType":"YulIdentifier","src":"6873:2:1"},"nativeSrc":"6873:17:1","nodeType":"YulFunctionCall","src":"6873:17:1"},"nativeSrc":"6870:43:1","nodeType":"YulIf","src":"6870:43:1"},{"nativeSrc":"6926:25:1","nodeType":"YulAssignment","src":"6926:25:1","value":{"arguments":[{"kind":"number","nativeSrc":"6939:1:1","nodeType":"YulLiteral","src":"6939:1:1","type":"","value":"2"},{"name":"exponent","nativeSrc":"6942:8:1","nodeType":"YulIdentifier","src":"6942:8:1"}],"functionName":{"name":"exp","nativeSrc":"6935:3:1","nodeType":"YulIdentifier","src":"6935:3:1"},"nativeSrc":"6935:16:1","nodeType":"YulFunctionCall","src":"6935:16:1"},"variableNames":[{"name":"power","nativeSrc":"6926:5:1","nodeType":"YulIdentifier","src":"6926:5:1"}]},{"body":{"nativeSrc":"6982:22:1","nodeType":"YulBlock","src":"6982:22:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x11","nativeSrc":"6984:16:1","nodeType":"YulIdentifier","src":"6984:16:1"},"nativeSrc":"6984:18:1","nodeType":"YulFunctionCall","src":"6984:18:1"},"nativeSrc":"6984:18:1","nodeType":"YulExpressionStatement","src":"6984:18:1"}]},"condition":{"arguments":[{"name":"power","nativeSrc":"6970:5:1","nodeType":"YulIdentifier","src":"6970:5:1"},{"name":"max","nativeSrc":"6977:3:1","nodeType":"YulIdentifier","src":"6977:3:1"}],"functionName":{"name":"gt","nativeSrc":"6967:2:1","nodeType":"YulIdentifier","src":"6967:2:1"},"nativeSrc":"6967:14:1","nodeType":"YulFunctionCall","src":"6967:14:1"},"nativeSrc":"6964:40:1","nodeType":"YulIf","src":"6964:40:1"},{"nativeSrc":"7017:5:1","nodeType":"YulLeave","src":"7017:5:1"}]},"nativeSrc":"6841:191:1","nodeType":"YulCase","src":"6841:191:1","value":{"kind":"number","nativeSrc":"6846:1:1","nodeType":"YulLiteral","src":"6846:1:1","type":"","value":"2"}}],"expression":{"name":"base","nativeSrc":"6762:4:1","nodeType":"YulIdentifier","src":"6762:4:1"},"nativeSrc":"6755:277:1","nodeType":"YulSwitch","src":"6755:277:1"},{"body":{"nativeSrc":"7164:123:1","nodeType":"YulBlock","src":"7164:123:1","statements":[{"nativeSrc":"7178:28:1","nodeType":"YulAssignment","src":"7178:28:1","value":{"arguments":[{"name":"base","nativeSrc":"7191:4:1","nodeType":"YulIdentifier","src":"7191:4:1"},{"name":"exponent","nativeSrc":"7197:8:1","nodeType":"YulIdentifier","src":"7197:8:1"}],"functionName":{"name":"exp","nativeSrc":"7187:3:1","nodeType":"YulIdentifier","src":"7187:3:1"},"nativeSrc":"7187:19:1","nodeType":"YulFunctionCall","src":"7187:19:1"},"variableNames":[{"name":"power","nativeSrc":"7178:5:1","nodeType":"YulIdentifier","src":"7178:5:1"}]},{"body":{"nativeSrc":"7237:22:1","nodeType":"YulBlock","src":"7237:22:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x11","nativeSrc":"7239:16:1","nodeType":"YulIdentifier","src":"7239:16:1"},"nativeSrc":"7239:18:1","nodeType":"YulFunctionCall","src":"7239:18:1"},"nativeSrc":"7239:18:1","nodeType":"YulExpressionStatement","src":"7239:18:1"}]},"condition":{"arguments":[{"name":"power","nativeSrc":"7225:5:1","nodeType":"YulIdentifier","src":"7225:5:1"},{"name":"max","nativeSrc":"7232:3:1","nodeType":"YulIdentifier","src":"7232:3:1"}],"functionName":{"name":"gt","nativeSrc":"7222:2:1","nodeType":"YulIdentifier","src":"7222:2:1"},"nativeSrc":"7222:14:1","nodeType":"YulFunctionCall","src":"7222:14:1"},"nativeSrc":"7219:40:1","nodeType":"YulIf","src":"7219:40:1"},{"nativeSrc":"7272:5:1","nodeType":"YulLeave","src":"7272:5:1"}]},"condition":{"arguments":[{"arguments":[{"arguments":[{"name":"base","nativeSrc":"7067:4:1","nodeType":"YulIdentifier","src":"7067:4:1"},{"kind":"number","nativeSrc":"7073:2:1","nodeType":"YulLiteral","src":"7073:2:1","type":"","value":"11"}],"functionName":{"name":"lt","nativeSrc":"7064:2:1","nodeType":"YulIdentifier","src":"7064:2:1"},"nativeSrc":"7064:12:1","nodeType":"YulFunctionCall","src":"7064:12:1"},{"arguments":[{"name":"exponent","nativeSrc":"7081:8:1","nodeType":"YulIdentifier","src":"7081:8:1"},{"kind":"number","nativeSrc":"7091:2:1","nodeType":"YulLiteral","src":"7091:2:1","type":"","value":"78"}],"functionName":{"name":"lt","nativeSrc":"7078:2:1","nodeType":"YulIdentifier","src":"7078:2:1"},"nativeSrc":"7078:16:1","nodeType":"YulFunctionCall","src":"7078:16:1"}],"functionName":{"name":"and","nativeSrc":"7060:3:1","nodeType":"YulIdentifier","src":"7060:3:1"},"nativeSrc":"7060:35:1","nodeType":"YulFunctionCall","src":"7060:35:1"},{"arguments":[{"arguments":[{"name":"base","nativeSrc":"7116:4:1","nodeType":"YulIdentifier","src":"7116:4:1"},{"kind":"number","nativeSrc":"7122:3:1","nodeType":"YulLiteral","src":"7122:3:1","type":"","value":"307"}],"functionName":{"name":"lt","nativeSrc":"7113:2:1","nodeType":"YulIdentifier","src":"7113:2:1"},"nativeSrc":"7113:13:1","nodeType":"YulFunctionCall","src":"7113:13:1"},{"arguments":[{"name":"exponent","nativeSrc":"7131:8:1","nodeType":"YulIdentifier","src":"7131:8:1"},{"kind":"number","nativeSrc":"7141:2:1","nodeType":"YulLiteral","src":"7141:2:1","type":"","value":"32"}],"functionName":{"name":"lt","nativeSrc":"7128:2:1","nodeType":"YulIdentifier","src":"7128:2:1"},"nativeSrc":"7128:16:1","nodeType":"YulFunctionCall","src":"7128:16:1"}],"functionName":{"name":"and","nativeSrc":"7109:3:1","nodeType":"YulIdentifier","src":"7109:3:1"},"nativeSrc":"7109:36:1","nodeType":"YulFunctionCall","src":"7109:36:1"}],"functionName":{"name":"or","nativeSrc":"7044:2:1","nodeType":"YulIdentifier","src":"7044:2:1"},"nativeSrc":"7044:111:1","nodeType":"YulFunctionCall","src":"7044:111:1"},"nativeSrc":"7041:246:1","nodeType":"YulIf","src":"7041:246:1"},{"nativeSrc":"7297:57:1","nodeType":"YulAssignment","src":"7297:57:1","value":{"arguments":[{"kind":"number","nativeSrc":"7331:1:1","nodeType":"YulLiteral","src":"7331:1:1","type":"","value":"1"},{"name":"base","nativeSrc":"7334:4:1","nodeType":"YulIdentifier","src":"7334:4:1"},{"name":"exponent","nativeSrc":"7340:8:1","nodeType":"YulIdentifier","src":"7340:8:1"},{"name":"max","nativeSrc":"7350:3:1","nodeType":"YulIdentifier","src":"7350:3:1"}],"functionName":{"name":"checked_exp_helper","nativeSrc":"7312:18:1","nodeType":"YulIdentifier","src":"7312:18:1"},"nativeSrc":"7312:42:1","nodeType":"YulFunctionCall","src":"7312:42:1"},"variableNames":[{"name":"power","nativeSrc":"7297:5:1","nodeType":"YulIdentifier","src":"7297:5:1"},{"name":"base","nativeSrc":"7304:4:1","nodeType":"YulIdentifier","src":"7304:4:1"}]},{"body":{"nativeSrc":"7393:22:1","nodeType":"YulBlock","src":"7393:22:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x11","nativeSrc":"7395:16:1","nodeType":"YulIdentifier","src":"7395:16:1"},"nativeSrc":"7395:18:1","nodeType":"YulFunctionCall","src":"7395:18:1"},"nativeSrc":"7395:18:1","nodeType":"YulExpressionStatement","src":"7395:18:1"}]},"condition":{"arguments":[{"name":"power","nativeSrc":"7370:5:1","nodeType":"YulIdentifier","src":"7370:5:1"},{"arguments":[{"name":"max","nativeSrc":"7381:3:1","nodeType":"YulIdentifier","src":"7381:3:1"},{"name":"base","nativeSrc":"7386:4:1","nodeType":"YulIdentifier","src":"7386:4:1"}],"functionName":{"name":"div","nativeSrc":"7377:3:1","nodeType":"YulIdentifier","src":"7377:3:1"},"nativeSrc":"7377:14:1","nodeType":"YulFunctionCall","src":"7377:14:1"}],"functionName":{"name":"gt","nativeSrc":"7367:2:1","nodeType":"YulIdentifier","src":"7367:2:1"},"nativeSrc":"7367:25:1","nodeType":"YulFunctionCall","src":"7367:25:1"},"nativeSrc":"7364:51:1","nodeType":"YulIf","src":"7364:51:1"},{"nativeSrc":"7424:25:1","nodeType":"YulAssignment","src":"7424:25:1","value":{"arguments":[{"name":"power","nativeSrc":"7437:5:1","nodeType":"YulIdentifier","src":"7437:5:1"},{"name":"base","nativeSrc":"7444:4:1","nodeType":"YulIdentifier","src":"7444:4:1"}],"functionName":{"name":"mul","nativeSrc":"7433:3:1","nodeType":"YulIdentifier","src":"7433:3:1"},"nativeSrc":"7433:16:1","nodeType":"YulFunctionCall","src":"7433:16:1"},"variableNames":[{"name":"power","nativeSrc":"7424:5:1","nodeType":"YulIdentifier","src":"7424:5:1"}]}]},"name":"checked_exp_unsigned","nativeSrc":"6382:1073:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"base","nativeSrc":"6412:4:1","nodeType":"YulTypedName","src":"6412:4:1","type":""},{"name":"exponent","nativeSrc":"6418:8:1","nodeType":"YulTypedName","src":"6418:8:1","type":""},{"name":"max","nativeSrc":"6428:3:1","nodeType":"YulTypedName","src":"6428:3:1","type":""}],"returnVariables":[{"name":"power","nativeSrc":"6436:5:1","nodeType":"YulTypedName","src":"6436:5:1","type":""}],"src":"6382:1073:1"},{"body":{"nativeSrc":"7527:219:1","nodeType":"YulBlock","src":"7527:219:1","statements":[{"nativeSrc":"7537:31:1","nodeType":"YulAssignment","src":"7537:31:1","value":{"arguments":[{"name":"base","nativeSrc":"7563:4:1","nodeType":"YulIdentifier","src":"7563:4:1"}],"functionName":{"name":"cleanup_t_uint256","nativeSrc":"7545:17:1","nodeType":"YulIdentifier","src":"7545:17:1"},"nativeSrc":"7545:23:1","nodeType":"YulFunctionCall","src":"7545:23:1"},"variableNames":[{"name":"base","nativeSrc":"7537:4:1","nodeType":"YulIdentifier","src":"7537:4:1"}]},{"nativeSrc":"7577:39:1","nodeType":"YulAssignment","src":"7577:39:1","value":{"arguments":[{"name":"exponent","nativeSrc":"7607:8:1","nodeType":"YulIdentifier","src":"7607:8:1"}],"functionName":{"name":"cleanup_t_uint256","nativeSrc":"7589:17:1","nodeType":"YulIdentifier","src":"7589:17:1"},"nativeSrc":"7589:27:1","nodeType":"YulFunctionCall","src":"7589:27:1"},"variableNames":[{"name":"exponent","nativeSrc":"7577:8:1","nodeType":"YulIdentifier","src":"7577:8:1"}]},{"nativeSrc":"7626:113:1","nodeType":"YulAssignment","src":"7626:113:1","value":{"arguments":[{"name":"base","nativeSrc":"7656:4:1","nodeType":"YulIdentifier","src":"7656:4:1"},{"name":"exponent","nativeSrc":"7662:8:1","nodeType":"YulIdentifier","src":"7662:8:1"},{"kind":"number","nativeSrc":"7672:66:1","nodeType":"YulLiteral","src":"7672:66:1","type":"","value":"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"}],"functionName":{"name":"checked_exp_unsigned","nativeSrc":"7635:20:1","nodeType":"YulIdentifier","src":"7635:20:1"},"nativeSrc":"7635:104:1","nodeType":"YulFunctionCall","src":"7635:104:1"},"variableNames":[{"name":"power","nativeSrc":"7626:5:1","nodeType":"YulIdentifier","src":"7626:5:1"}]}]},"name":"checked_exp_t_uint256_t_uint256","nativeSrc":"7461:285:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"base","nativeSrc":"7502:4:1","nodeType":"YulTypedName","src":"7502:4:1","type":""},{"name":"exponent","nativeSrc":"7508:8:1","nodeType":"YulTypedName","src":"7508:8:1","type":""}],"returnVariables":[{"name":"power","nativeSrc":"7521:5:1","nodeType":"YulTypedName","src":"7521:5:1","type":""}],"src":"7461:285:1"},{"body":{"nativeSrc":"7800:362:1","nodeType":"YulBlock","src":"7800:362:1","statements":[{"nativeSrc":"7810:25:1","nodeType":"YulAssignment","src":"7810:25:1","value":{"arguments":[{"name":"x","nativeSrc":"7833:1:1","nodeType":"YulIdentifier","src":"7833:1:1"}],"functionName":{"name":"cleanup_t_uint256","nativeSrc":"7815:17:1","nodeType":"YulIdentifier","src":"7815:17:1"},"nativeSrc":"7815:20:1","nodeType":"YulFunctionCall","src":"7815:20:1"},"variableNames":[{"name":"x","nativeSrc":"7810:1:1","nodeType":"YulIdentifier","src":"7810:1:1"}]},{"nativeSrc":"7844:25:1","nodeType":"YulAssignment","src":"7844:25:1","value":{"arguments":[{"name":"y","nativeSrc":"7867:1:1","nodeType":"YulIdentifier","src":"7867:1:1"}],"functionName":{"name":"cleanup_t_uint256","nativeSrc":"7849:17:1","nodeType":"YulIdentifier","src":"7849:17:1"},"nativeSrc":"7849:20:1","nodeType":"YulFunctionCall","src":"7849:20:1"},"variableNames":[{"name":"y","nativeSrc":"7844:1:1","nodeType":"YulIdentifier","src":"7844:1:1"}]},{"nativeSrc":"7878:28:1","nodeType":"YulVariableDeclaration","src":"7878:28:1","value":{"arguments":[{"name":"x","nativeSrc":"7901:1:1","nodeType":"YulIdentifier","src":"7901:1:1"},{"name":"y","nativeSrc":"7904:1:1","nodeType":"YulIdentifier","src":"7904:1:1"}],"functionName":{"name":"mul","nativeSrc":"7897:3:1","nodeType":"YulIdentifier","src":"7897:3:1"},"nativeSrc":"7897:9:1","nodeType":"YulFunctionCall","src":"7897:9:1"},"variables":[{"name":"product_raw","nativeSrc":"7882:11:1","nodeType":"YulTypedName","src":"7882:11:1","type":""}]},{"nativeSrc":"7915:41:1","nodeType":"YulAssignment","src":"7915:41:1","value":{"arguments":[{"name":"product_raw","nativeSrc":"7944:11:1","nodeType":"YulIdentifier","src":"7944:11:1"}],"functionName":{"name":"cleanup_t_uint256","nativeSrc":"7926:17:1","nodeType":"YulIdentifier","src":"7926:17:1"},"nativeSrc":"7926:30:1","nodeType":"YulFunctionCall","src":"7926:30:1"},"variableNames":[{"name":"product","nativeSrc":"7915:7:1","nodeType":"YulIdentifier","src":"7915:7:1"}]},{"body":{"nativeSrc":"8133:22:1","nodeType":"YulBlock","src":"8133:22:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x11","nativeSrc":"8135:16:1","nodeType":"YulIdentifier","src":"8135:16:1"},"nativeSrc":"8135:18:1","nodeType":"YulFunctionCall","src":"8135:18:1"},"nativeSrc":"8135:18:1","nodeType":"YulExpressionStatement","src":"8135:18:1"}]},"condition":{"arguments":[{"arguments":[{"arguments":[{"name":"x","nativeSrc":"8066:1:1","nodeType":"YulIdentifier","src":"8066:1:1"}],"functionName":{"name":"iszero","nativeSrc":"8059:6:1","nodeType":"YulIdentifier","src":"8059:6:1"},"nativeSrc":"8059:9:1","nodeType":"YulFunctionCall","src":"8059:9:1"},{"arguments":[{"name":"y","nativeSrc":"8089:1:1","nodeType":"YulIdentifier","src":"8089:1:1"},{"arguments":[{"name":"product","nativeSrc":"8096:7:1","nodeType":"YulIdentifier","src":"8096:7:1"},{"name":"x","nativeSrc":"8105:1:1","nodeType":"YulIdentifier","src":"8105:1:1"}],"functionName":{"name":"div","nativeSrc":"8092:3:1","nodeType":"YulIdentifier","src":"8092:3:1"},"nativeSrc":"8092:15:1","nodeType":"YulFunctionCall","src":"8092:15:1"}],"functionName":{"name":"eq","nativeSrc":"8086:2:1","nodeType":"YulIdentifier","src":"8086:2:1"},"nativeSrc":"8086:22:1","nodeType":"YulFunctionCall","src":"8086:22:1"}],"functionName":{"name":"or","nativeSrc":"8039:2:1","nodeType":"YulIdentifier","src":"8039:2:1"},"nativeSrc":"8039:83:1","nodeType":"YulFunctionCall","src":"8039:83:1"}],"functionName":{"name":"iszero","nativeSrc":"8019:6:1","nodeType":"YulIdentifier","src":"8019:6:1"},"nativeSrc":"8019:113:1","nodeType":"YulFunctionCall","src":"8019:113:1"},"nativeSrc":"8016:139:1","nodeType":"YulIf","src":"8016:139:1"}]},"name":"checked_mul_t_uint256","nativeSrc":"7752:410:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"x","nativeSrc":"7783:1:1","nodeType":"YulTypedName","src":"7783:1:1","type":""},{"name":"y","nativeSrc":"7786:1:1","nodeType":"YulTypedName","src":"7786:1:1","type":""}],"returnVariables":[{"name":"product","nativeSrc":"7792:7:1","nodeType":"YulTypedName","src":"7792:7:1","type":""}],"src":"7752:410:1"}]},"contents":"{\n\n    function array_length_t_string_memory_ptr(value) -> length {\n\n        length := mload(value)\n\n    }\n\n    function panic_error_0x41() {\n        mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)\n        mstore(4, 0x41)\n        revert(0, 0x24)\n    }\n\n    function panic_error_0x22() {\n        mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)\n        mstore(4, 0x22)\n        revert(0, 0x24)\n    }\n\n    function extract_byte_array_length(data) -> length {\n        length := div(data, 2)\n        let outOfPlaceEncoding := and(data, 1)\n        if iszero(outOfPlaceEncoding) {\n            length := and(length, 0x7f)\n        }\n\n        if eq(outOfPlaceEncoding, lt(length, 32)) {\n            panic_error_0x22()\n        }\n    }\n\n    function array_dataslot_t_string_storage(ptr) -> data {\n        data := ptr\n\n        mstore(0, ptr)\n        data := keccak256(0, 0x20)\n\n    }\n\n    function divide_by_32_ceil(value) -> result {\n        result := div(add(value, 31), 32)\n    }\n\n    function shift_left_dynamic(bits, value) -> newValue {\n        newValue :=\n\n        shl(bits, value)\n\n    }\n\n    function update_byte_slice_dynamic32(value, shiftBytes, toInsert) -> result {\n        let shiftBits := mul(shiftBytes, 8)\n        let mask := shift_left_dynamic(shiftBits, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n        toInsert := shift_left_dynamic(shiftBits, toInsert)\n        value := and(value, not(mask))\n        result := or(value, and(toInsert, mask))\n    }\n\n    function cleanup_t_uint256(value) -> cleaned {\n        cleaned := value\n    }\n\n    function identity(value) -> ret {\n        ret := value\n    }\n\n    function convert_t_uint256_to_t_uint256(value) -> converted {\n        converted := cleanup_t_uint256(identity(cleanup_t_uint256(value)))\n    }\n\n    function prepare_store_t_uint256(value) -> ret {\n        ret := value\n    }\n\n    function update_storage_value_t_uint256_to_t_uint256(slot, offset, value_0) {\n        let convertedValue_0 := convert_t_uint256_to_t_uint256(value_0)\n        sstore(slot, update_byte_slice_dynamic32(sload(slot), offset, prepare_store_t_uint256(convertedValue_0)))\n    }\n\n    function zero_value_for_split_t_uint256() -> ret {\n        ret := 0\n    }\n\n    function storage_set_to_zero_t_uint256(slot, offset) {\n        let zero_0 := zero_value_for_split_t_uint256()\n        update_storage_value_t_uint256_to_t_uint256(slot, offset, zero_0)\n    }\n\n    function clear_storage_range_t_bytes1(start, end) {\n        for {} lt(start, end) { start := add(start, 1) }\n        {\n            storage_set_to_zero_t_uint256(start, 0)\n        }\n    }\n\n    function clean_up_bytearray_end_slots_t_string_storage(array, len, startIndex) {\n\n        if gt(len, 31) {\n            let dataArea := array_dataslot_t_string_storage(array)\n            let deleteStart := add(dataArea, divide_by_32_ceil(startIndex))\n            // If we are clearing array to be short byte array, we want to clear only data starting from array data area.\n            if lt(startIndex, 32) { deleteStart := dataArea }\n            clear_storage_range_t_bytes1(deleteStart, add(dataArea, divide_by_32_ceil(len)))\n        }\n\n    }\n\n    function shift_right_unsigned_dynamic(bits, value) -> newValue {\n        newValue :=\n\n        shr(bits, value)\n\n    }\n\n    function mask_bytes_dynamic(data, bytes) -> result {\n        let mask := not(shift_right_unsigned_dynamic(mul(8, bytes), not(0)))\n        result := and(data, mask)\n    }\n    function extract_used_part_and_set_length_of_short_byte_array(data, len) -> used {\n        // we want to save only elements that are part of the array after resizing\n        // others should be set to zero\n        data := mask_bytes_dynamic(data, len)\n        used := or(data, mul(2, len))\n    }\n    function copy_byte_array_to_storage_from_t_string_memory_ptr_to_t_string_storage(slot, src) {\n\n        let newLen := array_length_t_string_memory_ptr(src)\n        // Make sure array length is sane\n        if gt(newLen, 0xffffffffffffffff) { panic_error_0x41() }\n\n        let oldLen := extract_byte_array_length(sload(slot))\n\n        // potentially truncate data\n        clean_up_bytearray_end_slots_t_string_storage(slot, oldLen, newLen)\n\n        let srcOffset := 0\n\n        srcOffset := 0x20\n\n        switch gt(newLen, 31)\n        case 1 {\n            let loopEnd := and(newLen, not(0x1f))\n\n            let dstPtr := array_dataslot_t_string_storage(slot)\n            let i := 0\n            for { } lt(i, loopEnd) { i := add(i, 0x20) } {\n                sstore(dstPtr, mload(add(src, srcOffset)))\n                dstPtr := add(dstPtr, 1)\n                srcOffset := add(srcOffset, 32)\n            }\n            if lt(loopEnd, newLen) {\n                let lastValue := mload(add(src, srcOffset))\n                sstore(dstPtr, mask_bytes_dynamic(lastValue, and(newLen, 0x1f)))\n            }\n            sstore(slot, add(mul(newLen, 2), 1))\n        }\n        default {\n            let value := 0\n            if newLen {\n                value := mload(add(src, srcOffset))\n            }\n            sstore(slot, extract_used_part_and_set_length_of_short_byte_array(value, newLen))\n        }\n    }\n\n    function panic_error_0x11() {\n        mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)\n        mstore(4, 0x11)\n        revert(0, 0x24)\n    }\n\n    function shift_right_1_unsigned(value) -> newValue {\n        newValue :=\n\n        shr(1, value)\n\n    }\n\n    function checked_exp_helper(_power, _base, exponent, max) -> power, base {\n        power := _power\n        base  := _base\n        for { } gt(exponent, 1) {}\n        {\n            // overflow check for base * base\n            if gt(base, div(max, base)) { panic_error_0x11() }\n            if and(exponent, 1)\n            {\n                // No checks for power := mul(power, base) needed, because the check\n                // for base * base above is sufficient, since:\n                // |power| <= base (proof by induction) and thus:\n                // |power * base| <= base * base <= max <= |min| (for signed)\n                // (this is equally true for signed and unsigned exp)\n                power := mul(power, base)\n            }\n            base := mul(base, base)\n            exponent := shift_right_1_unsigned(exponent)\n        }\n    }\n\n    function checked_exp_unsigned(base, exponent, max) -> power {\n        // This function currently cannot be inlined because of the\n        // \"leave\" statements. We have to improve the optimizer.\n\n        // Note that 0**0 == 1\n        if iszero(exponent) { power := 1 leave }\n        if iszero(base) { power := 0 leave }\n\n        // Specializations for small bases\n        switch base\n        // 0 is handled above\n        case 1 { power := 1 leave }\n        case 2\n        {\n            if gt(exponent, 255) { panic_error_0x11() }\n            power := exp(2, exponent)\n            if gt(power, max) { panic_error_0x11() }\n            leave\n        }\n        if or(\n            and(lt(base, 11), lt(exponent, 78)),\n            and(lt(base, 307), lt(exponent, 32))\n        )\n        {\n            power := exp(base, exponent)\n            if gt(power, max) { panic_error_0x11() }\n            leave\n        }\n\n        power, base := checked_exp_helper(1, base, exponent, max)\n\n        if gt(power, div(max, base)) { panic_error_0x11() }\n        power := mul(power, base)\n    }\n\n    function checked_exp_t_uint256_t_uint256(base, exponent) -> power {\n        base := cleanup_t_uint256(base)\n        exponent := cleanup_t_uint256(exponent)\n\n        power := checked_exp_unsigned(base, exponent, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n\n    }\n\n    function checked_mul_t_uint256(x, y) -> product {\n        x := cleanup_t_uint256(x)\n        y := cleanup_t_uint256(y)\n        let product_raw := mul(x, y)\n        product := cleanup_t_uint256(product_raw)\n\n        // overflow, if x != 0 and y != product/x\n        if iszero(\n            or(\n                iszero(x),\n                eq(y, div(product, x))\n            )\n        ) { panic_error_0x11() }\n\n    }\n\n}\n","id":1,"language":"Yul","name":"#utility.yul"}],"linkReferences":{},"object":"60806040526040518060400160405280600781526020017f4d79546f6b656e00000000000000000000000000000000000000000000000000815250600090816200004a9190620003b9565b506040518060400160405280600381526020017f4d4350000000000000000000000000000000000000000000000000000000000081525060019081620000919190620003b9565b506012600260006101000a81548160ff021916908360ff160217905550348015620000bb57600080fd5b50600260009054906101000a900460ff1660ff16600a620000dd919062000623565b620f4240620000ed919062000674565b600381905550600354600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550620006bf565b600081519050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680620001c157607f821691505b602082108103620001d757620001d662000179565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b600060088302620002417fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000202565b6200024d868362000202565b95508019841693508086168417925050509392505050565b6000819050919050565b6000819050919050565b60006200029a620002946200028e8462000265565b6200026f565b62000265565b9050919050565b6000819050919050565b620002b68362000279565b620002ce620002c582620002a1565b8484546200020f565b825550505050565b600090565b620002e5620002d6565b620002f2818484620002ab565b505050565b5b818110156200031a576200030e600082620002db565b600181019050620002f8565b5050565b601f82111562000369576200033381620001dd565b6200033e84620001f2565b810160208510156200034e578190505b620003666200035d85620001f2565b830182620002f7565b50505b505050565b600082821c905092915050565b60006200038e600019846008026200036e565b1980831691505092915050565b6000620003a983836200037b565b9150826002028217905092915050565b620003c4826200013f565b67ffffffffffffffff811115620003e057620003df6200014a565b5b620003ec8254620001a8565b620003f98282856200031e565b600060209050601f8311600181146200043157600084156200041c578287015190505b6200042885826200039b565b86555062000498565b601f1984166200044186620001dd565b60005b828110156200046b5784890151825560018201915060208501945060208101905062000444565b868310156200048b578489015162000487601f8916826200037b565b8355505b6001600288020188555050505b505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008160011c9050919050565b6000808291508390505b60018511156200052e57808604811115620005065762000505620004a0565b5b6001851615620005165780820291505b80810290506200052685620004cf565b9450620004e6565b94509492505050565b6000826200054957600190506200061c565b816200055957600090506200061c565b81600181146200057257600281146200057d57620005b3565b60019150506200061c565b60ff841115620005925762000591620004a0565b5b8360020a915084821115620005ac57620005ab620004a0565b5b506200061c565b5060208310610133831016604e8410600b8410161715620005ed5782820a905083811115620005e757620005e6620004a0565b5b6200061c565b620005fc8484846001620004dc565b92509050818404811115620006165762000615620004a0565b5b81810290505b9392505050565b6000620006308262000265565b91506200063d8362000265565b92506200066c7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff848462000537565b905092915050565b6000620006818262000265565b91506200068e8362000265565b92508282026200069e8162000265565b91508282048414831517620006b857620006b7620004a0565b5b5092915050565b610edc80620006cf6000396000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c806340c10f191161006657806340c10f191461015d57806370a082311461017957806395d89b41146101a9578063a9059cbb146101c7578063dd62ed3e146101f75761009e565b806306fdde03146100a3578063095ea7b3146100c157806318160ddd146100f157806323b872dd1461010f578063313ce5671461013f575b600080fd5b6100ab610227565b6040516100b89190610a85565b60405180910390f35b6100db60048036038101906100d69190610b40565b6102b5565b6040516100e89190610b9b565b60405180910390f35b6100f96103a7565b6040516101069190610bc5565b60405180910390f35b61012960048036038101906101249190610be0565b6103ad565b6040516101369190610b9b565b60405180910390f35b61014761069f565b6040516101549190610c4f565b60405180910390f35b61017760048036038101906101729190610b40565b6106b2565b005b610193600480360381019061018e9190610c6a565b61078b565b6040516101a09190610bc5565b60405180910390f35b6101b16107a3565b6040516101be9190610a85565b60405180910390f35b6101e160048036038101906101dc9190610b40565b610831565b6040516101ee9190610b9b565b60405180910390f35b610211600480360381019061020c9190610c97565b6109d0565b60405161021e9190610bc5565b60405180910390f35b6000805461023490610d06565b80601f016020809104026020016040519081016040528092919081815260200182805461026090610d06565b80156102ad5780601f10610282576101008083540402835291602001916102ad565b820191906000526020600020905b81548152906001019060200180831161029057829003601f168201915b505050505081565b600081600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040516103959190610bc5565b60405180910390a36001905092915050565b60035481565b600081600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015610431576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161042890610d83565b60405180910390fd5b81600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410156104f0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104e790610def565b60405180910390fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461053f9190610e3e565b9250508190555081600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546105959190610e72565b9250508190555081600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546106289190610e3e565b925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8460405161068c9190610bc5565b60405180910390a3600190509392505050565b600260009054906101000a900460ff1681565b80600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546107019190610e72565b92505081905550806003600082825461071a9190610e72565b925050819055508173ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8360405161077f9190610bc5565b60405180910390a35050565b60046020528060005260406000206000915090505481565b600180546107b090610d06565b80601f01602080910402602001604051908101604052809291908181526020018280546107dc90610d06565b80156108295780601f106107fe57610100808354040283529160200191610829565b820191906000526020600020905b81548152906001019060200180831161080c57829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410156108b5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108ac90610d83565b60405180910390fd5b81600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546109049190610e3e565b9250508190555081600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461095a9190610e72565b925050819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516109be9190610bc5565b60405180910390a36001905092915050565b6005602052816000526040600020602052806000526040600020600091509150505481565b600081519050919050565b600082825260208201905092915050565b60005b83811015610a2f578082015181840152602081019050610a14565b60008484015250505050565b6000601f19601f8301169050919050565b6000610a57826109f5565b610a618185610a00565b9350610a71818560208601610a11565b610a7a81610a3b565b840191505092915050565b60006020820190508181036000830152610a9f8184610a4c565b905092915050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610ad782610aac565b9050919050565b610ae781610acc565b8114610af257600080fd5b50565b600081359050610b0481610ade565b92915050565b6000819050919050565b610b1d81610b0a565b8114610b2857600080fd5b50565b600081359050610b3a81610b14565b92915050565b60008060408385031215610b5757610b56610aa7565b5b6000610b6585828601610af5565b9250506020610b7685828601610b2b565b9150509250929050565b60008115159050919050565b610b9581610b80565b82525050565b6000602082019050610bb06000830184610b8c565b92915050565b610bbf81610b0a565b82525050565b6000602082019050610bda6000830184610bb6565b92915050565b600080600060608486031215610bf957610bf8610aa7565b5b6000610c0786828701610af5565b9350506020610c1886828701610af5565b9250506040610c2986828701610b2b565b9150509250925092565b600060ff82169050919050565b610c4981610c33565b82525050565b6000602082019050610c646000830184610c40565b92915050565b600060208284031215610c8057610c7f610aa7565b5b6000610c8e84828501610af5565b91505092915050565b60008060408385031215610cae57610cad610aa7565b5b6000610cbc85828601610af5565b9250506020610ccd85828601610af5565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680610d1e57607f821691505b602082108103610d3157610d30610cd7565b5b50919050565b7f696e73756666696369656e742062616c616e6365000000000000000000000000600082015250565b6000610d6d601483610a00565b9150610d7882610d37565b602082019050919050565b60006020820190508181036000830152610d9c81610d60565b9050919050565b7f6578636565647320616c6c6f77616e6365000000000000000000000000000000600082015250565b6000610dd9601183610a00565b9150610de482610da3565b602082019050919050565b60006020820190508181036000830152610e0881610dcc565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610e4982610b0a565b9150610e5483610b0a565b9250828203905081811115610e6c57610e6b610e0f565b5b92915050565b6000610e7d82610b0a565b9150610e8883610b0a565b9250828201905080821115610ea057610e9f610e0f565b5b9291505056fea264697066735822122041fa693da1c1decf8c3e4932e0c8ae158fb01e9b5107935494ee90fbcdd5f6dc64736f6c63430008180033","opcodes":"PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x40 MLOAD DUP1 PUSH1 0x40 ADD PUSH1 0x40 MSTORE DUP1 PUSH1 0x7 DUP2 MSTORE PUSH1 0x20 ADD PUSH32 0x4D79546F6B656E00000000000000000000000000000000000000000000000000 DUP2 MSTORE POP PUSH1 0x0 SWAP1 DUP2 PUSH3 0x4A SWAP2 SWAP1 PUSH3 0x3B9 JUMP JUMPDEST POP PUSH1 0x40 MLOAD DUP1 PUSH1 0x40 ADD PUSH1 0x40 MSTORE DUP1 PUSH1 0x3 DUP2 MSTORE PUSH1 0x20 ADD PUSH32 0x4D43500000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE POP PUSH1 0x1 SWAP1 DUP2 PUSH3 0x91 SWAP2 SWAP1 PUSH3 0x3B9 JUMP JUMPDEST POP PUSH1 0x12 PUSH1 0x2 PUSH1 0x0 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH1 0xFF MUL NOT AND SWAP1 DUP4 PUSH1 0xFF AND MUL OR SWAP1 SSTORE POP CALLVALUE DUP1 ISZERO PUSH3 0xBB JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x2 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0xFF AND PUSH1 0xFF AND PUSH1 0xA PUSH3 0xDD SWAP2 SWAP1 PUSH3 0x623 JUMP JUMPDEST PUSH3 0xF4240 PUSH3 0xED SWAP2 SWAP1 PUSH3 0x674 JUMP JUMPDEST PUSH1 0x3 DUP2 SWAP1 SSTORE POP PUSH1 0x3 SLOAD PUSH1 0x4 PUSH1 0x0 CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 DUP2 SWAP1 SSTORE POP PUSH3 0x6BF JUMP JUMPDEST PUSH1 0x0 DUP2 MLOAD SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH32 0x4E487B7100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH32 0x4E487B7100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 MSTORE PUSH1 0x22 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 PUSH1 0x2 DUP3 DIV SWAP1 POP PUSH1 0x1 DUP3 AND DUP1 PUSH3 0x1C1 JUMPI PUSH1 0x7F DUP3 AND SWAP2 POP JUMPDEST PUSH1 0x20 DUP3 LT DUP2 SUB PUSH3 0x1D7 JUMPI PUSH3 0x1D6 PUSH3 0x179 JUMP JUMPDEST JUMPDEST POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP2 SWAP1 POP DUP2 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 PUSH1 0x1F DUP4 ADD DIV SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP3 DUP3 SHL SWAP1 POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x8 DUP4 MUL PUSH3 0x241 PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP3 PUSH3 0x202 JUMP JUMPDEST PUSH3 0x24D DUP7 DUP4 PUSH3 0x202 JUMP JUMPDEST SWAP6 POP DUP1 NOT DUP5 AND SWAP4 POP DUP1 DUP7 AND DUP5 OR SWAP3 POP POP POP SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP2 SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH3 0x29A PUSH3 0x294 PUSH3 0x28E DUP5 PUSH3 0x265 JUMP JUMPDEST PUSH3 0x26F JUMP JUMPDEST PUSH3 0x265 JUMP JUMPDEST SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP2 SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH3 0x2B6 DUP4 PUSH3 0x279 JUMP JUMPDEST PUSH3 0x2CE PUSH3 0x2C5 DUP3 PUSH3 0x2A1 JUMP JUMPDEST DUP5 DUP5 SLOAD PUSH3 0x20F JUMP JUMPDEST DUP3 SSTORE POP POP POP POP JUMP JUMPDEST PUSH1 0x0 SWAP1 JUMP JUMPDEST PUSH3 0x2E5 PUSH3 0x2D6 JUMP JUMPDEST PUSH3 0x2F2 DUP2 DUP5 DUP5 PUSH3 0x2AB JUMP JUMPDEST POP POP POP JUMP JUMPDEST JUMPDEST DUP2 DUP2 LT ISZERO PUSH3 0x31A JUMPI PUSH3 0x30E PUSH1 0x0 DUP3 PUSH3 0x2DB JUMP JUMPDEST PUSH1 0x1 DUP2 ADD SWAP1 POP PUSH3 0x2F8 JUMP JUMPDEST POP POP JUMP JUMPDEST PUSH1 0x1F DUP3 GT ISZERO PUSH3 0x369 JUMPI PUSH3 0x333 DUP2 PUSH3 0x1DD JUMP JUMPDEST PUSH3 0x33E DUP5 PUSH3 0x1F2 JUMP JUMPDEST DUP2 ADD PUSH1 0x20 DUP6 LT ISZERO PUSH3 0x34E JUMPI DUP2 SWAP1 POP JUMPDEST PUSH3 0x366 PUSH3 0x35D DUP6 PUSH3 0x1F2 JUMP JUMPDEST DUP4 ADD DUP3 PUSH3 0x2F7 JUMP JUMPDEST POP POP JUMPDEST POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP3 DUP3 SHR SWAP1 POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH3 0x38E PUSH1 0x0 NOT DUP5 PUSH1 0x8 MUL PUSH3 0x36E JUMP JUMPDEST NOT DUP1 DUP4 AND SWAP2 POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH3 0x3A9 DUP4 DUP4 PUSH3 0x37B JUMP JUMPDEST SWAP2 POP DUP3 PUSH1 0x2 MUL DUP3 OR SWAP1 POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH3 0x3C4 DUP3 PUSH3 0x13F JUMP JUMPDEST PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT ISZERO PUSH3 0x3E0 JUMPI PUSH3 0x3DF PUSH3 0x14A JUMP JUMPDEST JUMPDEST PUSH3 0x3EC DUP3 SLOAD PUSH3 0x1A8 JUMP JUMPDEST PUSH3 0x3F9 DUP3 DUP3 DUP6 PUSH3 0x31E JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 SWAP1 POP PUSH1 0x1F DUP4 GT PUSH1 0x1 DUP2 EQ PUSH3 0x431 JUMPI PUSH1 0x0 DUP5 ISZERO PUSH3 0x41C JUMPI DUP3 DUP8 ADD MLOAD SWAP1 POP JUMPDEST PUSH3 0x428 DUP6 DUP3 PUSH3 0x39B JUMP JUMPDEST DUP7 SSTORE POP PUSH3 0x498 JUMP JUMPDEST PUSH1 0x1F NOT DUP5 AND PUSH3 0x441 DUP7 PUSH3 0x1DD JUMP JUMPDEST PUSH1 0x0 JUMPDEST DUP3 DUP2 LT ISZERO PUSH3 0x46B JUMPI DUP5 DUP10 ADD MLOAD DUP3 SSTORE PUSH1 0x1 DUP3 ADD SWAP2 POP PUSH1 0x20 DUP6 ADD SWAP5 POP PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH3 0x444 JUMP JUMPDEST DUP7 DUP4 LT ISZERO PUSH3 0x48B JUMPI DUP5 DUP10 ADD MLOAD PUSH3 0x487 PUSH1 0x1F DUP10 AND DUP3 PUSH3 0x37B JUMP JUMPDEST DUP4 SSTORE POP JUMPDEST PUSH1 0x1 PUSH1 0x2 DUP9 MUL ADD DUP9 SSTORE POP POP POP JUMPDEST POP POP POP POP POP POP JUMP JUMPDEST PUSH32 0x4E487B7100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 DUP2 PUSH1 0x1 SHR SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP1 DUP3 SWAP2 POP DUP4 SWAP1 POP JUMPDEST PUSH1 0x1 DUP6 GT ISZERO PUSH3 0x52E JUMPI DUP1 DUP7 DIV DUP2 GT ISZERO PUSH3 0x506 JUMPI PUSH3 0x505 PUSH3 0x4A0 JUMP JUMPDEST JUMPDEST PUSH1 0x1 DUP6 AND ISZERO PUSH3 0x516 JUMPI DUP1 DUP3 MUL SWAP2 POP JUMPDEST DUP1 DUP2 MUL SWAP1 POP PUSH3 0x526 DUP6 PUSH3 0x4CF JUMP JUMPDEST SWAP5 POP PUSH3 0x4E6 JUMP JUMPDEST SWAP5 POP SWAP5 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP3 PUSH3 0x549 JUMPI PUSH1 0x1 SWAP1 POP PUSH3 0x61C JUMP JUMPDEST DUP2 PUSH3 0x559 JUMPI PUSH1 0x0 SWAP1 POP PUSH3 0x61C JUMP JUMPDEST DUP2 PUSH1 0x1 DUP2 EQ PUSH3 0x572 JUMPI PUSH1 0x2 DUP2 EQ PUSH3 0x57D JUMPI PUSH3 0x5B3 JUMP JUMPDEST PUSH1 0x1 SWAP2 POP POP PUSH3 0x61C JUMP JUMPDEST PUSH1 0xFF DUP5 GT ISZERO PUSH3 0x592 JUMPI PUSH3 0x591 PUSH3 0x4A0 JUMP JUMPDEST JUMPDEST DUP4 PUSH1 0x2 EXP SWAP2 POP DUP5 DUP3 GT ISZERO PUSH3 0x5AC JUMPI PUSH3 0x5AB PUSH3 0x4A0 JUMP JUMPDEST JUMPDEST POP PUSH3 0x61C JUMP JUMPDEST POP PUSH1 0x20 DUP4 LT PUSH2 0x133 DUP4 LT AND PUSH1 0x4E DUP5 LT PUSH1 0xB DUP5 LT AND OR ISZERO PUSH3 0x5ED JUMPI DUP3 DUP3 EXP SWAP1 POP DUP4 DUP2 GT ISZERO PUSH3 0x5E7 JUMPI PUSH3 0x5E6 PUSH3 0x4A0 JUMP JUMPDEST JUMPDEST PUSH3 0x61C JUMP JUMPDEST PUSH3 0x5FC DUP5 DUP5 DUP5 PUSH1 0x1 PUSH3 0x4DC JUMP JUMPDEST SWAP3 POP SWAP1 POP DUP2 DUP5 DIV DUP2 GT ISZERO PUSH3 0x616 JUMPI PUSH3 0x615 PUSH3 0x4A0 JUMP JUMPDEST JUMPDEST DUP2 DUP2 MUL SWAP1 POP JUMPDEST SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH3 0x630 DUP3 PUSH3 0x265 JUMP JUMPDEST SWAP2 POP PUSH3 0x63D DUP4 PUSH3 0x265 JUMP JUMPDEST SWAP3 POP PUSH3 0x66C PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP5 DUP5 PUSH3 0x537 JUMP JUMPDEST SWAP1 POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH3 0x681 DUP3 PUSH3 0x265 JUMP JUMPDEST SWAP2 POP PUSH3 0x68E DUP4 PUSH3 0x265 JUMP JUMPDEST SWAP3 POP DUP3 DUP3 MUL PUSH3 0x69E DUP2 PUSH3 0x265 JUMP JUMPDEST SWAP2 POP DUP3 DUP3 DIV DUP5 EQ DUP4 ISZERO OR PUSH3 0x6B8 JUMPI PUSH3 0x6B7 PUSH3 0x4A0 JUMP JUMPDEST JUMPDEST POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH2 0xEDC DUP1 PUSH3 0x6CF PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x9E JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x40C10F19 GT PUSH2 0x66 JUMPI DUP1 PUSH4 0x40C10F19 EQ PUSH2 0x15D JUMPI DUP1 PUSH4 0x70A08231 EQ PUSH2 0x179 JUMPI DUP1 PUSH4 0x95D89B41 EQ PUSH2 0x1A9 JUMPI DUP1 PUSH4 0xA9059CBB EQ PUSH2 0x1C7 JUMPI DUP1 PUSH4 0xDD62ED3E EQ PUSH2 0x1F7 JUMPI PUSH2 0x9E JUMP JUMPDEST DUP1 PUSH4 0x6FDDE03 EQ PUSH2 0xA3 JUMPI DUP1 PUSH4 0x95EA7B3 EQ PUSH2 0xC1 JUMPI DUP1 PUSH4 0x18160DDD EQ PUSH2 0xF1 JUMPI DUP1 PUSH4 0x23B872DD EQ PUSH2 0x10F JUMPI DUP1 PUSH4 0x313CE567 EQ PUSH2 0x13F JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xAB PUSH2 0x227 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0xB8 SWAP2 SWAP1 PUSH2 0xA85 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xDB PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 PUSH2 0xD6 SWAP2 SWAP1 PUSH2 0xB40 JUMP JUMPDEST PUSH2 0x2B5 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0xE8 SWAP2 SWAP1 PUSH2 0xB9B JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xF9 PUSH2 0x3A7 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x106 SWAP2 SWAP1 PUSH2 0xBC5 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x129 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 PUSH2 0x124 SWAP2 SWAP1 PUSH2 0xBE0 JUMP JUMPDEST PUSH2 0x3AD JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x136 SWAP2 SWAP1 PUSH2 0xB9B JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x147 PUSH2 0x69F JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x154 SWAP2 SWAP1 PUSH2 0xC4F JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x177 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 PUSH2 0x172 SWAP2 SWAP1 PUSH2 0xB40 JUMP JUMPDEST PUSH2 0x6B2 JUMP JUMPDEST STOP JUMPDEST PUSH2 0x193 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 PUSH2 0x18E SWAP2 SWAP1 PUSH2 0xC6A JUMP JUMPDEST PUSH2 0x78B JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x1A0 SWAP2 SWAP1 PUSH2 0xBC5 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x1B1 PUSH2 0x7A3 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x1BE SWAP2 SWAP1 PUSH2 0xA85 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x1E1 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 PUSH2 0x1DC SWAP2 SWAP1 PUSH2 0xB40 JUMP JUMPDEST PUSH2 0x831 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x1EE SWAP2 SWAP1 PUSH2 0xB9B JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x211 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 PUSH2 0x20C SWAP2 SWAP1 PUSH2 0xC97 JUMP JUMPDEST PUSH2 0x9D0 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x21E SWAP2 SWAP1 PUSH2 0xBC5 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH2 0x234 SWAP1 PUSH2 0xD06 JUMP JUMPDEST DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP1 SLOAD PUSH2 0x260 SWAP1 PUSH2 0xD06 JUMP JUMPDEST DUP1 ISZERO PUSH2 0x2AD JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x282 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x2AD JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE SWAP1 PUSH1 0x1 ADD SWAP1 PUSH1 0x20 ADD DUP1 DUP4 GT PUSH2 0x290 JUMPI DUP3 SWAP1 SUB PUSH1 0x1F AND DUP3 ADD SWAP2 JUMPDEST POP POP POP POP POP DUP2 JUMP JUMPDEST PUSH1 0x0 DUP2 PUSH1 0x5 PUSH1 0x0 CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 DUP6 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 DUP2 SWAP1 SSTORE POP DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH32 0x8C5BE1E5EBEC7D5BD14F71427D1E84F3DD0314C0F7B2291E5B200AC8C7C3B925 DUP5 PUSH1 0x40 MLOAD PUSH2 0x395 SWAP2 SWAP1 PUSH2 0xBC5 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG3 PUSH1 0x1 SWAP1 POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x3 SLOAD DUP2 JUMP JUMPDEST PUSH1 0x0 DUP2 PUSH1 0x4 PUSH1 0x0 DUP7 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 SLOAD LT ISZERO PUSH2 0x431 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x428 SWAP1 PUSH2 0xD83 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST DUP2 PUSH1 0x5 PUSH1 0x0 DUP7 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 SLOAD LT ISZERO PUSH2 0x4F0 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x4E7 SWAP1 PUSH2 0xDEF JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST DUP2 PUSH1 0x4 PUSH1 0x0 DUP7 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 DUP3 DUP3 SLOAD PUSH2 0x53F SWAP2 SWAP1 PUSH2 0xE3E JUMP JUMPDEST SWAP3 POP POP DUP2 SWAP1 SSTORE POP DUP2 PUSH1 0x4 PUSH1 0x0 DUP6 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 DUP3 DUP3 SLOAD PUSH2 0x595 SWAP2 SWAP1 PUSH2 0xE72 JUMP JUMPDEST SWAP3 POP POP DUP2 SWAP1 SSTORE POP DUP2 PUSH1 0x5 PUSH1 0x0 DUP7 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 DUP3 DUP3 SLOAD PUSH2 0x628 SWAP2 SWAP1 PUSH2 0xE3E JUMP JUMPDEST SWAP3 POP POP DUP2 SWAP1 SSTORE POP DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP5 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH32 0xDDF252AD1BE2C89B69C2B068FC378DAA952BA7F163C4A11628F55A4DF523B3EF DUP5 PUSH1 0x40 MLOAD PUSH2 0x68C SWAP2 SWAP1 PUSH2 0xBC5 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG3 PUSH1 0x1 SWAP1 POP SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x2 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0xFF AND DUP2 JUMP JUMPDEST DUP1 PUSH1 0x4 PUSH1 0x0 DUP5 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 DUP3 DUP3 SLOAD PUSH2 0x701 SWAP2 SWAP1 PUSH2 0xE72 JUMP JUMPDEST SWAP3 POP POP DUP2 SWAP1 SSTORE POP DUP1 PUSH1 0x3 PUSH1 0x0 DUP3 DUP3 SLOAD PUSH2 0x71A SWAP2 SWAP1 PUSH2 0xE72 JUMP JUMPDEST SWAP3 POP POP DUP2 SWAP1 SSTORE POP DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH1 0x0 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH32 0xDDF252AD1BE2C89B69C2B068FC378DAA952BA7F163C4A11628F55A4DF523B3EF DUP4 PUSH1 0x40 MLOAD PUSH2 0x77F SWAP2 SWAP1 PUSH2 0xBC5 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 0x4 PUSH1 0x20 MSTORE DUP1 PUSH1 0x0 MSTORE PUSH1 0x40 PUSH1 0x0 KECCAK256 PUSH1 0x0 SWAP2 POP SWAP1 POP SLOAD DUP2 JUMP JUMPDEST PUSH1 0x1 DUP1 SLOAD PUSH2 0x7B0 SWAP1 PUSH2 0xD06 JUMP JUMPDEST DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP1 SLOAD PUSH2 0x7DC SWAP1 PUSH2 0xD06 JUMP JUMPDEST DUP1 ISZERO PUSH2 0x829 JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x7FE JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x829 JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE SWAP1 PUSH1 0x1 ADD SWAP1 PUSH1 0x20 ADD DUP1 DUP4 GT PUSH2 0x80C JUMPI DUP3 SWAP1 SUB PUSH1 0x1F AND DUP3 ADD SWAP2 JUMPDEST POP POP POP POP POP DUP2 JUMP JUMPDEST PUSH1 0x0 DUP2 PUSH1 0x4 PUSH1 0x0 CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 SLOAD LT ISZERO PUSH2 0x8B5 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x8AC SWAP1 PUSH2 0xD83 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST DUP2 PUSH1 0x4 PUSH1 0x0 CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 DUP3 DUP3 SLOAD PUSH2 0x904 SWAP2 SWAP1 PUSH2 0xE3E JUMP JUMPDEST SWAP3 POP POP DUP2 SWAP1 SSTORE POP DUP2 PUSH1 0x4 PUSH1 0x0 DUP6 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 DUP3 DUP3 SLOAD PUSH2 0x95A SWAP2 SWAP1 PUSH2 0xE72 JUMP JUMPDEST SWAP3 POP POP DUP2 SWAP1 SSTORE POP DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH32 0xDDF252AD1BE2C89B69C2B068FC378DAA952BA7F163C4A11628F55A4DF523B3EF DUP5 PUSH1 0x40 MLOAD PUSH2 0x9BE SWAP2 SWAP1 PUSH2 0xBC5 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG3 PUSH1 0x1 SWAP1 POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x5 PUSH1 0x20 MSTORE DUP2 PUSH1 0x0 MSTORE PUSH1 0x40 PUSH1 0x0 KECCAK256 PUSH1 0x20 MSTORE DUP1 PUSH1 0x0 MSTORE PUSH1 0x40 PUSH1 0x0 KECCAK256 PUSH1 0x0 SWAP2 POP SWAP2 POP POP SLOAD DUP2 JUMP JUMPDEST PUSH1 0x0 DUP2 MLOAD SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP3 DUP3 MSTORE PUSH1 0x20 DUP3 ADD SWAP1 POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0xA2F JUMPI DUP1 DUP3 ADD MLOAD DUP2 DUP5 ADD MSTORE PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH2 0xA14 JUMP JUMPDEST PUSH1 0x0 DUP5 DUP5 ADD MSTORE POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x1F NOT PUSH1 0x1F DUP4 ADD AND SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xA57 DUP3 PUSH2 0x9F5 JUMP JUMPDEST PUSH2 0xA61 DUP2 DUP6 PUSH2 0xA00 JUMP JUMPDEST SWAP4 POP PUSH2 0xA71 DUP2 DUP6 PUSH1 0x20 DUP7 ADD PUSH2 0xA11 JUMP JUMPDEST PUSH2 0xA7A DUP2 PUSH2 0xA3B JUMP JUMPDEST DUP5 ADD SWAP2 POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD SWAP1 POP DUP2 DUP2 SUB PUSH1 0x0 DUP4 ADD MSTORE PUSH2 0xA9F DUP2 DUP5 PUSH2 0xA4C JUMP JUMPDEST SWAP1 POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP3 AND SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xAD7 DUP3 PUSH2 0xAAC JUMP JUMPDEST SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0xAE7 DUP2 PUSH2 0xACC JUMP JUMPDEST DUP2 EQ PUSH2 0xAF2 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 DUP2 CALLDATALOAD SWAP1 POP PUSH2 0xB04 DUP2 PUSH2 0xADE JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0xB1D DUP2 PUSH2 0xB0A JUMP JUMPDEST DUP2 EQ PUSH2 0xB28 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 DUP2 CALLDATALOAD SWAP1 POP PUSH2 0xB3A DUP2 PUSH2 0xB14 JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH2 0xB57 JUMPI PUSH2 0xB56 PUSH2 0xAA7 JUMP JUMPDEST JUMPDEST PUSH1 0x0 PUSH2 0xB65 DUP6 DUP3 DUP7 ADD PUSH2 0xAF5 JUMP JUMPDEST SWAP3 POP POP PUSH1 0x20 PUSH2 0xB76 DUP6 DUP3 DUP7 ADD PUSH2 0xB2B JUMP JUMPDEST SWAP2 POP POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP2 ISZERO ISZERO SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0xB95 DUP2 PUSH2 0xB80 JUMP JUMPDEST DUP3 MSTORE POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD SWAP1 POP PUSH2 0xBB0 PUSH1 0x0 DUP4 ADD DUP5 PUSH2 0xB8C JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH2 0xBBF DUP2 PUSH2 0xB0A JUMP JUMPDEST DUP3 MSTORE POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD SWAP1 POP PUSH2 0xBDA PUSH1 0x0 DUP4 ADD DUP5 PUSH2 0xBB6 JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x60 DUP5 DUP7 SUB SLT ISZERO PUSH2 0xBF9 JUMPI PUSH2 0xBF8 PUSH2 0xAA7 JUMP JUMPDEST JUMPDEST PUSH1 0x0 PUSH2 0xC07 DUP7 DUP3 DUP8 ADD PUSH2 0xAF5 JUMP JUMPDEST SWAP4 POP POP PUSH1 0x20 PUSH2 0xC18 DUP7 DUP3 DUP8 ADD PUSH2 0xAF5 JUMP JUMPDEST SWAP3 POP POP PUSH1 0x40 PUSH2 0xC29 DUP7 DUP3 DUP8 ADD PUSH2 0xB2B JUMP JUMPDEST SWAP2 POP POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH1 0x0 PUSH1 0xFF DUP3 AND SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0xC49 DUP2 PUSH2 0xC33 JUMP JUMPDEST DUP3 MSTORE POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD SWAP1 POP PUSH2 0xC64 PUSH1 0x0 DUP4 ADD DUP5 PUSH2 0xC40 JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0xC80 JUMPI PUSH2 0xC7F PUSH2 0xAA7 JUMP JUMPDEST JUMPDEST PUSH1 0x0 PUSH2 0xC8E DUP5 DUP3 DUP6 ADD PUSH2 0xAF5 JUMP JUMPDEST SWAP2 POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH2 0xCAE JUMPI PUSH2 0xCAD PUSH2 0xAA7 JUMP JUMPDEST JUMPDEST PUSH1 0x0 PUSH2 0xCBC DUP6 DUP3 DUP7 ADD PUSH2 0xAF5 JUMP JUMPDEST SWAP3 POP POP PUSH1 0x20 PUSH2 0xCCD DUP6 DUP3 DUP7 ADD PUSH2 0xAF5 JUMP JUMPDEST SWAP2 POP POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH32 0x4E487B7100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 MSTORE PUSH1 0x22 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 PUSH1 0x2 DUP3 DIV SWAP1 POP PUSH1 0x1 DUP3 AND DUP1 PUSH2 0xD1E JUMPI PUSH1 0x7F DUP3 AND SWAP2 POP JUMPDEST PUSH1 0x20 DUP3 LT DUP2 SUB PUSH2 0xD31 JUMPI PUSH2 0xD30 PUSH2 0xCD7 JUMP JUMPDEST JUMPDEST POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH32 0x696E73756666696369656E742062616C616E6365000000000000000000000000 PUSH1 0x0 DUP3 ADD MSTORE POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xD6D PUSH1 0x14 DUP4 PUSH2 0xA00 JUMP JUMPDEST SWAP2 POP PUSH2 0xD78 DUP3 PUSH2 0xD37 JUMP JUMPDEST PUSH1 0x20 DUP3 ADD SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD SWAP1 POP DUP2 DUP2 SUB PUSH1 0x0 DUP4 ADD MSTORE PUSH2 0xD9C DUP2 PUSH2 0xD60 JUMP JUMPDEST SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH32 0x6578636565647320616C6C6F77616E6365000000000000000000000000000000 PUSH1 0x0 DUP3 ADD MSTORE POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xDD9 PUSH1 0x11 DUP4 PUSH2 0xA00 JUMP JUMPDEST SWAP2 POP PUSH2 0xDE4 DUP3 PUSH2 0xDA3 JUMP JUMPDEST PUSH1 0x20 DUP3 ADD SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD SWAP1 POP DUP2 DUP2 SUB PUSH1 0x0 DUP4 ADD MSTORE PUSH2 0xE08 DUP2 PUSH2 0xDCC JUMP JUMPDEST SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH32 0x4E487B7100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 PUSH2 0xE49 DUP3 PUSH2 0xB0A JUMP JUMPDEST SWAP2 POP PUSH2 0xE54 DUP4 PUSH2 0xB0A JUMP JUMPDEST SWAP3 POP DUP3 DUP3 SUB SWAP1 POP DUP2 DUP2 GT ISZERO PUSH2 0xE6C JUMPI PUSH2 0xE6B PUSH2 0xE0F JUMP JUMPDEST JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xE7D DUP3 PUSH2 0xB0A JUMP JUMPDEST SWAP2 POP PUSH2 0xE88 DUP4 PUSH2 0xB0A JUMP JUMPDEST SWAP3 POP DUP3 DUP3 ADD SWAP1 POP DUP1 DUP3 GT ISZERO PUSH2 0xEA0 JUMPI PUSH2 0xE9F PUSH2 0xE0F JUMP JUMPDEST JUMPDEST SWAP3 SWAP2 POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 COINBASE STATICCALL PUSH10 0x3DA1C1DECF8C3E4932E0 0xC8 0xAE ISZERO DUP16 0xB0 0x1E SWAP12 MLOAD SMOD SWAP4 SLOAD SWAP5 0xEE SWAP1 0xFB 0xCD 0xD5 0xF6 0xDC PUSH5 0x736F6C6343 STOP ADDMOD XOR STOP CALLER ","sourceMap":"58:1667:0:-:0;;;83:30;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;119:28;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;177:2;153:26;;;;;;;;;;;;;;;;;;;;499:121;;;;;;;;;;559:8;;;;;;;;;;;551:17;;547:2;:21;;;;:::i;:::-;537:7;:31;;;;:::i;:::-;523:11;:45;;;;602:11;;578:9;:21;588:10;578:21;;;;;;;;;;;;;;;:35;;;;58:1667;;7:99:1;59:6;93:5;87:12;77:22;;7:99;;;:::o;112:180::-;160:77;157:1;150:88;257:4;254:1;247:15;281:4;278:1;271:15;298:180;346:77;343:1;336:88;443:4;440:1;433:15;467:4;464:1;457:15;484:320;528:6;565:1;559:4;555:12;545:22;;612:1;606:4;602:12;633:18;623:81;;689:4;681:6;677:17;667:27;;623:81;751:2;743:6;740:14;720:18;717:38;714:84;;770:18;;:::i;:::-;714:84;535:269;484:320;;;:::o;810:141::-;859:4;882:3;874:11;;905:3;902:1;895:14;939:4;936:1;926:18;918:26;;810:141;;;:::o;957:93::-;994:6;1041:2;1036;1029:5;1025:14;1021:23;1011:33;;957:93;;;:::o;1056:107::-;1100:8;1150:5;1144:4;1140:16;1119:37;;1056:107;;;;:::o;1169:393::-;1238:6;1288:1;1276:10;1272:18;1311:97;1341:66;1330:9;1311:97;:::i;:::-;1429:39;1459:8;1448:9;1429:39;:::i;:::-;1417:51;;1501:4;1497:9;1490:5;1486:21;1477:30;;1550:4;1540:8;1536:19;1529:5;1526:30;1516:40;;1245:317;;1169:393;;;;;:::o;1568:77::-;1605:7;1634:5;1623:16;;1568:77;;;:::o;1651:60::-;1679:3;1700:5;1693:12;;1651:60;;;:::o;1717:142::-;1767:9;1800:53;1818:34;1827:24;1845:5;1827:24;:::i;:::-;1818:34;:::i;:::-;1800:53;:::i;:::-;1787:66;;1717:142;;;:::o;1865:75::-;1908:3;1929:5;1922:12;;1865:75;;;:::o;1946:269::-;2056:39;2087:7;2056:39;:::i;:::-;2117:91;2166:41;2190:16;2166:41;:::i;:::-;2158:6;2151:4;2145:11;2117:91;:::i;:::-;2111:4;2104:105;2022:193;1946:269;;;:::o;2221:73::-;2266:3;2221:73;:::o;2300:189::-;2377:32;;:::i;:::-;2418:65;2476:6;2468;2462:4;2418:65;:::i;:::-;2353:136;2300:189;;:::o;2495:186::-;2555:120;2572:3;2565:5;2562:14;2555:120;;;2626:39;2663:1;2656:5;2626:39;:::i;:::-;2599:1;2592:5;2588:13;2579:22;;2555:120;;;2495:186;;:::o;2687:543::-;2788:2;2783:3;2780:11;2777:446;;;2822:38;2854:5;2822:38;:::i;:::-;2906:29;2924:10;2906:29;:::i;:::-;2896:8;2892:44;3089:2;3077:10;3074:18;3071:49;;;3110:8;3095:23;;3071:49;3133:80;3189:22;3207:3;3189:22;:::i;:::-;3179:8;3175:37;3162:11;3133:80;:::i;:::-;2792:431;;2777:446;2687:543;;;:::o;3236:117::-;3290:8;3340:5;3334:4;3330:16;3309:37;;3236:117;;;;:::o;3359:169::-;3403:6;3436:51;3484:1;3480:6;3472:5;3469:1;3465:13;3436:51;:::i;:::-;3432:56;3517:4;3511;3507:15;3497:25;;3410:118;3359:169;;;;:::o;3533:295::-;3609:4;3755:29;3780:3;3774:4;3755:29;:::i;:::-;3747:37;;3817:3;3814:1;3810:11;3804:4;3801:21;3793:29;;3533:295;;;;:::o;3833:1395::-;3950:37;3983:3;3950:37;:::i;:::-;4052:18;4044:6;4041:30;4038:56;;;4074:18;;:::i;:::-;4038:56;4118:38;4150:4;4144:11;4118:38;:::i;:::-;4203:67;4263:6;4255;4249:4;4203:67;:::i;:::-;4297:1;4321:4;4308:17;;4353:2;4345:6;4342:14;4370:1;4365:618;;;;5027:1;5044:6;5041:77;;;5093:9;5088:3;5084:19;5078:26;5069:35;;5041:77;5144:67;5204:6;5197:5;5144:67;:::i;:::-;5138:4;5131:81;5000:222;4335:887;;4365:618;4417:4;4413:9;4405:6;4401:22;4451:37;4483:4;4451:37;:::i;:::-;4510:1;4524:208;4538:7;4535:1;4532:14;4524:208;;;4617:9;4612:3;4608:19;4602:26;4594:6;4587:42;4668:1;4660:6;4656:14;4646:24;;4715:2;4704:9;4700:18;4687:31;;4561:4;4558:1;4554:12;4549:17;;4524:208;;;4760:6;4751:7;4748:19;4745:179;;;4818:9;4813:3;4809:19;4803:26;4861:48;4903:4;4895:6;4891:17;4880:9;4861:48;:::i;:::-;4853:6;4846:64;4768:156;4745:179;4970:1;4966;4958:6;4954:14;4950:22;4944:4;4937:36;4372:611;;;4335:887;;3925:1303;;;3833:1395;;:::o;5234:180::-;5282:77;5279:1;5272:88;5379:4;5376:1;5369:15;5403:4;5400:1;5393:15;5420:102;5462:8;5509:5;5506:1;5502:13;5481:34;;5420:102;;;:::o;5528:848::-;5589:5;5596:4;5620:6;5611:15;;5644:5;5635:14;;5658:712;5679:1;5669:8;5666:15;5658:712;;;5774:4;5769:3;5765:14;5759:4;5756:24;5753:50;;;5783:18;;:::i;:::-;5753:50;5833:1;5823:8;5819:16;5816:451;;;6248:4;6241:5;6237:16;6228:25;;5816:451;6298:4;6292;6288:15;6280:23;;6328:32;6351:8;6328:32;:::i;:::-;6316:44;;5658:712;;;5528:848;;;;;;;:::o;6382:1073::-;6436:5;6627:8;6617:40;;6648:1;6639:10;;6650:5;;6617:40;6676:4;6666:36;;6693:1;6684:10;;6695:5;;6666:36;6762:4;6810:1;6805:27;;;;6846:1;6841:191;;;;6755:277;;6805:27;6823:1;6814:10;;6825:5;;;6841:191;6886:3;6876:8;6873:17;6870:43;;;6893:18;;:::i;:::-;6870:43;6942:8;6939:1;6935:16;6926:25;;6977:3;6970:5;6967:14;6964:40;;;6984:18;;:::i;:::-;6964:40;7017:5;;;6755:277;;7141:2;7131:8;7128:16;7122:3;7116:4;7113:13;7109:36;7091:2;7081:8;7078:16;7073:2;7067:4;7064:12;7060:35;7044:111;7041:246;;;7197:8;7191:4;7187:19;7178:28;;7232:3;7225:5;7222:14;7219:40;;;7239:18;;:::i;:::-;7219:40;7272:5;;7041:246;7312:42;7350:3;7340:8;7334:4;7331:1;7312:42;:::i;:::-;7297:57;;;;7386:4;7381:3;7377:14;7370:5;7367:25;7364:51;;;7395:18;;:::i;:::-;7364:51;7444:4;7437:5;7433:16;7424:25;;6382:1073;;;;;;:::o;7461:285::-;7521:5;7545:23;7563:4;7545:23;:::i;:::-;7537:31;;7589:27;7607:8;7589:27;:::i;:::-;7577:39;;7635:104;7672:66;7662:8;7656:4;7635:104;:::i;:::-;7626:113;;7461:285;;;;:::o;7752:410::-;7792:7;7815:20;7833:1;7815:20;:::i;:::-;7810:25;;7849:20;7867:1;7849:20;:::i;:::-;7844:25;;7904:1;7901;7897:9;7926:30;7944:11;7926:30;:::i;:::-;7915:41;;8105:1;8096:7;8092:15;8089:1;8086:22;8066:1;8059:9;8039:83;8016:139;;8135:18;;:::i;:::-;8016:139;7800:362;7752:410;;;;:::o;58:1667:0:-;;;;;;;"},"deployedBytecode":{"functionDebugData":{"@allowance_22":{"entryPoint":2512,"id":22,"parameterSlots":0,"returnSlots":0},"@approve_130":{"entryPoint":693,"id":130,"parameterSlots":2,"returnSlots":1},"@balanceOf_16":{"entryPoint":1931,"id":16,"parameterSlots":0,"returnSlots":0},"@decimals_10":{"entryPoint":1695,"id":10,"parameterSlots":0,"returnSlots":0},"@mint_219":{"entryPoint":1714,"id":219,"parameterSlots":2,"returnSlots":0},"@name_4":{"entryPoint":551,"id":4,"parameterSlots":0,"returnSlots":0},"@symbol_7":{"entryPoint":1955,"id":7,"parameterSlots":0,"returnSlots":0},"@totalSupply_12":{"entryPoint":935,"id":12,"parameterSlots":0,"returnSlots":0},"@transferFrom_192":{"entryPoint":941,"id":192,"parameterSlots":3,"returnSlots":1},"@transfer_102":{"entryPoint":2097,"id":102,"parameterSlots":2,"returnSlots":1},"abi_decode_t_address":{"entryPoint":2805,"id":null,"parameterSlots":2,"returnSlots":1},"abi_decode_t_uint256":{"entryPoint":2859,"id":null,"parameterSlots":2,"returnSlots":1},"abi_decode_tuple_t_address":{"entryPoint":3178,"id":null,"parameterSlots":2,"returnSlots":1},"abi_decode_tuple_t_addresst_address":{"entryPoint":3223,"id":null,"parameterSlots":2,"returnSlots":2},"abi_decode_tuple_t_addresst_addresst_uint256":{"entryPoint":3040,"id":null,"parameterSlots":2,"returnSlots":3},"abi_decode_tuple_t_addresst_uint256":{"entryPoint":2880,"id":null,"parameterSlots":2,"returnSlots":2},"abi_encode_t_bool_to_t_bool_fromStack":{"entryPoint":2956,"id":null,"parameterSlots":2,"returnSlots":0},"abi_encode_t_string_memory_ptr_to_t_string_memory_ptr_fromStack":{"entryPoint":2636,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_t_stringliteral_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618_to_t_string_memory_ptr_fromStack":{"entryPoint":3532,"id":null,"parameterSlots":1,"returnSlots":1},"abi_encode_t_stringliteral_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee_to_t_string_memory_ptr_fromStack":{"entryPoint":3424,"id":null,"parameterSlots":1,"returnSlots":1},"abi_encode_t_uint256_to_t_uint256_fromStack":{"entryPoint":2998,"id":null,"parameterSlots":2,"returnSlots":0},"abi_encode_t_uint8_to_t_uint8_fromStack":{"entryPoint":3136,"id":null,"parameterSlots":2,"returnSlots":0},"abi_encode_tuple_t_bool__to_t_bool__fromStack_reversed":{"entryPoint":2971,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_tuple_t_string_memory_ptr__to_t_string_memory_ptr__fromStack_reversed":{"entryPoint":2693,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_tuple_t_stringliteral_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618__to_t_string_memory_ptr__fromStack_reversed":{"entryPoint":3567,"id":null,"parameterSlots":1,"returnSlots":1},"abi_encode_tuple_t_stringliteral_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee__to_t_string_memory_ptr__fromStack_reversed":{"entryPoint":3459,"id":null,"parameterSlots":1,"returnSlots":1},"abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed":{"entryPoint":3013,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_tuple_t_uint8__to_t_uint8__fromStack_reversed":{"entryPoint":3151,"id":null,"parameterSlots":2,"returnSlots":1},"allocate_unbounded":{"entryPoint":null,"id":null,"parameterSlots":0,"returnSlots":1},"array_length_t_string_memory_ptr":{"entryPoint":2549,"id":null,"parameterSlots":1,"returnSlots":1},"array_storeLengthForEncoding_t_string_memory_ptr_fromStack":{"entryPoint":2560,"id":null,"parameterSlots":2,"returnSlots":1},"checked_add_t_uint256":{"entryPoint":3698,"id":null,"parameterSlots":2,"returnSlots":1},"checked_sub_t_uint256":{"entryPoint":3646,"id":null,"parameterSlots":2,"returnSlots":1},"cleanup_t_address":{"entryPoint":2764,"id":null,"parameterSlots":1,"returnSlots":1},"cleanup_t_bool":{"entryPoint":2944,"id":null,"parameterSlots":1,"returnSlots":1},"cleanup_t_uint160":{"entryPoint":2732,"id":null,"parameterSlots":1,"returnSlots":1},"cleanup_t_uint256":{"entryPoint":2826,"id":null,"parameterSlots":1,"returnSlots":1},"cleanup_t_uint8":{"entryPoint":3123,"id":null,"parameterSlots":1,"returnSlots":1},"copy_memory_to_memory_with_cleanup":{"entryPoint":2577,"id":null,"parameterSlots":3,"returnSlots":0},"extract_byte_array_length":{"entryPoint":3334,"id":null,"parameterSlots":1,"returnSlots":1},"panic_error_0x11":{"entryPoint":3599,"id":null,"parameterSlots":0,"returnSlots":0},"panic_error_0x22":{"entryPoint":3287,"id":null,"parameterSlots":0,"returnSlots":0},"revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db":{"entryPoint":null,"id":null,"parameterSlots":0,"returnSlots":0},"revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b":{"entryPoint":2727,"id":null,"parameterSlots":0,"returnSlots":0},"round_up_to_mul_of_32":{"entryPoint":2619,"id":null,"parameterSlots":1,"returnSlots":1},"store_literal_in_memory_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618":{"entryPoint":3491,"id":null,"parameterSlots":1,"returnSlots":0},"store_literal_in_memory_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee":{"entryPoint":3383,"id":null,"parameterSlots":1,"returnSlots":0},"validator_revert_t_address":{"entryPoint":2782,"id":null,"parameterSlots":1,"returnSlots":0},"validator_revert_t_uint256":{"entryPoint":2836,"id":null,"parameterSlots":1,"returnSlots":0}},"generatedSources":[{"ast":{"nativeSrc":"0:8703:1","nodeType":"YulBlock","src":"0:8703:1","statements":[{"body":{"nativeSrc":"66:40:1","nodeType":"YulBlock","src":"66:40:1","statements":[{"nativeSrc":"77:22:1","nodeType":"YulAssignment","src":"77:22:1","value":{"arguments":[{"name":"value","nativeSrc":"93:5:1","nodeType":"YulIdentifier","src":"93:5:1"}],"functionName":{"name":"mload","nativeSrc":"87:5:1","nodeType":"YulIdentifier","src":"87:5:1"},"nativeSrc":"87:12:1","nodeType":"YulFunctionCall","src":"87:12:1"},"variableNames":[{"name":"length","nativeSrc":"77:6:1","nodeType":"YulIdentifier","src":"77:6:1"}]}]},"name":"array_length_t_string_memory_ptr","nativeSrc":"7:99:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"49:5:1","nodeType":"YulTypedName","src":"49:5:1","type":""}],"returnVariables":[{"name":"length","nativeSrc":"59:6:1","nodeType":"YulTypedName","src":"59:6:1","type":""}],"src":"7:99:1"},{"body":{"nativeSrc":"208:73:1","nodeType":"YulBlock","src":"208:73:1","statements":[{"expression":{"arguments":[{"name":"pos","nativeSrc":"225:3:1","nodeType":"YulIdentifier","src":"225:3:1"},{"name":"length","nativeSrc":"230:6:1","nodeType":"YulIdentifier","src":"230:6:1"}],"functionName":{"name":"mstore","nativeSrc":"218:6:1","nodeType":"YulIdentifier","src":"218:6:1"},"nativeSrc":"218:19:1","nodeType":"YulFunctionCall","src":"218:19:1"},"nativeSrc":"218:19:1","nodeType":"YulExpressionStatement","src":"218:19:1"},{"nativeSrc":"246:29:1","nodeType":"YulAssignment","src":"246:29:1","value":{"arguments":[{"name":"pos","nativeSrc":"265:3:1","nodeType":"YulIdentifier","src":"265:3:1"},{"kind":"number","nativeSrc":"270:4:1","nodeType":"YulLiteral","src":"270:4:1","type":"","value":"0x20"}],"functionName":{"name":"add","nativeSrc":"261:3:1","nodeType":"YulIdentifier","src":"261:3:1"},"nativeSrc":"261:14:1","nodeType":"YulFunctionCall","src":"261:14:1"},"variableNames":[{"name":"updated_pos","nativeSrc":"246:11:1","nodeType":"YulIdentifier","src":"246:11:1"}]}]},"name":"array_storeLengthForEncoding_t_string_memory_ptr_fromStack","nativeSrc":"112:169:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"pos","nativeSrc":"180:3:1","nodeType":"YulTypedName","src":"180:3:1","type":""},{"name":"length","nativeSrc":"185:6:1","nodeType":"YulTypedName","src":"185:6:1","type":""}],"returnVariables":[{"name":"updated_pos","nativeSrc":"196:11:1","nodeType":"YulTypedName","src":"196:11:1","type":""}],"src":"112:169:1"},{"body":{"nativeSrc":"349:184:1","nodeType":"YulBlock","src":"349:184:1","statements":[{"nativeSrc":"359:10:1","nodeType":"YulVariableDeclaration","src":"359:10:1","value":{"kind":"number","nativeSrc":"368:1:1","nodeType":"YulLiteral","src":"368:1:1","type":"","value":"0"},"variables":[{"name":"i","nativeSrc":"363:1:1","nodeType":"YulTypedName","src":"363:1:1","type":""}]},{"body":{"nativeSrc":"428:63:1","nodeType":"YulBlock","src":"428:63:1","statements":[{"expression":{"arguments":[{"arguments":[{"name":"dst","nativeSrc":"453:3:1","nodeType":"YulIdentifier","src":"453:3:1"},{"name":"i","nativeSrc":"458:1:1","nodeType":"YulIdentifier","src":"458:1:1"}],"functionName":{"name":"add","nativeSrc":"449:3:1","nodeType":"YulIdentifier","src":"449:3:1"},"nativeSrc":"449:11:1","nodeType":"YulFunctionCall","src":"449:11:1"},{"arguments":[{"arguments":[{"name":"src","nativeSrc":"472:3:1","nodeType":"YulIdentifier","src":"472:3:1"},{"name":"i","nativeSrc":"477:1:1","nodeType":"YulIdentifier","src":"477:1:1"}],"functionName":{"name":"add","nativeSrc":"468:3:1","nodeType":"YulIdentifier","src":"468:3:1"},"nativeSrc":"468:11:1","nodeType":"YulFunctionCall","src":"468:11:1"}],"functionName":{"name":"mload","nativeSrc":"462:5:1","nodeType":"YulIdentifier","src":"462:5:1"},"nativeSrc":"462:18:1","nodeType":"YulFunctionCall","src":"462:18:1"}],"functionName":{"name":"mstore","nativeSrc":"442:6:1","nodeType":"YulIdentifier","src":"442:6:1"},"nativeSrc":"442:39:1","nodeType":"YulFunctionCall","src":"442:39:1"},"nativeSrc":"442:39:1","nodeType":"YulExpressionStatement","src":"442:39:1"}]},"condition":{"arguments":[{"name":"i","nativeSrc":"389:1:1","nodeType":"YulIdentifier","src":"389:1:1"},{"name":"length","nativeSrc":"392:6:1","nodeType":"YulIdentifier","src":"392:6:1"}],"functionName":{"name":"lt","nativeSrc":"386:2:1","nodeType":"YulIdentifier","src":"386:2:1"},"nativeSrc":"386:13:1","nodeType":"YulFunctionCall","src":"386:13:1"},"nativeSrc":"378:113:1","nodeType":"YulForLoop","post":{"nativeSrc":"400:19:1","nodeType":"YulBlock","src":"400:19:1","statements":[{"nativeSrc":"402:15:1","nodeType":"YulAssignment","src":"402:15:1","value":{"arguments":[{"name":"i","nativeSrc":"411:1:1","nodeType":"YulIdentifier","src":"411:1:1"},{"kind":"number","nativeSrc":"414:2:1","nodeType":"YulLiteral","src":"414:2:1","type":"","value":"32"}],"functionName":{"name":"add","nativeSrc":"407:3:1","nodeType":"YulIdentifier","src":"407:3:1"},"nativeSrc":"407:10:1","nodeType":"YulFunctionCall","src":"407:10:1"},"variableNames":[{"name":"i","nativeSrc":"402:1:1","nodeType":"YulIdentifier","src":"402:1:1"}]}]},"pre":{"nativeSrc":"382:3:1","nodeType":"YulBlock","src":"382:3:1","statements":[]},"src":"378:113:1"},{"expression":{"arguments":[{"arguments":[{"name":"dst","nativeSrc":"511:3:1","nodeType":"YulIdentifier","src":"511:3:1"},{"name":"length","nativeSrc":"516:6:1","nodeType":"YulIdentifier","src":"516:6:1"}],"functionName":{"name":"add","nativeSrc":"507:3:1","nodeType":"YulIdentifier","src":"507:3:1"},"nativeSrc":"507:16:1","nodeType":"YulFunctionCall","src":"507:16:1"},{"kind":"number","nativeSrc":"525:1:1","nodeType":"YulLiteral","src":"525:1:1","type":"","value":"0"}],"functionName":{"name":"mstore","nativeSrc":"500:6:1","nodeType":"YulIdentifier","src":"500:6:1"},"nativeSrc":"500:27:1","nodeType":"YulFunctionCall","src":"500:27:1"},"nativeSrc":"500:27:1","nodeType":"YulExpressionStatement","src":"500:27:1"}]},"name":"copy_memory_to_memory_with_cleanup","nativeSrc":"287:246:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"src","nativeSrc":"331:3:1","nodeType":"YulTypedName","src":"331:3:1","type":""},{"name":"dst","nativeSrc":"336:3:1","nodeType":"YulTypedName","src":"336:3:1","type":""},{"name":"length","nativeSrc":"341:6:1","nodeType":"YulTypedName","src":"341:6:1","type":""}],"src":"287:246:1"},{"body":{"nativeSrc":"587:54:1","nodeType":"YulBlock","src":"587:54:1","statements":[{"nativeSrc":"597:38:1","nodeType":"YulAssignment","src":"597:38:1","value":{"arguments":[{"arguments":[{"name":"value","nativeSrc":"615:5:1","nodeType":"YulIdentifier","src":"615:5:1"},{"kind":"number","nativeSrc":"622:2:1","nodeType":"YulLiteral","src":"622:2:1","type":"","value":"31"}],"functionName":{"name":"add","nativeSrc":"611:3:1","nodeType":"YulIdentifier","src":"611:3:1"},"nativeSrc":"611:14:1","nodeType":"YulFunctionCall","src":"611:14:1"},{"arguments":[{"kind":"number","nativeSrc":"631:2:1","nodeType":"YulLiteral","src":"631:2:1","type":"","value":"31"}],"functionName":{"name":"not","nativeSrc":"627:3:1","nodeType":"YulIdentifier","src":"627:3:1"},"nativeSrc":"627:7:1","nodeType":"YulFunctionCall","src":"627:7:1"}],"functionName":{"name":"and","nativeSrc":"607:3:1","nodeType":"YulIdentifier","src":"607:3:1"},"nativeSrc":"607:28:1","nodeType":"YulFunctionCall","src":"607:28:1"},"variableNames":[{"name":"result","nativeSrc":"597:6:1","nodeType":"YulIdentifier","src":"597:6:1"}]}]},"name":"round_up_to_mul_of_32","nativeSrc":"539:102:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"570:5:1","nodeType":"YulTypedName","src":"570:5:1","type":""}],"returnVariables":[{"name":"result","nativeSrc":"580:6:1","nodeType":"YulTypedName","src":"580:6:1","type":""}],"src":"539:102:1"},{"body":{"nativeSrc":"739:285:1","nodeType":"YulBlock","src":"739:285:1","statements":[{"nativeSrc":"749:53:1","nodeType":"YulVariableDeclaration","src":"749:53:1","value":{"arguments":[{"name":"value","nativeSrc":"796:5:1","nodeType":"YulIdentifier","src":"796:5:1"}],"functionName":{"name":"array_length_t_string_memory_ptr","nativeSrc":"763:32:1","nodeType":"YulIdentifier","src":"763:32:1"},"nativeSrc":"763:39:1","nodeType":"YulFunctionCall","src":"763:39:1"},"variables":[{"name":"length","nativeSrc":"753:6:1","nodeType":"YulTypedName","src":"753:6:1","type":""}]},{"nativeSrc":"811:78:1","nodeType":"YulAssignment","src":"811:78:1","value":{"arguments":[{"name":"pos","nativeSrc":"877:3:1","nodeType":"YulIdentifier","src":"877:3:1"},{"name":"length","nativeSrc":"882:6:1","nodeType":"YulIdentifier","src":"882:6:1"}],"functionName":{"name":"array_storeLengthForEncoding_t_string_memory_ptr_fromStack","nativeSrc":"818:58:1","nodeType":"YulIdentifier","src":"818:58:1"},"nativeSrc":"818:71:1","nodeType":"YulFunctionCall","src":"818:71:1"},"variableNames":[{"name":"pos","nativeSrc":"811:3:1","nodeType":"YulIdentifier","src":"811:3:1"}]},{"expression":{"arguments":[{"arguments":[{"name":"value","nativeSrc":"937:5:1","nodeType":"YulIdentifier","src":"937:5:1"},{"kind":"number","nativeSrc":"944:4:1","nodeType":"YulLiteral","src":"944:4:1","type":"","value":"0x20"}],"functionName":{"name":"add","nativeSrc":"933:3:1","nodeType":"YulIdentifier","src":"933:3:1"},"nativeSrc":"933:16:1","nodeType":"YulFunctionCall","src":"933:16:1"},{"name":"pos","nativeSrc":"951:3:1","nodeType":"YulIdentifier","src":"951:3:1"},{"name":"length","nativeSrc":"956:6:1","nodeType":"YulIdentifier","src":"956:6:1"}],"functionName":{"name":"copy_memory_to_memory_with_cleanup","nativeSrc":"898:34:1","nodeType":"YulIdentifier","src":"898:34:1"},"nativeSrc":"898:65:1","nodeType":"YulFunctionCall","src":"898:65:1"},"nativeSrc":"898:65:1","nodeType":"YulExpressionStatement","src":"898:65:1"},{"nativeSrc":"972:46:1","nodeType":"YulAssignment","src":"972:46:1","value":{"arguments":[{"name":"pos","nativeSrc":"983:3:1","nodeType":"YulIdentifier","src":"983:3:1"},{"arguments":[{"name":"length","nativeSrc":"1010:6:1","nodeType":"YulIdentifier","src":"1010:6:1"}],"functionName":{"name":"round_up_to_mul_of_32","nativeSrc":"988:21:1","nodeType":"YulIdentifier","src":"988:21:1"},"nativeSrc":"988:29:1","nodeType":"YulFunctionCall","src":"988:29:1"}],"functionName":{"name":"add","nativeSrc":"979:3:1","nodeType":"YulIdentifier","src":"979:3:1"},"nativeSrc":"979:39:1","nodeType":"YulFunctionCall","src":"979:39:1"},"variableNames":[{"name":"end","nativeSrc":"972:3:1","nodeType":"YulIdentifier","src":"972:3:1"}]}]},"name":"abi_encode_t_string_memory_ptr_to_t_string_memory_ptr_fromStack","nativeSrc":"647:377:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"720:5:1","nodeType":"YulTypedName","src":"720:5:1","type":""},{"name":"pos","nativeSrc":"727:3:1","nodeType":"YulTypedName","src":"727:3:1","type":""}],"returnVariables":[{"name":"end","nativeSrc":"735:3:1","nodeType":"YulTypedName","src":"735:3:1","type":""}],"src":"647:377:1"},{"body":{"nativeSrc":"1148:195:1","nodeType":"YulBlock","src":"1148:195:1","statements":[{"nativeSrc":"1158:26:1","nodeType":"YulAssignment","src":"1158:26:1","value":{"arguments":[{"name":"headStart","nativeSrc":"1170:9:1","nodeType":"YulIdentifier","src":"1170:9:1"},{"kind":"number","nativeSrc":"1181:2:1","nodeType":"YulLiteral","src":"1181:2:1","type":"","value":"32"}],"functionName":{"name":"add","nativeSrc":"1166:3:1","nodeType":"YulIdentifier","src":"1166:3:1"},"nativeSrc":"1166:18:1","nodeType":"YulFunctionCall","src":"1166:18:1"},"variableNames":[{"name":"tail","nativeSrc":"1158:4:1","nodeType":"YulIdentifier","src":"1158:4:1"}]},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nativeSrc":"1205:9:1","nodeType":"YulIdentifier","src":"1205:9:1"},{"kind":"number","nativeSrc":"1216:1:1","nodeType":"YulLiteral","src":"1216:1:1","type":"","value":"0"}],"functionName":{"name":"add","nativeSrc":"1201:3:1","nodeType":"YulIdentifier","src":"1201:3:1"},"nativeSrc":"1201:17:1","nodeType":"YulFunctionCall","src":"1201:17:1"},{"arguments":[{"name":"tail","nativeSrc":"1224:4:1","nodeType":"YulIdentifier","src":"1224:4:1"},{"name":"headStart","nativeSrc":"1230:9:1","nodeType":"YulIdentifier","src":"1230:9:1"}],"functionName":{"name":"sub","nativeSrc":"1220:3:1","nodeType":"YulIdentifier","src":"1220:3:1"},"nativeSrc":"1220:20:1","nodeType":"YulFunctionCall","src":"1220:20:1"}],"functionName":{"name":"mstore","nativeSrc":"1194:6:1","nodeType":"YulIdentifier","src":"1194:6:1"},"nativeSrc":"1194:47:1","nodeType":"YulFunctionCall","src":"1194:47:1"},"nativeSrc":"1194:47:1","nodeType":"YulExpressionStatement","src":"1194:47:1"},{"nativeSrc":"1250:86:1","nodeType":"YulAssignment","src":"1250:86:1","value":{"arguments":[{"name":"value0","nativeSrc":"1322:6:1","nodeType":"YulIdentifier","src":"1322:6:1"},{"name":"tail","nativeSrc":"1331:4:1","nodeType":"YulIdentifier","src":"1331:4:1"}],"functionName":{"name":"abi_encode_t_string_memory_ptr_to_t_string_memory_ptr_fromStack","nativeSrc":"1258:63:1","nodeType":"YulIdentifier","src":"1258:63:1"},"nativeSrc":"1258:78:1","nodeType":"YulFunctionCall","src":"1258:78:1"},"variableNames":[{"name":"tail","nativeSrc":"1250:4:1","nodeType":"YulIdentifier","src":"1250:4:1"}]}]},"name":"abi_encode_tuple_t_string_memory_ptr__to_t_string_memory_ptr__fromStack_reversed","nativeSrc":"1030:313:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nativeSrc":"1120:9:1","nodeType":"YulTypedName","src":"1120:9:1","type":""},{"name":"value0","nativeSrc":"1132:6:1","nodeType":"YulTypedName","src":"1132:6:1","type":""}],"returnVariables":[{"name":"tail","nativeSrc":"1143:4:1","nodeType":"YulTypedName","src":"1143:4:1","type":""}],"src":"1030:313:1"},{"body":{"nativeSrc":"1389:35:1","nodeType":"YulBlock","src":"1389:35:1","statements":[{"nativeSrc":"1399:19:1","nodeType":"YulAssignment","src":"1399:19:1","value":{"arguments":[{"kind":"number","nativeSrc":"1415:2:1","nodeType":"YulLiteral","src":"1415:2:1","type":"","value":"64"}],"functionName":{"name":"mload","nativeSrc":"1409:5:1","nodeType":"YulIdentifier","src":"1409:5:1"},"nativeSrc":"1409:9:1","nodeType":"YulFunctionCall","src":"1409:9:1"},"variableNames":[{"name":"memPtr","nativeSrc":"1399:6:1","nodeType":"YulIdentifier","src":"1399:6:1"}]}]},"name":"allocate_unbounded","nativeSrc":"1349:75:1","nodeType":"YulFunctionDefinition","returnVariables":[{"name":"memPtr","nativeSrc":"1382:6:1","nodeType":"YulTypedName","src":"1382:6:1","type":""}],"src":"1349:75:1"},{"body":{"nativeSrc":"1519:28:1","nodeType":"YulBlock","src":"1519:28:1","statements":[{"expression":{"arguments":[{"kind":"number","nativeSrc":"1536:1:1","nodeType":"YulLiteral","src":"1536:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"1539:1:1","nodeType":"YulLiteral","src":"1539:1:1","type":"","value":"0"}],"functionName":{"name":"revert","nativeSrc":"1529:6:1","nodeType":"YulIdentifier","src":"1529:6:1"},"nativeSrc":"1529:12:1","nodeType":"YulFunctionCall","src":"1529:12:1"},"nativeSrc":"1529:12:1","nodeType":"YulExpressionStatement","src":"1529:12:1"}]},"name":"revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b","nativeSrc":"1430:117:1","nodeType":"YulFunctionDefinition","src":"1430:117:1"},{"body":{"nativeSrc":"1642:28:1","nodeType":"YulBlock","src":"1642:28:1","statements":[{"expression":{"arguments":[{"kind":"number","nativeSrc":"1659:1:1","nodeType":"YulLiteral","src":"1659:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"1662:1:1","nodeType":"YulLiteral","src":"1662:1:1","type":"","value":"0"}],"functionName":{"name":"revert","nativeSrc":"1652:6:1","nodeType":"YulIdentifier","src":"1652:6:1"},"nativeSrc":"1652:12:1","nodeType":"YulFunctionCall","src":"1652:12:1"},"nativeSrc":"1652:12:1","nodeType":"YulExpressionStatement","src":"1652:12:1"}]},"name":"revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db","nativeSrc":"1553:117:1","nodeType":"YulFunctionDefinition","src":"1553:117:1"},{"body":{"nativeSrc":"1721:81:1","nodeType":"YulBlock","src":"1721:81:1","statements":[{"nativeSrc":"1731:65:1","nodeType":"YulAssignment","src":"1731:65:1","value":{"arguments":[{"name":"value","nativeSrc":"1746:5:1","nodeType":"YulIdentifier","src":"1746:5:1"},{"kind":"number","nativeSrc":"1753:42:1","nodeType":"YulLiteral","src":"1753:42:1","type":"","value":"0xffffffffffffffffffffffffffffffffffffffff"}],"functionName":{"name":"and","nativeSrc":"1742:3:1","nodeType":"YulIdentifier","src":"1742:3:1"},"nativeSrc":"1742:54:1","nodeType":"YulFunctionCall","src":"1742:54:1"},"variableNames":[{"name":"cleaned","nativeSrc":"1731:7:1","nodeType":"YulIdentifier","src":"1731:7:1"}]}]},"name":"cleanup_t_uint160","nativeSrc":"1676:126:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"1703:5:1","nodeType":"YulTypedName","src":"1703:5:1","type":""}],"returnVariables":[{"name":"cleaned","nativeSrc":"1713:7:1","nodeType":"YulTypedName","src":"1713:7:1","type":""}],"src":"1676:126:1"},{"body":{"nativeSrc":"1853:51:1","nodeType":"YulBlock","src":"1853:51:1","statements":[{"nativeSrc":"1863:35:1","nodeType":"YulAssignment","src":"1863:35:1","value":{"arguments":[{"name":"value","nativeSrc":"1892:5:1","nodeType":"YulIdentifier","src":"1892:5:1"}],"functionName":{"name":"cleanup_t_uint160","nativeSrc":"1874:17:1","nodeType":"YulIdentifier","src":"1874:17:1"},"nativeSrc":"1874:24:1","nodeType":"YulFunctionCall","src":"1874:24:1"},"variableNames":[{"name":"cleaned","nativeSrc":"1863:7:1","nodeType":"YulIdentifier","src":"1863:7:1"}]}]},"name":"cleanup_t_address","nativeSrc":"1808:96:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"1835:5:1","nodeType":"YulTypedName","src":"1835:5:1","type":""}],"returnVariables":[{"name":"cleaned","nativeSrc":"1845:7:1","nodeType":"YulTypedName","src":"1845:7:1","type":""}],"src":"1808:96:1"},{"body":{"nativeSrc":"1953:79:1","nodeType":"YulBlock","src":"1953:79:1","statements":[{"body":{"nativeSrc":"2010:16:1","nodeType":"YulBlock","src":"2010:16:1","statements":[{"expression":{"arguments":[{"kind":"number","nativeSrc":"2019:1:1","nodeType":"YulLiteral","src":"2019:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"2022:1:1","nodeType":"YulLiteral","src":"2022:1:1","type":"","value":"0"}],"functionName":{"name":"revert","nativeSrc":"2012:6:1","nodeType":"YulIdentifier","src":"2012:6:1"},"nativeSrc":"2012:12:1","nodeType":"YulFunctionCall","src":"2012:12:1"},"nativeSrc":"2012:12:1","nodeType":"YulExpressionStatement","src":"2012:12:1"}]},"condition":{"arguments":[{"arguments":[{"name":"value","nativeSrc":"1976:5:1","nodeType":"YulIdentifier","src":"1976:5:1"},{"arguments":[{"name":"value","nativeSrc":"2001:5:1","nodeType":"YulIdentifier","src":"2001:5:1"}],"functionName":{"name":"cleanup_t_address","nativeSrc":"1983:17:1","nodeType":"YulIdentifier","src":"1983:17:1"},"nativeSrc":"1983:24:1","nodeType":"YulFunctionCall","src":"1983:24:1"}],"functionName":{"name":"eq","nativeSrc":"1973:2:1","nodeType":"YulIdentifier","src":"1973:2:1"},"nativeSrc":"1973:35:1","nodeType":"YulFunctionCall","src":"1973:35:1"}],"functionName":{"name":"iszero","nativeSrc":"1966:6:1","nodeType":"YulIdentifier","src":"1966:6:1"},"nativeSrc":"1966:43:1","nodeType":"YulFunctionCall","src":"1966:43:1"},"nativeSrc":"1963:63:1","nodeType":"YulIf","src":"1963:63:1"}]},"name":"validator_revert_t_address","nativeSrc":"1910:122:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"1946:5:1","nodeType":"YulTypedName","src":"1946:5:1","type":""}],"src":"1910:122:1"},{"body":{"nativeSrc":"2090:87:1","nodeType":"YulBlock","src":"2090:87:1","statements":[{"nativeSrc":"2100:29:1","nodeType":"YulAssignment","src":"2100:29:1","value":{"arguments":[{"name":"offset","nativeSrc":"2122:6:1","nodeType":"YulIdentifier","src":"2122:6:1"}],"functionName":{"name":"calldataload","nativeSrc":"2109:12:1","nodeType":"YulIdentifier","src":"2109:12:1"},"nativeSrc":"2109:20:1","nodeType":"YulFunctionCall","src":"2109:20:1"},"variableNames":[{"name":"value","nativeSrc":"2100:5:1","nodeType":"YulIdentifier","src":"2100:5:1"}]},{"expression":{"arguments":[{"name":"value","nativeSrc":"2165:5:1","nodeType":"YulIdentifier","src":"2165:5:1"}],"functionName":{"name":"validator_revert_t_address","nativeSrc":"2138:26:1","nodeType":"YulIdentifier","src":"2138:26:1"},"nativeSrc":"2138:33:1","nodeType":"YulFunctionCall","src":"2138:33:1"},"nativeSrc":"2138:33:1","nodeType":"YulExpressionStatement","src":"2138:33:1"}]},"name":"abi_decode_t_address","nativeSrc":"2038:139:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"offset","nativeSrc":"2068:6:1","nodeType":"YulTypedName","src":"2068:6:1","type":""},{"name":"end","nativeSrc":"2076:3:1","nodeType":"YulTypedName","src":"2076:3:1","type":""}],"returnVariables":[{"name":"value","nativeSrc":"2084:5:1","nodeType":"YulTypedName","src":"2084:5:1","type":""}],"src":"2038:139:1"},{"body":{"nativeSrc":"2228:32:1","nodeType":"YulBlock","src":"2228:32:1","statements":[{"nativeSrc":"2238:16:1","nodeType":"YulAssignment","src":"2238:16:1","value":{"name":"value","nativeSrc":"2249:5:1","nodeType":"YulIdentifier","src":"2249:5:1"},"variableNames":[{"name":"cleaned","nativeSrc":"2238:7:1","nodeType":"YulIdentifier","src":"2238:7:1"}]}]},"name":"cleanup_t_uint256","nativeSrc":"2183:77:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"2210:5:1","nodeType":"YulTypedName","src":"2210:5:1","type":""}],"returnVariables":[{"name":"cleaned","nativeSrc":"2220:7:1","nodeType":"YulTypedName","src":"2220:7:1","type":""}],"src":"2183:77:1"},{"body":{"nativeSrc":"2309:79:1","nodeType":"YulBlock","src":"2309:79:1","statements":[{"body":{"nativeSrc":"2366:16:1","nodeType":"YulBlock","src":"2366:16:1","statements":[{"expression":{"arguments":[{"kind":"number","nativeSrc":"2375:1:1","nodeType":"YulLiteral","src":"2375:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"2378:1:1","nodeType":"YulLiteral","src":"2378:1:1","type":"","value":"0"}],"functionName":{"name":"revert","nativeSrc":"2368:6:1","nodeType":"YulIdentifier","src":"2368:6:1"},"nativeSrc":"2368:12:1","nodeType":"YulFunctionCall","src":"2368:12:1"},"nativeSrc":"2368:12:1","nodeType":"YulExpressionStatement","src":"2368:12:1"}]},"condition":{"arguments":[{"arguments":[{"name":"value","nativeSrc":"2332:5:1","nodeType":"YulIdentifier","src":"2332:5:1"},{"arguments":[{"name":"value","nativeSrc":"2357:5:1","nodeType":"YulIdentifier","src":"2357:5:1"}],"functionName":{"name":"cleanup_t_uint256","nativeSrc":"2339:17:1","nodeType":"YulIdentifier","src":"2339:17:1"},"nativeSrc":"2339:24:1","nodeType":"YulFunctionCall","src":"2339:24:1"}],"functionName":{"name":"eq","nativeSrc":"2329:2:1","nodeType":"YulIdentifier","src":"2329:2:1"},"nativeSrc":"2329:35:1","nodeType":"YulFunctionCall","src":"2329:35:1"}],"functionName":{"name":"iszero","nativeSrc":"2322:6:1","nodeType":"YulIdentifier","src":"2322:6:1"},"nativeSrc":"2322:43:1","nodeType":"YulFunctionCall","src":"2322:43:1"},"nativeSrc":"2319:63:1","nodeType":"YulIf","src":"2319:63:1"}]},"name":"validator_revert_t_uint256","nativeSrc":"2266:122:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"2302:5:1","nodeType":"YulTypedName","src":"2302:5:1","type":""}],"src":"2266:122:1"},{"body":{"nativeSrc":"2446:87:1","nodeType":"YulBlock","src":"2446:87:1","statements":[{"nativeSrc":"2456:29:1","nodeType":"YulAssignment","src":"2456:29:1","value":{"arguments":[{"name":"offset","nativeSrc":"2478:6:1","nodeType":"YulIdentifier","src":"2478:6:1"}],"functionName":{"name":"calldataload","nativeSrc":"2465:12:1","nodeType":"YulIdentifier","src":"2465:12:1"},"nativeSrc":"2465:20:1","nodeType":"YulFunctionCall","src":"2465:20:1"},"variableNames":[{"name":"value","nativeSrc":"2456:5:1","nodeType":"YulIdentifier","src":"2456:5:1"}]},{"expression":{"arguments":[{"name":"value","nativeSrc":"2521:5:1","nodeType":"YulIdentifier","src":"2521:5:1"}],"functionName":{"name":"validator_revert_t_uint256","nativeSrc":"2494:26:1","nodeType":"YulIdentifier","src":"2494:26:1"},"nativeSrc":"2494:33:1","nodeType":"YulFunctionCall","src":"2494:33:1"},"nativeSrc":"2494:33:1","nodeType":"YulExpressionStatement","src":"2494:33:1"}]},"name":"abi_decode_t_uint256","nativeSrc":"2394:139:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"offset","nativeSrc":"2424:6:1","nodeType":"YulTypedName","src":"2424:6:1","type":""},{"name":"end","nativeSrc":"2432:3:1","nodeType":"YulTypedName","src":"2432:3:1","type":""}],"returnVariables":[{"name":"value","nativeSrc":"2440:5:1","nodeType":"YulTypedName","src":"2440:5:1","type":""}],"src":"2394:139:1"},{"body":{"nativeSrc":"2622:391:1","nodeType":"YulBlock","src":"2622:391:1","statements":[{"body":{"nativeSrc":"2668:83:1","nodeType":"YulBlock","src":"2668:83:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b","nativeSrc":"2670:77:1","nodeType":"YulIdentifier","src":"2670:77:1"},"nativeSrc":"2670:79:1","nodeType":"YulFunctionCall","src":"2670:79:1"},"nativeSrc":"2670:79:1","nodeType":"YulExpressionStatement","src":"2670:79:1"}]},"condition":{"arguments":[{"arguments":[{"name":"dataEnd","nativeSrc":"2643:7:1","nodeType":"YulIdentifier","src":"2643:7:1"},{"name":"headStart","nativeSrc":"2652:9:1","nodeType":"YulIdentifier","src":"2652:9:1"}],"functionName":{"name":"sub","nativeSrc":"2639:3:1","nodeType":"YulIdentifier","src":"2639:3:1"},"nativeSrc":"2639:23:1","nodeType":"YulFunctionCall","src":"2639:23:1"},{"kind":"number","nativeSrc":"2664:2:1","nodeType":"YulLiteral","src":"2664:2:1","type":"","value":"64"}],"functionName":{"name":"slt","nativeSrc":"2635:3:1","nodeType":"YulIdentifier","src":"2635:3:1"},"nativeSrc":"2635:32:1","nodeType":"YulFunctionCall","src":"2635:32:1"},"nativeSrc":"2632:119:1","nodeType":"YulIf","src":"2632:119:1"},{"nativeSrc":"2761:117:1","nodeType":"YulBlock","src":"2761:117:1","statements":[{"nativeSrc":"2776:15:1","nodeType":"YulVariableDeclaration","src":"2776:15:1","value":{"kind":"number","nativeSrc":"2790:1:1","nodeType":"YulLiteral","src":"2790:1:1","type":"","value":"0"},"variables":[{"name":"offset","nativeSrc":"2780:6:1","nodeType":"YulTypedName","src":"2780:6:1","type":""}]},{"nativeSrc":"2805:63:1","nodeType":"YulAssignment","src":"2805:63:1","value":{"arguments":[{"arguments":[{"name":"headStart","nativeSrc":"2840:9:1","nodeType":"YulIdentifier","src":"2840:9:1"},{"name":"offset","nativeSrc":"2851:6:1","nodeType":"YulIdentifier","src":"2851:6:1"}],"functionName":{"name":"add","nativeSrc":"2836:3:1","nodeType":"YulIdentifier","src":"2836:3:1"},"nativeSrc":"2836:22:1","nodeType":"YulFunctionCall","src":"2836:22:1"},{"name":"dataEnd","nativeSrc":"2860:7:1","nodeType":"YulIdentifier","src":"2860:7:1"}],"functionName":{"name":"abi_decode_t_address","nativeSrc":"2815:20:1","nodeType":"YulIdentifier","src":"2815:20:1"},"nativeSrc":"2815:53:1","nodeType":"YulFunctionCall","src":"2815:53:1"},"variableNames":[{"name":"value0","nativeSrc":"2805:6:1","nodeType":"YulIdentifier","src":"2805:6:1"}]}]},{"nativeSrc":"2888:118:1","nodeType":"YulBlock","src":"2888:118:1","statements":[{"nativeSrc":"2903:16:1","nodeType":"YulVariableDeclaration","src":"2903:16:1","value":{"kind":"number","nativeSrc":"2917:2:1","nodeType":"YulLiteral","src":"2917:2:1","type":"","value":"32"},"variables":[{"name":"offset","nativeSrc":"2907:6:1","nodeType":"YulTypedName","src":"2907:6:1","type":""}]},{"nativeSrc":"2933:63:1","nodeType":"YulAssignment","src":"2933:63:1","value":{"arguments":[{"arguments":[{"name":"headStart","nativeSrc":"2968:9:1","nodeType":"YulIdentifier","src":"2968:9:1"},{"name":"offset","nativeSrc":"2979:6:1","nodeType":"YulIdentifier","src":"2979:6:1"}],"functionName":{"name":"add","nativeSrc":"2964:3:1","nodeType":"YulIdentifier","src":"2964:3:1"},"nativeSrc":"2964:22:1","nodeType":"YulFunctionCall","src":"2964:22:1"},{"name":"dataEnd","nativeSrc":"2988:7:1","nodeType":"YulIdentifier","src":"2988:7:1"}],"functionName":{"name":"abi_decode_t_uint256","nativeSrc":"2943:20:1","nodeType":"YulIdentifier","src":"2943:20:1"},"nativeSrc":"2943:53:1","nodeType":"YulFunctionCall","src":"2943:53:1"},"variableNames":[{"name":"value1","nativeSrc":"2933:6:1","nodeType":"YulIdentifier","src":"2933:6:1"}]}]}]},"name":"abi_decode_tuple_t_addresst_uint256","nativeSrc":"2539:474:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nativeSrc":"2584:9:1","nodeType":"YulTypedName","src":"2584:9:1","type":""},{"name":"dataEnd","nativeSrc":"2595:7:1","nodeType":"YulTypedName","src":"2595:7:1","type":""}],"returnVariables":[{"name":"value0","nativeSrc":"2607:6:1","nodeType":"YulTypedName","src":"2607:6:1","type":""},{"name":"value1","nativeSrc":"2615:6:1","nodeType":"YulTypedName","src":"2615:6:1","type":""}],"src":"2539:474:1"},{"body":{"nativeSrc":"3061:48:1","nodeType":"YulBlock","src":"3061:48:1","statements":[{"nativeSrc":"3071:32:1","nodeType":"YulAssignment","src":"3071:32:1","value":{"arguments":[{"arguments":[{"name":"value","nativeSrc":"3096:5:1","nodeType":"YulIdentifier","src":"3096:5:1"}],"functionName":{"name":"iszero","nativeSrc":"3089:6:1","nodeType":"YulIdentifier","src":"3089:6:1"},"nativeSrc":"3089:13:1","nodeType":"YulFunctionCall","src":"3089:13:1"}],"functionName":{"name":"iszero","nativeSrc":"3082:6:1","nodeType":"YulIdentifier","src":"3082:6:1"},"nativeSrc":"3082:21:1","nodeType":"YulFunctionCall","src":"3082:21:1"},"variableNames":[{"name":"cleaned","nativeSrc":"3071:7:1","nodeType":"YulIdentifier","src":"3071:7:1"}]}]},"name":"cleanup_t_bool","nativeSrc":"3019:90:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"3043:5:1","nodeType":"YulTypedName","src":"3043:5:1","type":""}],"returnVariables":[{"name":"cleaned","nativeSrc":"3053:7:1","nodeType":"YulTypedName","src":"3053:7:1","type":""}],"src":"3019:90:1"},{"body":{"nativeSrc":"3174:50:1","nodeType":"YulBlock","src":"3174:50:1","statements":[{"expression":{"arguments":[{"name":"pos","nativeSrc":"3191:3:1","nodeType":"YulIdentifier","src":"3191:3:1"},{"arguments":[{"name":"value","nativeSrc":"3211:5:1","nodeType":"YulIdentifier","src":"3211:5:1"}],"functionName":{"name":"cleanup_t_bool","nativeSrc":"3196:14:1","nodeType":"YulIdentifier","src":"3196:14:1"},"nativeSrc":"3196:21:1","nodeType":"YulFunctionCall","src":"3196:21:1"}],"functionName":{"name":"mstore","nativeSrc":"3184:6:1","nodeType":"YulIdentifier","src":"3184:6:1"},"nativeSrc":"3184:34:1","nodeType":"YulFunctionCall","src":"3184:34:1"},"nativeSrc":"3184:34:1","nodeType":"YulExpressionStatement","src":"3184:34:1"}]},"name":"abi_encode_t_bool_to_t_bool_fromStack","nativeSrc":"3115:109:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"3162:5:1","nodeType":"YulTypedName","src":"3162:5:1","type":""},{"name":"pos","nativeSrc":"3169:3:1","nodeType":"YulTypedName","src":"3169:3:1","type":""}],"src":"3115:109:1"},{"body":{"nativeSrc":"3322:118:1","nodeType":"YulBlock","src":"3322:118:1","statements":[{"nativeSrc":"3332:26:1","nodeType":"YulAssignment","src":"3332:26:1","value":{"arguments":[{"name":"headStart","nativeSrc":"3344:9:1","nodeType":"YulIdentifier","src":"3344:9:1"},{"kind":"number","nativeSrc":"3355:2:1","nodeType":"YulLiteral","src":"3355:2:1","type":"","value":"32"}],"functionName":{"name":"add","nativeSrc":"3340:3:1","nodeType":"YulIdentifier","src":"3340:3:1"},"nativeSrc":"3340:18:1","nodeType":"YulFunctionCall","src":"3340:18:1"},"variableNames":[{"name":"tail","nativeSrc":"3332:4:1","nodeType":"YulIdentifier","src":"3332:4:1"}]},{"expression":{"arguments":[{"name":"value0","nativeSrc":"3406:6:1","nodeType":"YulIdentifier","src":"3406:6:1"},{"arguments":[{"name":"headStart","nativeSrc":"3419:9:1","nodeType":"YulIdentifier","src":"3419:9:1"},{"kind":"number","nativeSrc":"3430:1:1","nodeType":"YulLiteral","src":"3430:1:1","type":"","value":"0"}],"functionName":{"name":"add","nativeSrc":"3415:3:1","nodeType":"YulIdentifier","src":"3415:3:1"},"nativeSrc":"3415:17:1","nodeType":"YulFunctionCall","src":"3415:17:1"}],"functionName":{"name":"abi_encode_t_bool_to_t_bool_fromStack","nativeSrc":"3368:37:1","nodeType":"YulIdentifier","src":"3368:37:1"},"nativeSrc":"3368:65:1","nodeType":"YulFunctionCall","src":"3368:65:1"},"nativeSrc":"3368:65:1","nodeType":"YulExpressionStatement","src":"3368:65:1"}]},"name":"abi_encode_tuple_t_bool__to_t_bool__fromStack_reversed","nativeSrc":"3230:210:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nativeSrc":"3294:9:1","nodeType":"YulTypedName","src":"3294:9:1","type":""},{"name":"value0","nativeSrc":"3306:6:1","nodeType":"YulTypedName","src":"3306:6:1","type":""}],"returnVariables":[{"name":"tail","nativeSrc":"3317:4:1","nodeType":"YulTypedName","src":"3317:4:1","type":""}],"src":"3230:210:1"},{"body":{"nativeSrc":"3511:53:1","nodeType":"YulBlock","src":"3511:53:1","statements":[{"expression":{"arguments":[{"name":"pos","nativeSrc":"3528:3:1","nodeType":"YulIdentifier","src":"3528:3:1"},{"arguments":[{"name":"value","nativeSrc":"3551:5:1","nodeType":"YulIdentifier","src":"3551:5:1"}],"functionName":{"name":"cleanup_t_uint256","nativeSrc":"3533:17:1","nodeType":"YulIdentifier","src":"3533:17:1"},"nativeSrc":"3533:24:1","nodeType":"YulFunctionCall","src":"3533:24:1"}],"functionName":{"name":"mstore","nativeSrc":"3521:6:1","nodeType":"YulIdentifier","src":"3521:6:1"},"nativeSrc":"3521:37:1","nodeType":"YulFunctionCall","src":"3521:37:1"},"nativeSrc":"3521:37:1","nodeType":"YulExpressionStatement","src":"3521:37:1"}]},"name":"abi_encode_t_uint256_to_t_uint256_fromStack","nativeSrc":"3446:118:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"3499:5:1","nodeType":"YulTypedName","src":"3499:5:1","type":""},{"name":"pos","nativeSrc":"3506:3:1","nodeType":"YulTypedName","src":"3506:3:1","type":""}],"src":"3446:118:1"},{"body":{"nativeSrc":"3668:124:1","nodeType":"YulBlock","src":"3668:124:1","statements":[{"nativeSrc":"3678:26:1","nodeType":"YulAssignment","src":"3678:26:1","value":{"arguments":[{"name":"headStart","nativeSrc":"3690:9:1","nodeType":"YulIdentifier","src":"3690:9:1"},{"kind":"number","nativeSrc":"3701:2:1","nodeType":"YulLiteral","src":"3701:2:1","type":"","value":"32"}],"functionName":{"name":"add","nativeSrc":"3686:3:1","nodeType":"YulIdentifier","src":"3686:3:1"},"nativeSrc":"3686:18:1","nodeType":"YulFunctionCall","src":"3686:18:1"},"variableNames":[{"name":"tail","nativeSrc":"3678:4:1","nodeType":"YulIdentifier","src":"3678:4:1"}]},{"expression":{"arguments":[{"name":"value0","nativeSrc":"3758:6:1","nodeType":"YulIdentifier","src":"3758:6:1"},{"arguments":[{"name":"headStart","nativeSrc":"3771:9:1","nodeType":"YulIdentifier","src":"3771:9:1"},{"kind":"number","nativeSrc":"3782:1:1","nodeType":"YulLiteral","src":"3782:1:1","type":"","value":"0"}],"functionName":{"name":"add","nativeSrc":"3767:3:1","nodeType":"YulIdentifier","src":"3767:3:1"},"nativeSrc":"3767:17:1","nodeType":"YulFunctionCall","src":"3767:17:1"}],"functionName":{"name":"abi_encode_t_uint256_to_t_uint256_fromStack","nativeSrc":"3714:43:1","nodeType":"YulIdentifier","src":"3714:43:1"},"nativeSrc":"3714:71:1","nodeType":"YulFunctionCall","src":"3714:71:1"},"nativeSrc":"3714:71:1","nodeType":"YulExpressionStatement","src":"3714:71:1"}]},"name":"abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed","nativeSrc":"3570:222:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nativeSrc":"3640:9:1","nodeType":"YulTypedName","src":"3640:9:1","type":""},{"name":"value0","nativeSrc":"3652:6:1","nodeType":"YulTypedName","src":"3652:6:1","type":""}],"returnVariables":[{"name":"tail","nativeSrc":"3663:4:1","nodeType":"YulTypedName","src":"3663:4:1","type":""}],"src":"3570:222:1"},{"body":{"nativeSrc":"3898:519:1","nodeType":"YulBlock","src":"3898:519:1","statements":[{"body":{"nativeSrc":"3944:83:1","nodeType":"YulBlock","src":"3944:83:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b","nativeSrc":"3946:77:1","nodeType":"YulIdentifier","src":"3946:77:1"},"nativeSrc":"3946:79:1","nodeType":"YulFunctionCall","src":"3946:79:1"},"nativeSrc":"3946:79:1","nodeType":"YulExpressionStatement","src":"3946:79:1"}]},"condition":{"arguments":[{"arguments":[{"name":"dataEnd","nativeSrc":"3919:7:1","nodeType":"YulIdentifier","src":"3919:7:1"},{"name":"headStart","nativeSrc":"3928:9:1","nodeType":"YulIdentifier","src":"3928:9:1"}],"functionName":{"name":"sub","nativeSrc":"3915:3:1","nodeType":"YulIdentifier","src":"3915:3:1"},"nativeSrc":"3915:23:1","nodeType":"YulFunctionCall","src":"3915:23:1"},{"kind":"number","nativeSrc":"3940:2:1","nodeType":"YulLiteral","src":"3940:2:1","type":"","value":"96"}],"functionName":{"name":"slt","nativeSrc":"3911:3:1","nodeType":"YulIdentifier","src":"3911:3:1"},"nativeSrc":"3911:32:1","nodeType":"YulFunctionCall","src":"3911:32:1"},"nativeSrc":"3908:119:1","nodeType":"YulIf","src":"3908:119:1"},{"nativeSrc":"4037:117:1","nodeType":"YulBlock","src":"4037:117:1","statements":[{"nativeSrc":"4052:15:1","nodeType":"YulVariableDeclaration","src":"4052:15:1","value":{"kind":"number","nativeSrc":"4066:1:1","nodeType":"YulLiteral","src":"4066:1:1","type":"","value":"0"},"variables":[{"name":"offset","nativeSrc":"4056:6:1","nodeType":"YulTypedName","src":"4056:6:1","type":""}]},{"nativeSrc":"4081:63:1","nodeType":"YulAssignment","src":"4081:63:1","value":{"arguments":[{"arguments":[{"name":"headStart","nativeSrc":"4116:9:1","nodeType":"YulIdentifier","src":"4116:9:1"},{"name":"offset","nativeSrc":"4127:6:1","nodeType":"YulIdentifier","src":"4127:6:1"}],"functionName":{"name":"add","nativeSrc":"4112:3:1","nodeType":"YulIdentifier","src":"4112:3:1"},"nativeSrc":"4112:22:1","nodeType":"YulFunctionCall","src":"4112:22:1"},{"name":"dataEnd","nativeSrc":"4136:7:1","nodeType":"YulIdentifier","src":"4136:7:1"}],"functionName":{"name":"abi_decode_t_address","nativeSrc":"4091:20:1","nodeType":"YulIdentifier","src":"4091:20:1"},"nativeSrc":"4091:53:1","nodeType":"YulFunctionCall","src":"4091:53:1"},"variableNames":[{"name":"value0","nativeSrc":"4081:6:1","nodeType":"YulIdentifier","src":"4081:6:1"}]}]},{"nativeSrc":"4164:118:1","nodeType":"YulBlock","src":"4164:118:1","statements":[{"nativeSrc":"4179:16:1","nodeType":"YulVariableDeclaration","src":"4179:16:1","value":{"kind":"number","nativeSrc":"4193:2:1","nodeType":"YulLiteral","src":"4193:2:1","type":"","value":"32"},"variables":[{"name":"offset","nativeSrc":"4183:6:1","nodeType":"YulTypedName","src":"4183:6:1","type":""}]},{"nativeSrc":"4209:63:1","nodeType":"YulAssignment","src":"4209:63:1","value":{"arguments":[{"arguments":[{"name":"headStart","nativeSrc":"4244:9:1","nodeType":"YulIdentifier","src":"4244:9:1"},{"name":"offset","nativeSrc":"4255:6:1","nodeType":"YulIdentifier","src":"4255:6:1"}],"functionName":{"name":"add","nativeSrc":"4240:3:1","nodeType":"YulIdentifier","src":"4240:3:1"},"nativeSrc":"4240:22:1","nodeType":"YulFunctionCall","src":"4240:22:1"},{"name":"dataEnd","nativeSrc":"4264:7:1","nodeType":"YulIdentifier","src":"4264:7:1"}],"functionName":{"name":"abi_decode_t_address","nativeSrc":"4219:20:1","nodeType":"YulIdentifier","src":"4219:20:1"},"nativeSrc":"4219:53:1","nodeType":"YulFunctionCall","src":"4219:53:1"},"variableNames":[{"name":"value1","nativeSrc":"4209:6:1","nodeType":"YulIdentifier","src":"4209:6:1"}]}]},{"nativeSrc":"4292:118:1","nodeType":"YulBlock","src":"4292:118:1","statements":[{"nativeSrc":"4307:16:1","nodeType":"YulVariableDeclaration","src":"4307:16:1","value":{"kind":"number","nativeSrc":"4321:2:1","nodeType":"YulLiteral","src":"4321:2:1","type":"","value":"64"},"variables":[{"name":"offset","nativeSrc":"4311:6:1","nodeType":"YulTypedName","src":"4311:6:1","type":""}]},{"nativeSrc":"4337:63:1","nodeType":"YulAssignment","src":"4337:63:1","value":{"arguments":[{"arguments":[{"name":"headStart","nativeSrc":"4372:9:1","nodeType":"YulIdentifier","src":"4372:9:1"},{"name":"offset","nativeSrc":"4383:6:1","nodeType":"YulIdentifier","src":"4383:6:1"}],"functionName":{"name":"add","nativeSrc":"4368:3:1","nodeType":"YulIdentifier","src":"4368:3:1"},"nativeSrc":"4368:22:1","nodeType":"YulFunctionCall","src":"4368:22:1"},{"name":"dataEnd","nativeSrc":"4392:7:1","nodeType":"YulIdentifier","src":"4392:7:1"}],"functionName":{"name":"abi_decode_t_uint256","nativeSrc":"4347:20:1","nodeType":"YulIdentifier","src":"4347:20:1"},"nativeSrc":"4347:53:1","nodeType":"YulFunctionCall","src":"4347:53:1"},"variableNames":[{"name":"value2","nativeSrc":"4337:6:1","nodeType":"YulIdentifier","src":"4337:6:1"}]}]}]},"name":"abi_decode_tuple_t_addresst_addresst_uint256","nativeSrc":"3798:619:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nativeSrc":"3852:9:1","nodeType":"YulTypedName","src":"3852:9:1","type":""},{"name":"dataEnd","nativeSrc":"3863:7:1","nodeType":"YulTypedName","src":"3863:7:1","type":""}],"returnVariables":[{"name":"value0","nativeSrc":"3875:6:1","nodeType":"YulTypedName","src":"3875:6:1","type":""},{"name":"value1","nativeSrc":"3883:6:1","nodeType":"YulTypedName","src":"3883:6:1","type":""},{"name":"value2","nativeSrc":"3891:6:1","nodeType":"YulTypedName","src":"3891:6:1","type":""}],"src":"3798:619:1"},{"body":{"nativeSrc":"4466:43:1","nodeType":"YulBlock","src":"4466:43:1","statements":[{"nativeSrc":"4476:27:1","nodeType":"YulAssignment","src":"4476:27:1","value":{"arguments":[{"name":"value","nativeSrc":"4491:5:1","nodeType":"YulIdentifier","src":"4491:5:1"},{"kind":"number","nativeSrc":"4498:4:1","nodeType":"YulLiteral","src":"4498:4:1","type":"","value":"0xff"}],"functionName":{"name":"and","nativeSrc":"4487:3:1","nodeType":"YulIdentifier","src":"4487:3:1"},"nativeSrc":"4487:16:1","nodeType":"YulFunctionCall","src":"4487:16:1"},"variableNames":[{"name":"cleaned","nativeSrc":"4476:7:1","nodeType":"YulIdentifier","src":"4476:7:1"}]}]},"name":"cleanup_t_uint8","nativeSrc":"4423:86:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"4448:5:1","nodeType":"YulTypedName","src":"4448:5:1","type":""}],"returnVariables":[{"name":"cleaned","nativeSrc":"4458:7:1","nodeType":"YulTypedName","src":"4458:7:1","type":""}],"src":"4423:86:1"},{"body":{"nativeSrc":"4576:51:1","nodeType":"YulBlock","src":"4576:51:1","statements":[{"expression":{"arguments":[{"name":"pos","nativeSrc":"4593:3:1","nodeType":"YulIdentifier","src":"4593:3:1"},{"arguments":[{"name":"value","nativeSrc":"4614:5:1","nodeType":"YulIdentifier","src":"4614:5:1"}],"functionName":{"name":"cleanup_t_uint8","nativeSrc":"4598:15:1","nodeType":"YulIdentifier","src":"4598:15:1"},"nativeSrc":"4598:22:1","nodeType":"YulFunctionCall","src":"4598:22:1"}],"functionName":{"name":"mstore","nativeSrc":"4586:6:1","nodeType":"YulIdentifier","src":"4586:6:1"},"nativeSrc":"4586:35:1","nodeType":"YulFunctionCall","src":"4586:35:1"},"nativeSrc":"4586:35:1","nodeType":"YulExpressionStatement","src":"4586:35:1"}]},"name":"abi_encode_t_uint8_to_t_uint8_fromStack","nativeSrc":"4515:112:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nativeSrc":"4564:5:1","nodeType":"YulTypedName","src":"4564:5:1","type":""},{"name":"pos","nativeSrc":"4571:3:1","nodeType":"YulTypedName","src":"4571:3:1","type":""}],"src":"4515:112:1"},{"body":{"nativeSrc":"4727:120:1","nodeType":"YulBlock","src":"4727:120:1","statements":[{"nativeSrc":"4737:26:1","nodeType":"YulAssignment","src":"4737:26:1","value":{"arguments":[{"name":"headStart","nativeSrc":"4749:9:1","nodeType":"YulIdentifier","src":"4749:9:1"},{"kind":"number","nativeSrc":"4760:2:1","nodeType":"YulLiteral","src":"4760:2:1","type":"","value":"32"}],"functionName":{"name":"add","nativeSrc":"4745:3:1","nodeType":"YulIdentifier","src":"4745:3:1"},"nativeSrc":"4745:18:1","nodeType":"YulFunctionCall","src":"4745:18:1"},"variableNames":[{"name":"tail","nativeSrc":"4737:4:1","nodeType":"YulIdentifier","src":"4737:4:1"}]},{"expression":{"arguments":[{"name":"value0","nativeSrc":"4813:6:1","nodeType":"YulIdentifier","src":"4813:6:1"},{"arguments":[{"name":"headStart","nativeSrc":"4826:9:1","nodeType":"YulIdentifier","src":"4826:9:1"},{"kind":"number","nativeSrc":"4837:1:1","nodeType":"YulLiteral","src":"4837:1:1","type":"","value":"0"}],"functionName":{"name":"add","nativeSrc":"4822:3:1","nodeType":"YulIdentifier","src":"4822:3:1"},"nativeSrc":"4822:17:1","nodeType":"YulFunctionCall","src":"4822:17:1"}],"functionName":{"name":"abi_encode_t_uint8_to_t_uint8_fromStack","nativeSrc":"4773:39:1","nodeType":"YulIdentifier","src":"4773:39:1"},"nativeSrc":"4773:67:1","nodeType":"YulFunctionCall","src":"4773:67:1"},"nativeSrc":"4773:67:1","nodeType":"YulExpressionStatement","src":"4773:67:1"}]},"name":"abi_encode_tuple_t_uint8__to_t_uint8__fromStack_reversed","nativeSrc":"4633:214:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nativeSrc":"4699:9:1","nodeType":"YulTypedName","src":"4699:9:1","type":""},{"name":"value0","nativeSrc":"4711:6:1","nodeType":"YulTypedName","src":"4711:6:1","type":""}],"returnVariables":[{"name":"tail","nativeSrc":"4722:4:1","nodeType":"YulTypedName","src":"4722:4:1","type":""}],"src":"4633:214:1"},{"body":{"nativeSrc":"4919:263:1","nodeType":"YulBlock","src":"4919:263:1","statements":[{"body":{"nativeSrc":"4965:83:1","nodeType":"YulBlock","src":"4965:83:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b","nativeSrc":"4967:77:1","nodeType":"YulIdentifier","src":"4967:77:1"},"nativeSrc":"4967:79:1","nodeType":"YulFunctionCall","src":"4967:79:1"},"nativeSrc":"4967:79:1","nodeType":"YulExpressionStatement","src":"4967:79:1"}]},"condition":{"arguments":[{"arguments":[{"name":"dataEnd","nativeSrc":"4940:7:1","nodeType":"YulIdentifier","src":"4940:7:1"},{"name":"headStart","nativeSrc":"4949:9:1","nodeType":"YulIdentifier","src":"4949:9:1"}],"functionName":{"name":"sub","nativeSrc":"4936:3:1","nodeType":"YulIdentifier","src":"4936:3:1"},"nativeSrc":"4936:23:1","nodeType":"YulFunctionCall","src":"4936:23:1"},{"kind":"number","nativeSrc":"4961:2:1","nodeType":"YulLiteral","src":"4961:2:1","type":"","value":"32"}],"functionName":{"name":"slt","nativeSrc":"4932:3:1","nodeType":"YulIdentifier","src":"4932:3:1"},"nativeSrc":"4932:32:1","nodeType":"YulFunctionCall","src":"4932:32:1"},"nativeSrc":"4929:119:1","nodeType":"YulIf","src":"4929:119:1"},{"nativeSrc":"5058:117:1","nodeType":"YulBlock","src":"5058:117:1","statements":[{"nativeSrc":"5073:15:1","nodeType":"YulVariableDeclaration","src":"5073:15:1","value":{"kind":"number","nativeSrc":"5087:1:1","nodeType":"YulLiteral","src":"5087:1:1","type":"","value":"0"},"variables":[{"name":"offset","nativeSrc":"5077:6:1","nodeType":"YulTypedName","src":"5077:6:1","type":""}]},{"nativeSrc":"5102:63:1","nodeType":"YulAssignment","src":"5102:63:1","value":{"arguments":[{"arguments":[{"name":"headStart","nativeSrc":"5137:9:1","nodeType":"YulIdentifier","src":"5137:9:1"},{"name":"offset","nativeSrc":"5148:6:1","nodeType":"YulIdentifier","src":"5148:6:1"}],"functionName":{"name":"add","nativeSrc":"5133:3:1","nodeType":"YulIdentifier","src":"5133:3:1"},"nativeSrc":"5133:22:1","nodeType":"YulFunctionCall","src":"5133:22:1"},{"name":"dataEnd","nativeSrc":"5157:7:1","nodeType":"YulIdentifier","src":"5157:7:1"}],"functionName":{"name":"abi_decode_t_address","nativeSrc":"5112:20:1","nodeType":"YulIdentifier","src":"5112:20:1"},"nativeSrc":"5112:53:1","nodeType":"YulFunctionCall","src":"5112:53:1"},"variableNames":[{"name":"value0","nativeSrc":"5102:6:1","nodeType":"YulIdentifier","src":"5102:6:1"}]}]}]},"name":"abi_decode_tuple_t_address","nativeSrc":"4853:329:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nativeSrc":"4889:9:1","nodeType":"YulTypedName","src":"4889:9:1","type":""},{"name":"dataEnd","nativeSrc":"4900:7:1","nodeType":"YulTypedName","src":"4900:7:1","type":""}],"returnVariables":[{"name":"value0","nativeSrc":"4912:6:1","nodeType":"YulTypedName","src":"4912:6:1","type":""}],"src":"4853:329:1"},{"body":{"nativeSrc":"5271:391:1","nodeType":"YulBlock","src":"5271:391:1","statements":[{"body":{"nativeSrc":"5317:83:1","nodeType":"YulBlock","src":"5317:83:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b","nativeSrc":"5319:77:1","nodeType":"YulIdentifier","src":"5319:77:1"},"nativeSrc":"5319:79:1","nodeType":"YulFunctionCall","src":"5319:79:1"},"nativeSrc":"5319:79:1","nodeType":"YulExpressionStatement","src":"5319:79:1"}]},"condition":{"arguments":[{"arguments":[{"name":"dataEnd","nativeSrc":"5292:7:1","nodeType":"YulIdentifier","src":"5292:7:1"},{"name":"headStart","nativeSrc":"5301:9:1","nodeType":"YulIdentifier","src":"5301:9:1"}],"functionName":{"name":"sub","nativeSrc":"5288:3:1","nodeType":"YulIdentifier","src":"5288:3:1"},"nativeSrc":"5288:23:1","nodeType":"YulFunctionCall","src":"5288:23:1"},{"kind":"number","nativeSrc":"5313:2:1","nodeType":"YulLiteral","src":"5313:2:1","type":"","value":"64"}],"functionName":{"name":"slt","nativeSrc":"5284:3:1","nodeType":"YulIdentifier","src":"5284:3:1"},"nativeSrc":"5284:32:1","nodeType":"YulFunctionCall","src":"5284:32:1"},"nativeSrc":"5281:119:1","nodeType":"YulIf","src":"5281:119:1"},{"nativeSrc":"5410:117:1","nodeType":"YulBlock","src":"5410:117:1","statements":[{"nativeSrc":"5425:15:1","nodeType":"YulVariableDeclaration","src":"5425:15:1","value":{"kind":"number","nativeSrc":"5439:1:1","nodeType":"YulLiteral","src":"5439:1:1","type":"","value":"0"},"variables":[{"name":"offset","nativeSrc":"5429:6:1","nodeType":"YulTypedName","src":"5429:6:1","type":""}]},{"nativeSrc":"5454:63:1","nodeType":"YulAssignment","src":"5454:63:1","value":{"arguments":[{"arguments":[{"name":"headStart","nativeSrc":"5489:9:1","nodeType":"YulIdentifier","src":"5489:9:1"},{"name":"offset","nativeSrc":"5500:6:1","nodeType":"YulIdentifier","src":"5500:6:1"}],"functionName":{"name":"add","nativeSrc":"5485:3:1","nodeType":"YulIdentifier","src":"5485:3:1"},"nativeSrc":"5485:22:1","nodeType":"YulFunctionCall","src":"5485:22:1"},{"name":"dataEnd","nativeSrc":"5509:7:1","nodeType":"YulIdentifier","src":"5509:7:1"}],"functionName":{"name":"abi_decode_t_address","nativeSrc":"5464:20:1","nodeType":"YulIdentifier","src":"5464:20:1"},"nativeSrc":"5464:53:1","nodeType":"YulFunctionCall","src":"5464:53:1"},"variableNames":[{"name":"value0","nativeSrc":"5454:6:1","nodeType":"YulIdentifier","src":"5454:6:1"}]}]},{"nativeSrc":"5537:118:1","nodeType":"YulBlock","src":"5537:118:1","statements":[{"nativeSrc":"5552:16:1","nodeType":"YulVariableDeclaration","src":"5552:16:1","value":{"kind":"number","nativeSrc":"5566:2:1","nodeType":"YulLiteral","src":"5566:2:1","type":"","value":"32"},"variables":[{"name":"offset","nativeSrc":"5556:6:1","nodeType":"YulTypedName","src":"5556:6:1","type":""}]},{"nativeSrc":"5582:63:1","nodeType":"YulAssignment","src":"5582:63:1","value":{"arguments":[{"arguments":[{"name":"headStart","nativeSrc":"5617:9:1","nodeType":"YulIdentifier","src":"5617:9:1"},{"name":"offset","nativeSrc":"5628:6:1","nodeType":"YulIdentifier","src":"5628:6:1"}],"functionName":{"name":"add","nativeSrc":"5613:3:1","nodeType":"YulIdentifier","src":"5613:3:1"},"nativeSrc":"5613:22:1","nodeType":"YulFunctionCall","src":"5613:22:1"},{"name":"dataEnd","nativeSrc":"5637:7:1","nodeType":"YulIdentifier","src":"5637:7:1"}],"functionName":{"name":"abi_decode_t_address","nativeSrc":"5592:20:1","nodeType":"YulIdentifier","src":"5592:20:1"},"nativeSrc":"5592:53:1","nodeType":"YulFunctionCall","src":"5592:53:1"},"variableNames":[{"name":"value1","nativeSrc":"5582:6:1","nodeType":"YulIdentifier","src":"5582:6:1"}]}]}]},"name":"abi_decode_tuple_t_addresst_address","nativeSrc":"5188:474:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nativeSrc":"5233:9:1","nodeType":"YulTypedName","src":"5233:9:1","type":""},{"name":"dataEnd","nativeSrc":"5244:7:1","nodeType":"YulTypedName","src":"5244:7:1","type":""}],"returnVariables":[{"name":"value0","nativeSrc":"5256:6:1","nodeType":"YulTypedName","src":"5256:6:1","type":""},{"name":"value1","nativeSrc":"5264:6:1","nodeType":"YulTypedName","src":"5264:6:1","type":""}],"src":"5188:474:1"},{"body":{"nativeSrc":"5696:152:1","nodeType":"YulBlock","src":"5696:152:1","statements":[{"expression":{"arguments":[{"kind":"number","nativeSrc":"5713:1:1","nodeType":"YulLiteral","src":"5713:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"5716:77:1","nodeType":"YulLiteral","src":"5716:77:1","type":"","value":"35408467139433450592217433187231851964531694900788300625387963629091585785856"}],"functionName":{"name":"mstore","nativeSrc":"5706:6:1","nodeType":"YulIdentifier","src":"5706:6:1"},"nativeSrc":"5706:88:1","nodeType":"YulFunctionCall","src":"5706:88:1"},"nativeSrc":"5706:88:1","nodeType":"YulExpressionStatement","src":"5706:88:1"},{"expression":{"arguments":[{"kind":"number","nativeSrc":"5810:1:1","nodeType":"YulLiteral","src":"5810:1:1","type":"","value":"4"},{"kind":"number","nativeSrc":"5813:4:1","nodeType":"YulLiteral","src":"5813:4:1","type":"","value":"0x22"}],"functionName":{"name":"mstore","nativeSrc":"5803:6:1","nodeType":"YulIdentifier","src":"5803:6:1"},"nativeSrc":"5803:15:1","nodeType":"YulFunctionCall","src":"5803:15:1"},"nativeSrc":"5803:15:1","nodeType":"YulExpressionStatement","src":"5803:15:1"},{"expression":{"arguments":[{"kind":"number","nativeSrc":"5834:1:1","nodeType":"YulLiteral","src":"5834:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"5837:4:1","nodeType":"YulLiteral","src":"5837:4:1","type":"","value":"0x24"}],"functionName":{"name":"revert","nativeSrc":"5827:6:1","nodeType":"YulIdentifier","src":"5827:6:1"},"nativeSrc":"5827:15:1","nodeType":"YulFunctionCall","src":"5827:15:1"},"nativeSrc":"5827:15:1","nodeType":"YulExpressionStatement","src":"5827:15:1"}]},"name":"panic_error_0x22","nativeSrc":"5668:180:1","nodeType":"YulFunctionDefinition","src":"5668:180:1"},{"body":{"nativeSrc":"5905:269:1","nodeType":"YulBlock","src":"5905:269:1","statements":[{"nativeSrc":"5915:22:1","nodeType":"YulAssignment","src":"5915:22:1","value":{"arguments":[{"name":"data","nativeSrc":"5929:4:1","nodeType":"YulIdentifier","src":"5929:4:1"},{"kind":"number","nativeSrc":"5935:1:1","nodeType":"YulLiteral","src":"5935:1:1","type":"","value":"2"}],"functionName":{"name":"div","nativeSrc":"5925:3:1","nodeType":"YulIdentifier","src":"5925:3:1"},"nativeSrc":"5925:12:1","nodeType":"YulFunctionCall","src":"5925:12:1"},"variableNames":[{"name":"length","nativeSrc":"5915:6:1","nodeType":"YulIdentifier","src":"5915:6:1"}]},{"nativeSrc":"5946:38:1","nodeType":"YulVariableDeclaration","src":"5946:38:1","value":{"arguments":[{"name":"data","nativeSrc":"5976:4:1","nodeType":"YulIdentifier","src":"5976:4:1"},{"kind":"number","nativeSrc":"5982:1:1","nodeType":"YulLiteral","src":"5982:1:1","type":"","value":"1"}],"functionName":{"name":"and","nativeSrc":"5972:3:1","nodeType":"YulIdentifier","src":"5972:3:1"},"nativeSrc":"5972:12:1","nodeType":"YulFunctionCall","src":"5972:12:1"},"variables":[{"name":"outOfPlaceEncoding","nativeSrc":"5950:18:1","nodeType":"YulTypedName","src":"5950:18:1","type":""}]},{"body":{"nativeSrc":"6023:51:1","nodeType":"YulBlock","src":"6023:51:1","statements":[{"nativeSrc":"6037:27:1","nodeType":"YulAssignment","src":"6037:27:1","value":{"arguments":[{"name":"length","nativeSrc":"6051:6:1","nodeType":"YulIdentifier","src":"6051:6:1"},{"kind":"number","nativeSrc":"6059:4:1","nodeType":"YulLiteral","src":"6059:4:1","type":"","value":"0x7f"}],"functionName":{"name":"and","nativeSrc":"6047:3:1","nodeType":"YulIdentifier","src":"6047:3:1"},"nativeSrc":"6047:17:1","nodeType":"YulFunctionCall","src":"6047:17:1"},"variableNames":[{"name":"length","nativeSrc":"6037:6:1","nodeType":"YulIdentifier","src":"6037:6:1"}]}]},"condition":{"arguments":[{"name":"outOfPlaceEncoding","nativeSrc":"6003:18:1","nodeType":"YulIdentifier","src":"6003:18:1"}],"functionName":{"name":"iszero","nativeSrc":"5996:6:1","nodeType":"YulIdentifier","src":"5996:6:1"},"nativeSrc":"5996:26:1","nodeType":"YulFunctionCall","src":"5996:26:1"},"nativeSrc":"5993:81:1","nodeType":"YulIf","src":"5993:81:1"},{"body":{"nativeSrc":"6126:42:1","nodeType":"YulBlock","src":"6126:42:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x22","nativeSrc":"6140:16:1","nodeType":"YulIdentifier","src":"6140:16:1"},"nativeSrc":"6140:18:1","nodeType":"YulFunctionCall","src":"6140:18:1"},"nativeSrc":"6140:18:1","nodeType":"YulExpressionStatement","src":"6140:18:1"}]},"condition":{"arguments":[{"name":"outOfPlaceEncoding","nativeSrc":"6090:18:1","nodeType":"YulIdentifier","src":"6090:18:1"},{"arguments":[{"name":"length","nativeSrc":"6113:6:1","nodeType":"YulIdentifier","src":"6113:6:1"},{"kind":"number","nativeSrc":"6121:2:1","nodeType":"YulLiteral","src":"6121:2:1","type":"","value":"32"}],"functionName":{"name":"lt","nativeSrc":"6110:2:1","nodeType":"YulIdentifier","src":"6110:2:1"},"nativeSrc":"6110:14:1","nodeType":"YulFunctionCall","src":"6110:14:1"}],"functionName":{"name":"eq","nativeSrc":"6087:2:1","nodeType":"YulIdentifier","src":"6087:2:1"},"nativeSrc":"6087:38:1","nodeType":"YulFunctionCall","src":"6087:38:1"},"nativeSrc":"6084:84:1","nodeType":"YulIf","src":"6084:84:1"}]},"name":"extract_byte_array_length","nativeSrc":"5854:320:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"data","nativeSrc":"5889:4:1","nodeType":"YulTypedName","src":"5889:4:1","type":""}],"returnVariables":[{"name":"length","nativeSrc":"5898:6:1","nodeType":"YulTypedName","src":"5898:6:1","type":""}],"src":"5854:320:1"},{"body":{"nativeSrc":"6286:64:1","nodeType":"YulBlock","src":"6286:64:1","statements":[{"expression":{"arguments":[{"arguments":[{"name":"memPtr","nativeSrc":"6308:6:1","nodeType":"YulIdentifier","src":"6308:6:1"},{"kind":"number","nativeSrc":"6316:1:1","nodeType":"YulLiteral","src":"6316:1:1","type":"","value":"0"}],"functionName":{"name":"add","nativeSrc":"6304:3:1","nodeType":"YulIdentifier","src":"6304:3:1"},"nativeSrc":"6304:14:1","nodeType":"YulFunctionCall","src":"6304:14:1"},{"hexValue":"696e73756666696369656e742062616c616e6365","kind":"string","nativeSrc":"6320:22:1","nodeType":"YulLiteral","src":"6320:22:1","type":"","value":"insufficient balance"}],"functionName":{"name":"mstore","nativeSrc":"6297:6:1","nodeType":"YulIdentifier","src":"6297:6:1"},"nativeSrc":"6297:46:1","nodeType":"YulFunctionCall","src":"6297:46:1"},"nativeSrc":"6297:46:1","nodeType":"YulExpressionStatement","src":"6297:46:1"}]},"name":"store_literal_in_memory_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee","nativeSrc":"6180:170:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"memPtr","nativeSrc":"6278:6:1","nodeType":"YulTypedName","src":"6278:6:1","type":""}],"src":"6180:170:1"},{"body":{"nativeSrc":"6502:220:1","nodeType":"YulBlock","src":"6502:220:1","statements":[{"nativeSrc":"6512:74:1","nodeType":"YulAssignment","src":"6512:74:1","value":{"arguments":[{"name":"pos","nativeSrc":"6578:3:1","nodeType":"YulIdentifier","src":"6578:3:1"},{"kind":"number","nativeSrc":"6583:2:1","nodeType":"YulLiteral","src":"6583:2:1","type":"","value":"20"}],"functionName":{"name":"array_storeLengthForEncoding_t_string_memory_ptr_fromStack","nativeSrc":"6519:58:1","nodeType":"YulIdentifier","src":"6519:58:1"},"nativeSrc":"6519:67:1","nodeType":"YulFunctionCall","src":"6519:67:1"},"variableNames":[{"name":"pos","nativeSrc":"6512:3:1","nodeType":"YulIdentifier","src":"6512:3:1"}]},{"expression":{"arguments":[{"name":"pos","nativeSrc":"6684:3:1","nodeType":"YulIdentifier","src":"6684:3:1"}],"functionName":{"name":"store_literal_in_memory_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee","nativeSrc":"6595:88:1","nodeType":"YulIdentifier","src":"6595:88:1"},"nativeSrc":"6595:93:1","nodeType":"YulFunctionCall","src":"6595:93:1"},"nativeSrc":"6595:93:1","nodeType":"YulExpressionStatement","src":"6595:93:1"},{"nativeSrc":"6697:19:1","nodeType":"YulAssignment","src":"6697:19:1","value":{"arguments":[{"name":"pos","nativeSrc":"6708:3:1","nodeType":"YulIdentifier","src":"6708:3:1"},{"kind":"number","nativeSrc":"6713:2:1","nodeType":"YulLiteral","src":"6713:2:1","type":"","value":"32"}],"functionName":{"name":"add","nativeSrc":"6704:3:1","nodeType":"YulIdentifier","src":"6704:3:1"},"nativeSrc":"6704:12:1","nodeType":"YulFunctionCall","src":"6704:12:1"},"variableNames":[{"name":"end","nativeSrc":"6697:3:1","nodeType":"YulIdentifier","src":"6697:3:1"}]}]},"name":"abi_encode_t_stringliteral_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee_to_t_string_memory_ptr_fromStack","nativeSrc":"6356:366:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"pos","nativeSrc":"6490:3:1","nodeType":"YulTypedName","src":"6490:3:1","type":""}],"returnVariables":[{"name":"end","nativeSrc":"6498:3:1","nodeType":"YulTypedName","src":"6498:3:1","type":""}],"src":"6356:366:1"},{"body":{"nativeSrc":"6899:248:1","nodeType":"YulBlock","src":"6899:248:1","statements":[{"nativeSrc":"6909:26:1","nodeType":"YulAssignment","src":"6909:26:1","value":{"arguments":[{"name":"headStart","nativeSrc":"6921:9:1","nodeType":"YulIdentifier","src":"6921:9:1"},{"kind":"number","nativeSrc":"6932:2:1","nodeType":"YulLiteral","src":"6932:2:1","type":"","value":"32"}],"functionName":{"name":"add","nativeSrc":"6917:3:1","nodeType":"YulIdentifier","src":"6917:3:1"},"nativeSrc":"6917:18:1","nodeType":"YulFunctionCall","src":"6917:18:1"},"variableNames":[{"name":"tail","nativeSrc":"6909:4:1","nodeType":"YulIdentifier","src":"6909:4:1"}]},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nativeSrc":"6956:9:1","nodeType":"YulIdentifier","src":"6956:9:1"},{"kind":"number","nativeSrc":"6967:1:1","nodeType":"YulLiteral","src":"6967:1:1","type":"","value":"0"}],"functionName":{"name":"add","nativeSrc":"6952:3:1","nodeType":"YulIdentifier","src":"6952:3:1"},"nativeSrc":"6952:17:1","nodeType":"YulFunctionCall","src":"6952:17:1"},{"arguments":[{"name":"tail","nativeSrc":"6975:4:1","nodeType":"YulIdentifier","src":"6975:4:1"},{"name":"headStart","nativeSrc":"6981:9:1","nodeType":"YulIdentifier","src":"6981:9:1"}],"functionName":{"name":"sub","nativeSrc":"6971:3:1","nodeType":"YulIdentifier","src":"6971:3:1"},"nativeSrc":"6971:20:1","nodeType":"YulFunctionCall","src":"6971:20:1"}],"functionName":{"name":"mstore","nativeSrc":"6945:6:1","nodeType":"YulIdentifier","src":"6945:6:1"},"nativeSrc":"6945:47:1","nodeType":"YulFunctionCall","src":"6945:47:1"},"nativeSrc":"6945:47:1","nodeType":"YulExpressionStatement","src":"6945:47:1"},{"nativeSrc":"7001:139:1","nodeType":"YulAssignment","src":"7001:139:1","value":{"arguments":[{"name":"tail","nativeSrc":"7135:4:1","nodeType":"YulIdentifier","src":"7135:4:1"}],"functionName":{"name":"abi_encode_t_stringliteral_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee_to_t_string_memory_ptr_fromStack","nativeSrc":"7009:124:1","nodeType":"YulIdentifier","src":"7009:124:1"},"nativeSrc":"7009:131:1","nodeType":"YulFunctionCall","src":"7009:131:1"},"variableNames":[{"name":"tail","nativeSrc":"7001:4:1","nodeType":"YulIdentifier","src":"7001:4:1"}]}]},"name":"abi_encode_tuple_t_stringliteral_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee__to_t_string_memory_ptr__fromStack_reversed","nativeSrc":"6728:419:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nativeSrc":"6879:9:1","nodeType":"YulTypedName","src":"6879:9:1","type":""}],"returnVariables":[{"name":"tail","nativeSrc":"6894:4:1","nodeType":"YulTypedName","src":"6894:4:1","type":""}],"src":"6728:419:1"},{"body":{"nativeSrc":"7259:61:1","nodeType":"YulBlock","src":"7259:61:1","statements":[{"expression":{"arguments":[{"arguments":[{"name":"memPtr","nativeSrc":"7281:6:1","nodeType":"YulIdentifier","src":"7281:6:1"},{"kind":"number","nativeSrc":"7289:1:1","nodeType":"YulLiteral","src":"7289:1:1","type":"","value":"0"}],"functionName":{"name":"add","nativeSrc":"7277:3:1","nodeType":"YulIdentifier","src":"7277:3:1"},"nativeSrc":"7277:14:1","nodeType":"YulFunctionCall","src":"7277:14:1"},{"hexValue":"6578636565647320616c6c6f77616e6365","kind":"string","nativeSrc":"7293:19:1","nodeType":"YulLiteral","src":"7293:19:1","type":"","value":"exceeds allowance"}],"functionName":{"name":"mstore","nativeSrc":"7270:6:1","nodeType":"YulIdentifier","src":"7270:6:1"},"nativeSrc":"7270:43:1","nodeType":"YulFunctionCall","src":"7270:43:1"},"nativeSrc":"7270:43:1","nodeType":"YulExpressionStatement","src":"7270:43:1"}]},"name":"store_literal_in_memory_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618","nativeSrc":"7153:167:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"memPtr","nativeSrc":"7251:6:1","nodeType":"YulTypedName","src":"7251:6:1","type":""}],"src":"7153:167:1"},{"body":{"nativeSrc":"7472:220:1","nodeType":"YulBlock","src":"7472:220:1","statements":[{"nativeSrc":"7482:74:1","nodeType":"YulAssignment","src":"7482:74:1","value":{"arguments":[{"name":"pos","nativeSrc":"7548:3:1","nodeType":"YulIdentifier","src":"7548:3:1"},{"kind":"number","nativeSrc":"7553:2:1","nodeType":"YulLiteral","src":"7553:2:1","type":"","value":"17"}],"functionName":{"name":"array_storeLengthForEncoding_t_string_memory_ptr_fromStack","nativeSrc":"7489:58:1","nodeType":"YulIdentifier","src":"7489:58:1"},"nativeSrc":"7489:67:1","nodeType":"YulFunctionCall","src":"7489:67:1"},"variableNames":[{"name":"pos","nativeSrc":"7482:3:1","nodeType":"YulIdentifier","src":"7482:3:1"}]},{"expression":{"arguments":[{"name":"pos","nativeSrc":"7654:3:1","nodeType":"YulIdentifier","src":"7654:3:1"}],"functionName":{"name":"store_literal_in_memory_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618","nativeSrc":"7565:88:1","nodeType":"YulIdentifier","src":"7565:88:1"},"nativeSrc":"7565:93:1","nodeType":"YulFunctionCall","src":"7565:93:1"},"nativeSrc":"7565:93:1","nodeType":"YulExpressionStatement","src":"7565:93:1"},{"nativeSrc":"7667:19:1","nodeType":"YulAssignment","src":"7667:19:1","value":{"arguments":[{"name":"pos","nativeSrc":"7678:3:1","nodeType":"YulIdentifier","src":"7678:3:1"},{"kind":"number","nativeSrc":"7683:2:1","nodeType":"YulLiteral","src":"7683:2:1","type":"","value":"32"}],"functionName":{"name":"add","nativeSrc":"7674:3:1","nodeType":"YulIdentifier","src":"7674:3:1"},"nativeSrc":"7674:12:1","nodeType":"YulFunctionCall","src":"7674:12:1"},"variableNames":[{"name":"end","nativeSrc":"7667:3:1","nodeType":"YulIdentifier","src":"7667:3:1"}]}]},"name":"abi_encode_t_stringliteral_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618_to_t_string_memory_ptr_fromStack","nativeSrc":"7326:366:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"pos","nativeSrc":"7460:3:1","nodeType":"YulTypedName","src":"7460:3:1","type":""}],"returnVariables":[{"name":"end","nativeSrc":"7468:3:1","nodeType":"YulTypedName","src":"7468:3:1","type":""}],"src":"7326:366:1"},{"body":{"nativeSrc":"7869:248:1","nodeType":"YulBlock","src":"7869:248:1","statements":[{"nativeSrc":"7879:26:1","nodeType":"YulAssignment","src":"7879:26:1","value":{"arguments":[{"name":"headStart","nativeSrc":"7891:9:1","nodeType":"YulIdentifier","src":"7891:9:1"},{"kind":"number","nativeSrc":"7902:2:1","nodeType":"YulLiteral","src":"7902:2:1","type":"","value":"32"}],"functionName":{"name":"add","nativeSrc":"7887:3:1","nodeType":"YulIdentifier","src":"7887:3:1"},"nativeSrc":"7887:18:1","nodeType":"YulFunctionCall","src":"7887:18:1"},"variableNames":[{"name":"tail","nativeSrc":"7879:4:1","nodeType":"YulIdentifier","src":"7879:4:1"}]},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nativeSrc":"7926:9:1","nodeType":"YulIdentifier","src":"7926:9:1"},{"kind":"number","nativeSrc":"7937:1:1","nodeType":"YulLiteral","src":"7937:1:1","type":"","value":"0"}],"functionName":{"name":"add","nativeSrc":"7922:3:1","nodeType":"YulIdentifier","src":"7922:3:1"},"nativeSrc":"7922:17:1","nodeType":"YulFunctionCall","src":"7922:17:1"},{"arguments":[{"name":"tail","nativeSrc":"7945:4:1","nodeType":"YulIdentifier","src":"7945:4:1"},{"name":"headStart","nativeSrc":"7951:9:1","nodeType":"YulIdentifier","src":"7951:9:1"}],"functionName":{"name":"sub","nativeSrc":"7941:3:1","nodeType":"YulIdentifier","src":"7941:3:1"},"nativeSrc":"7941:20:1","nodeType":"YulFunctionCall","src":"7941:20:1"}],"functionName":{"name":"mstore","nativeSrc":"7915:6:1","nodeType":"YulIdentifier","src":"7915:6:1"},"nativeSrc":"7915:47:1","nodeType":"YulFunctionCall","src":"7915:47:1"},"nativeSrc":"7915:47:1","nodeType":"YulExpressionStatement","src":"7915:47:1"},{"nativeSrc":"7971:139:1","nodeType":"YulAssignment","src":"7971:139:1","value":{"arguments":[{"name":"tail","nativeSrc":"8105:4:1","nodeType":"YulIdentifier","src":"8105:4:1"}],"functionName":{"name":"abi_encode_t_stringliteral_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618_to_t_string_memory_ptr_fromStack","nativeSrc":"7979:124:1","nodeType":"YulIdentifier","src":"7979:124:1"},"nativeSrc":"7979:131:1","nodeType":"YulFunctionCall","src":"7979:131:1"},"variableNames":[{"name":"tail","nativeSrc":"7971:4:1","nodeType":"YulIdentifier","src":"7971:4:1"}]}]},"name":"abi_encode_tuple_t_stringliteral_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618__to_t_string_memory_ptr__fromStack_reversed","nativeSrc":"7698:419:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nativeSrc":"7849:9:1","nodeType":"YulTypedName","src":"7849:9:1","type":""}],"returnVariables":[{"name":"tail","nativeSrc":"7864:4:1","nodeType":"YulTypedName","src":"7864:4:1","type":""}],"src":"7698:419:1"},{"body":{"nativeSrc":"8151:152:1","nodeType":"YulBlock","src":"8151:152:1","statements":[{"expression":{"arguments":[{"kind":"number","nativeSrc":"8168:1:1","nodeType":"YulLiteral","src":"8168:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"8171:77:1","nodeType":"YulLiteral","src":"8171:77:1","type":"","value":"35408467139433450592217433187231851964531694900788300625387963629091585785856"}],"functionName":{"name":"mstore","nativeSrc":"8161:6:1","nodeType":"YulIdentifier","src":"8161:6:1"},"nativeSrc":"8161:88:1","nodeType":"YulFunctionCall","src":"8161:88:1"},"nativeSrc":"8161:88:1","nodeType":"YulExpressionStatement","src":"8161:88:1"},{"expression":{"arguments":[{"kind":"number","nativeSrc":"8265:1:1","nodeType":"YulLiteral","src":"8265:1:1","type":"","value":"4"},{"kind":"number","nativeSrc":"8268:4:1","nodeType":"YulLiteral","src":"8268:4:1","type":"","value":"0x11"}],"functionName":{"name":"mstore","nativeSrc":"8258:6:1","nodeType":"YulIdentifier","src":"8258:6:1"},"nativeSrc":"8258:15:1","nodeType":"YulFunctionCall","src":"8258:15:1"},"nativeSrc":"8258:15:1","nodeType":"YulExpressionStatement","src":"8258:15:1"},{"expression":{"arguments":[{"kind":"number","nativeSrc":"8289:1:1","nodeType":"YulLiteral","src":"8289:1:1","type":"","value":"0"},{"kind":"number","nativeSrc":"8292:4:1","nodeType":"YulLiteral","src":"8292:4:1","type":"","value":"0x24"}],"functionName":{"name":"revert","nativeSrc":"8282:6:1","nodeType":"YulIdentifier","src":"8282:6:1"},"nativeSrc":"8282:15:1","nodeType":"YulFunctionCall","src":"8282:15:1"},"nativeSrc":"8282:15:1","nodeType":"YulExpressionStatement","src":"8282:15:1"}]},"name":"panic_error_0x11","nativeSrc":"8123:180:1","nodeType":"YulFunctionDefinition","src":"8123:180:1"},{"body":{"nativeSrc":"8354:149:1","nodeType":"YulBlock","src":"8354:149:1","statements":[{"nativeSrc":"8364:25:1","nodeType":"YulAssignment","src":"8364:25:1","value":{"arguments":[{"name":"x","nativeSrc":"8387:1:1","nodeType":"YulIdentifier","src":"8387:1:1"}],"functionName":{"name":"cleanup_t_uint256","nativeSrc":"8369:17:1","nodeType":"YulIdentifier","src":"8369:17:1"},"nativeSrc":"8369:20:1","nodeType":"YulFunctionCall","src":"8369:20:1"},"variableNames":[{"name":"x","nativeSrc":"8364:1:1","nodeType":"YulIdentifier","src":"8364:1:1"}]},{"nativeSrc":"8398:25:1","nodeType":"YulAssignment","src":"8398:25:1","value":{"arguments":[{"name":"y","nativeSrc":"8421:1:1","nodeType":"YulIdentifier","src":"8421:1:1"}],"functionName":{"name":"cleanup_t_uint256","nativeSrc":"8403:17:1","nodeType":"YulIdentifier","src":"8403:17:1"},"nativeSrc":"8403:20:1","nodeType":"YulFunctionCall","src":"8403:20:1"},"variableNames":[{"name":"y","nativeSrc":"8398:1:1","nodeType":"YulIdentifier","src":"8398:1:1"}]},{"nativeSrc":"8432:17:1","nodeType":"YulAssignment","src":"8432:17:1","value":{"arguments":[{"name":"x","nativeSrc":"8444:1:1","nodeType":"YulIdentifier","src":"8444:1:1"},{"name":"y","nativeSrc":"8447:1:1","nodeType":"YulIdentifier","src":"8447:1:1"}],"functionName":{"name":"sub","nativeSrc":"8440:3:1","nodeType":"YulIdentifier","src":"8440:3:1"},"nativeSrc":"8440:9:1","nodeType":"YulFunctionCall","src":"8440:9:1"},"variableNames":[{"name":"diff","nativeSrc":"8432:4:1","nodeType":"YulIdentifier","src":"8432:4:1"}]},{"body":{"nativeSrc":"8474:22:1","nodeType":"YulBlock","src":"8474:22:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x11","nativeSrc":"8476:16:1","nodeType":"YulIdentifier","src":"8476:16:1"},"nativeSrc":"8476:18:1","nodeType":"YulFunctionCall","src":"8476:18:1"},"nativeSrc":"8476:18:1","nodeType":"YulExpressionStatement","src":"8476:18:1"}]},"condition":{"arguments":[{"name":"diff","nativeSrc":"8465:4:1","nodeType":"YulIdentifier","src":"8465:4:1"},{"name":"x","nativeSrc":"8471:1:1","nodeType":"YulIdentifier","src":"8471:1:1"}],"functionName":{"name":"gt","nativeSrc":"8462:2:1","nodeType":"YulIdentifier","src":"8462:2:1"},"nativeSrc":"8462:11:1","nodeType":"YulFunctionCall","src":"8462:11:1"},"nativeSrc":"8459:37:1","nodeType":"YulIf","src":"8459:37:1"}]},"name":"checked_sub_t_uint256","nativeSrc":"8309:194:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"x","nativeSrc":"8340:1:1","nodeType":"YulTypedName","src":"8340:1:1","type":""},{"name":"y","nativeSrc":"8343:1:1","nodeType":"YulTypedName","src":"8343:1:1","type":""}],"returnVariables":[{"name":"diff","nativeSrc":"8349:4:1","nodeType":"YulTypedName","src":"8349:4:1","type":""}],"src":"8309:194:1"},{"body":{"nativeSrc":"8553:147:1","nodeType":"YulBlock","src":"8553:147:1","statements":[{"nativeSrc":"8563:25:1","nodeType":"YulAssignment","src":"8563:25:1","value":{"arguments":[{"name":"x","nativeSrc":"8586:1:1","nodeType":"YulIdentifier","src":"8586:1:1"}],"functionName":{"name":"cleanup_t_uint256","nativeSrc":"8568:17:1","nodeType":"YulIdentifier","src":"8568:17:1"},"nativeSrc":"8568:20:1","nodeType":"YulFunctionCall","src":"8568:20:1"},"variableNames":[{"name":"x","nativeSrc":"8563:1:1","nodeType":"YulIdentifier","src":"8563:1:1"}]},{"nativeSrc":"8597:25:1","nodeType":"YulAssignment","src":"8597:25:1","value":{"arguments":[{"name":"y","nativeSrc":"8620:1:1","nodeType":"YulIdentifier","src":"8620:1:1"}],"functionName":{"name":"cleanup_t_uint256","nativeSrc":"8602:17:1","nodeType":"YulIdentifier","src":"8602:17:1"},"nativeSrc":"8602:20:1","nodeType":"YulFunctionCall","src":"8602:20:1"},"variableNames":[{"name":"y","nativeSrc":"8597:1:1","nodeType":"YulIdentifier","src":"8597:1:1"}]},{"nativeSrc":"8631:16:1","nodeType":"YulAssignment","src":"8631:16:1","value":{"arguments":[{"name":"x","nativeSrc":"8642:1:1","nodeType":"YulIdentifier","src":"8642:1:1"},{"name":"y","nativeSrc":"8645:1:1","nodeType":"YulIdentifier","src":"8645:1:1"}],"functionName":{"name":"add","nativeSrc":"8638:3:1","nodeType":"YulIdentifier","src":"8638:3:1"},"nativeSrc":"8638:9:1","nodeType":"YulFunctionCall","src":"8638:9:1"},"variableNames":[{"name":"sum","nativeSrc":"8631:3:1","nodeType":"YulIdentifier","src":"8631:3:1"}]},{"body":{"nativeSrc":"8671:22:1","nodeType":"YulBlock","src":"8671:22:1","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x11","nativeSrc":"8673:16:1","nodeType":"YulIdentifier","src":"8673:16:1"},"nativeSrc":"8673:18:1","nodeType":"YulFunctionCall","src":"8673:18:1"},"nativeSrc":"8673:18:1","nodeType":"YulExpressionStatement","src":"8673:18:1"}]},"condition":{"arguments":[{"name":"x","nativeSrc":"8663:1:1","nodeType":"YulIdentifier","src":"8663:1:1"},{"name":"sum","nativeSrc":"8666:3:1","nodeType":"YulIdentifier","src":"8666:3:1"}],"functionName":{"name":"gt","nativeSrc":"8660:2:1","nodeType":"YulIdentifier","src":"8660:2:1"},"nativeSrc":"8660:10:1","nodeType":"YulFunctionCall","src":"8660:10:1"},"nativeSrc":"8657:36:1","nodeType":"YulIf","src":"8657:36:1"}]},"name":"checked_add_t_uint256","nativeSrc":"8509:191:1","nodeType":"YulFunctionDefinition","parameters":[{"name":"x","nativeSrc":"8540:1:1","nodeType":"YulTypedName","src":"8540:1:1","type":""},{"name":"y","nativeSrc":"8543:1:1","nodeType":"YulTypedName","src":"8543:1:1","type":""}],"returnVariables":[{"name":"sum","nativeSrc":"8549:3:1","nodeType":"YulTypedName","src":"8549:3:1","type":""}],"src":"8509:191:1"}]},"contents":"{\n\n    function array_length_t_string_memory_ptr(value) -> length {\n\n        length := mload(value)\n\n    }\n\n    function array_storeLengthForEncoding_t_string_memory_ptr_fromStack(pos, length) -> updated_pos {\n        mstore(pos, length)\n        updated_pos := add(pos, 0x20)\n    }\n\n    function copy_memory_to_memory_with_cleanup(src, dst, length) {\n        let i := 0\n        for { } lt(i, length) { i := add(i, 32) }\n        {\n            mstore(add(dst, i), mload(add(src, i)))\n        }\n        mstore(add(dst, length), 0)\n    }\n\n    function round_up_to_mul_of_32(value) -> result {\n        result := and(add(value, 31), not(31))\n    }\n\n    function abi_encode_t_string_memory_ptr_to_t_string_memory_ptr_fromStack(value, pos) -> end {\n        let length := array_length_t_string_memory_ptr(value)\n        pos := array_storeLengthForEncoding_t_string_memory_ptr_fromStack(pos, length)\n        copy_memory_to_memory_with_cleanup(add(value, 0x20), pos, length)\n        end := add(pos, round_up_to_mul_of_32(length))\n    }\n\n    function abi_encode_tuple_t_string_memory_ptr__to_t_string_memory_ptr__fromStack_reversed(headStart , value0) -> tail {\n        tail := add(headStart, 32)\n\n        mstore(add(headStart, 0), sub(tail, headStart))\n        tail := abi_encode_t_string_memory_ptr_to_t_string_memory_ptr_fromStack(value0,  tail)\n\n    }\n\n    function allocate_unbounded() -> memPtr {\n        memPtr := mload(64)\n    }\n\n    function revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() {\n        revert(0, 0)\n    }\n\n    function revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db() {\n        revert(0, 0)\n    }\n\n    function cleanup_t_uint160(value) -> cleaned {\n        cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)\n    }\n\n    function cleanup_t_address(value) -> cleaned {\n        cleaned := cleanup_t_uint160(value)\n    }\n\n    function validator_revert_t_address(value) {\n        if iszero(eq(value, cleanup_t_address(value))) { revert(0, 0) }\n    }\n\n    function abi_decode_t_address(offset, end) -> value {\n        value := calldataload(offset)\n        validator_revert_t_address(value)\n    }\n\n    function cleanup_t_uint256(value) -> cleaned {\n        cleaned := value\n    }\n\n    function validator_revert_t_uint256(value) {\n        if iszero(eq(value, cleanup_t_uint256(value))) { revert(0, 0) }\n    }\n\n    function abi_decode_t_uint256(offset, end) -> value {\n        value := calldataload(offset)\n        validator_revert_t_uint256(value)\n    }\n\n    function abi_decode_tuple_t_addresst_uint256(headStart, dataEnd) -> value0, value1 {\n        if slt(sub(dataEnd, headStart), 64) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }\n\n        {\n\n            let offset := 0\n\n            value0 := abi_decode_t_address(add(headStart, offset), dataEnd)\n        }\n\n        {\n\n            let offset := 32\n\n            value1 := abi_decode_t_uint256(add(headStart, offset), dataEnd)\n        }\n\n    }\n\n    function cleanup_t_bool(value) -> cleaned {\n        cleaned := iszero(iszero(value))\n    }\n\n    function abi_encode_t_bool_to_t_bool_fromStack(value, pos) {\n        mstore(pos, cleanup_t_bool(value))\n    }\n\n    function abi_encode_tuple_t_bool__to_t_bool__fromStack_reversed(headStart , value0) -> tail {\n        tail := add(headStart, 32)\n\n        abi_encode_t_bool_to_t_bool_fromStack(value0,  add(headStart, 0))\n\n    }\n\n    function abi_encode_t_uint256_to_t_uint256_fromStack(value, pos) {\n        mstore(pos, cleanup_t_uint256(value))\n    }\n\n    function abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed(headStart , value0) -> tail {\n        tail := add(headStart, 32)\n\n        abi_encode_t_uint256_to_t_uint256_fromStack(value0,  add(headStart, 0))\n\n    }\n\n    function abi_decode_tuple_t_addresst_addresst_uint256(headStart, dataEnd) -> value0, value1, value2 {\n        if slt(sub(dataEnd, headStart), 96) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }\n\n        {\n\n            let offset := 0\n\n            value0 := abi_decode_t_address(add(headStart, offset), dataEnd)\n        }\n\n        {\n\n            let offset := 32\n\n            value1 := abi_decode_t_address(add(headStart, offset), dataEnd)\n        }\n\n        {\n\n            let offset := 64\n\n            value2 := abi_decode_t_uint256(add(headStart, offset), dataEnd)\n        }\n\n    }\n\n    function cleanup_t_uint8(value) -> cleaned {\n        cleaned := and(value, 0xff)\n    }\n\n    function abi_encode_t_uint8_to_t_uint8_fromStack(value, pos) {\n        mstore(pos, cleanup_t_uint8(value))\n    }\n\n    function abi_encode_tuple_t_uint8__to_t_uint8__fromStack_reversed(headStart , value0) -> tail {\n        tail := add(headStart, 32)\n\n        abi_encode_t_uint8_to_t_uint8_fromStack(value0,  add(headStart, 0))\n\n    }\n\n    function abi_decode_tuple_t_address(headStart, dataEnd) -> value0 {\n        if slt(sub(dataEnd, headStart), 32) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }\n\n        {\n\n            let offset := 0\n\n            value0 := abi_decode_t_address(add(headStart, offset), dataEnd)\n        }\n\n    }\n\n    function abi_decode_tuple_t_addresst_address(headStart, dataEnd) -> value0, value1 {\n        if slt(sub(dataEnd, headStart), 64) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }\n\n        {\n\n            let offset := 0\n\n            value0 := abi_decode_t_address(add(headStart, offset), dataEnd)\n        }\n\n        {\n\n            let offset := 32\n\n            value1 := abi_decode_t_address(add(headStart, offset), dataEnd)\n        }\n\n    }\n\n    function panic_error_0x22() {\n        mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)\n        mstore(4, 0x22)\n        revert(0, 0x24)\n    }\n\n    function extract_byte_array_length(data) -> length {\n        length := div(data, 2)\n        let outOfPlaceEncoding := and(data, 1)\n        if iszero(outOfPlaceEncoding) {\n            length := and(length, 0x7f)\n        }\n\n        if eq(outOfPlaceEncoding, lt(length, 32)) {\n            panic_error_0x22()\n        }\n    }\n\n    function store_literal_in_memory_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee(memPtr) {\n\n        mstore(add(memPtr, 0), \"insufficient balance\")\n\n    }\n\n    function abi_encode_t_stringliteral_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee_to_t_string_memory_ptr_fromStack(pos) -> end {\n        pos := array_storeLengthForEncoding_t_string_memory_ptr_fromStack(pos, 20)\n        store_literal_in_memory_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee(pos)\n        end := add(pos, 32)\n    }\n\n    function abi_encode_tuple_t_stringliteral_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee__to_t_string_memory_ptr__fromStack_reversed(headStart ) -> tail {\n        tail := add(headStart, 32)\n\n        mstore(add(headStart, 0), sub(tail, headStart))\n        tail := abi_encode_t_stringliteral_a6d1ff1db3d0b9b8c60e12ccab5ce7431be9a2cd0518ac362f1c5c1e0b1cefee_to_t_string_memory_ptr_fromStack( tail)\n\n    }\n\n    function store_literal_in_memory_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618(memPtr) {\n\n        mstore(add(memPtr, 0), \"exceeds allowance\")\n\n    }\n\n    function abi_encode_t_stringliteral_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618_to_t_string_memory_ptr_fromStack(pos) -> end {\n        pos := array_storeLengthForEncoding_t_string_memory_ptr_fromStack(pos, 17)\n        store_literal_in_memory_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618(pos)\n        end := add(pos, 32)\n    }\n\n    function abi_encode_tuple_t_stringliteral_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618__to_t_string_memory_ptr__fromStack_reversed(headStart ) -> tail {\n        tail := add(headStart, 32)\n\n        mstore(add(headStart, 0), sub(tail, headStart))\n        tail := abi_encode_t_stringliteral_a2db9b2d459fa87320b1b84f2f349507cfdbf260f36c3b404dc6ea1ada9b5618_to_t_string_memory_ptr_fromStack( tail)\n\n    }\n\n    function panic_error_0x11() {\n        mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)\n        mstore(4, 0x11)\n        revert(0, 0x24)\n    }\n\n    function checked_sub_t_uint256(x, y) -> diff {\n        x := cleanup_t_uint256(x)\n        y := cleanup_t_uint256(y)\n        diff := sub(x, y)\n\n        if gt(diff, x) { panic_error_0x11() }\n\n    }\n\n    function checked_add_t_uint256(x, y) -> sum {\n        x := cleanup_t_uint256(x)\n        y := cleanup_t_uint256(y)\n        sum := add(x, y)\n\n        if gt(x, sum) { panic_error_0x11() }\n\n    }\n\n}\n","id":1,"language":"Yul","name":"#utility.yul"}],"immutableReferences":{},"linkReferences":{},"object":"608060405234801561001057600080fd5b506004361061009e5760003560e01c806340c10f191161006657806340c10f191461015d57806370a082311461017957806395d89b41146101a9578063a9059cbb146101c7578063dd62ed3e146101f75761009e565b806306fdde03146100a3578063095ea7b3146100c157806318160ddd146100f157806323b872dd1461010f578063313ce5671461013f575b600080fd5b6100ab610227565b6040516100b89190610a85565b60405180910390f35b6100db60048036038101906100d69190610b40565b6102b5565b6040516100e89190610b9b565b60405180910390f35b6100f96103a7565b6040516101069190610bc5565b60405180910390f35b61012960048036038101906101249190610be0565b6103ad565b6040516101369190610b9b565b60405180910390f35b61014761069f565b6040516101549190610c4f565b60405180910390f35b61017760048036038101906101729190610b40565b6106b2565b005b610193600480360381019061018e9190610c6a565b61078b565b6040516101a09190610bc5565b60405180910390f35b6101b16107a3565b6040516101be9190610a85565b60405180910390f35b6101e160048036038101906101dc9190610b40565b610831565b6040516101ee9190610b9b565b60405180910390f35b610211600480360381019061020c9190610c97565b6109d0565b60405161021e9190610bc5565b60405180910390f35b6000805461023490610d06565b80601f016020809104026020016040519081016040528092919081815260200182805461026090610d06565b80156102ad5780601f10610282576101008083540402835291602001916102ad565b820191906000526020600020905b81548152906001019060200180831161029057829003601f168201915b505050505081565b600081600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040516103959190610bc5565b60405180910390a36001905092915050565b60035481565b600081600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015610431576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161042890610d83565b60405180910390fd5b81600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410156104f0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104e790610def565b60405180910390fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461053f9190610e3e565b9250508190555081600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546105959190610e72565b9250508190555081600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546106289190610e3e565b925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8460405161068c9190610bc5565b60405180910390a3600190509392505050565b600260009054906101000a900460ff1681565b80600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546107019190610e72565b92505081905550806003600082825461071a9190610e72565b925050819055508173ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8360405161077f9190610bc5565b60405180910390a35050565b60046020528060005260406000206000915090505481565b600180546107b090610d06565b80601f01602080910402602001604051908101604052809291908181526020018280546107dc90610d06565b80156108295780601f106107fe57610100808354040283529160200191610829565b820191906000526020600020905b81548152906001019060200180831161080c57829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410156108b5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108ac90610d83565b60405180910390fd5b81600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546109049190610e3e565b9250508190555081600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461095a9190610e72565b925050819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516109be9190610bc5565b60405180910390a36001905092915050565b6005602052816000526040600020602052806000526040600020600091509150505481565b600081519050919050565b600082825260208201905092915050565b60005b83811015610a2f578082015181840152602081019050610a14565b60008484015250505050565b6000601f19601f8301169050919050565b6000610a57826109f5565b610a618185610a00565b9350610a71818560208601610a11565b610a7a81610a3b565b840191505092915050565b60006020820190508181036000830152610a9f8184610a4c565b905092915050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610ad782610aac565b9050919050565b610ae781610acc565b8114610af257600080fd5b50565b600081359050610b0481610ade565b92915050565b6000819050919050565b610b1d81610b0a565b8114610b2857600080fd5b50565b600081359050610b3a81610b14565b92915050565b60008060408385031215610b5757610b56610aa7565b5b6000610b6585828601610af5565b9250506020610b7685828601610b2b565b9150509250929050565b60008115159050919050565b610b9581610b80565b82525050565b6000602082019050610bb06000830184610b8c565b92915050565b610bbf81610b0a565b82525050565b6000602082019050610bda6000830184610bb6565b92915050565b600080600060608486031215610bf957610bf8610aa7565b5b6000610c0786828701610af5565b9350506020610c1886828701610af5565b9250506040610c2986828701610b2b565b9150509250925092565b600060ff82169050919050565b610c4981610c33565b82525050565b6000602082019050610c646000830184610c40565b92915050565b600060208284031215610c8057610c7f610aa7565b5b6000610c8e84828501610af5565b91505092915050565b60008060408385031215610cae57610cad610aa7565b5b6000610cbc85828601610af5565b9250506020610ccd85828601610af5565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680610d1e57607f821691505b602082108103610d3157610d30610cd7565b5b50919050565b7f696e73756666696369656e742062616c616e6365000000000000000000000000600082015250565b6000610d6d601483610a00565b9150610d7882610d37565b602082019050919050565b60006020820190508181036000830152610d9c81610d60565b9050919050565b7f6578636565647320616c6c6f77616e6365000000000000000000000000000000600082015250565b6000610dd9601183610a00565b9150610de482610da3565b602082019050919050565b60006020820190508181036000830152610e0881610dcc565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610e4982610b0a565b9150610e5483610b0a565b9250828203905081811115610e6c57610e6b610e0f565b5b92915050565b6000610e7d82610b0a565b9150610e8883610b0a565b9250828201905080821115610ea057610e9f610e0f565b5b9291505056fea264697066735822122041fa693da1c1decf8c3e4932e0c8ae158fb01e9b5107935494ee90fbcdd5f6dc64736f6c63430008180033","opcodes":"PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x9E JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x40C10F19 GT PUSH2 0x66 JUMPI DUP1 PUSH4 0x40C10F19 EQ PUSH2 0x15D JUMPI DUP1 PUSH4 0x70A08231 EQ PUSH2 0x179 JUMPI DUP1 PUSH4 0x95D89B41 EQ PUSH2 0x1A9 JUMPI DUP1 PUSH4 0xA9059CBB EQ PUSH2 0x1C7 JUMPI DUP1 PUSH4 0xDD62ED3E EQ PUSH2 0x1F7 JUMPI PUSH2 0x9E JUMP JUMPDEST DUP1 PUSH4 0x6FDDE03 EQ PUSH2 0xA3 JUMPI DUP1 PUSH4 0x95EA7B3 EQ PUSH2 0xC1 JUMPI DUP1 PUSH4 0x18160DDD EQ PUSH2 0xF1 JUMPI DUP1 PUSH4 0x23B872DD EQ PUSH2 0x10F JUMPI DUP1 PUSH4 0x313CE567 EQ PUSH2 0x13F JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0xAB PUSH2 0x227 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0xB8 SWAP2 SWAP1 PUSH2 0xA85 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xDB PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 PUSH2 0xD6 SWAP2 SWAP1 PUSH2 0xB40 JUMP JUMPDEST PUSH2 0x2B5 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0xE8 SWAP2 SWAP1 PUSH2 0xB9B JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xF9 PUSH2 0x3A7 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x106 SWAP2 SWAP1 PUSH2 0xBC5 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x129 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 PUSH2 0x124 SWAP2 SWAP1 PUSH2 0xBE0 JUMP JUMPDEST PUSH2 0x3AD JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x136 SWAP2 SWAP1 PUSH2 0xB9B JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x147 PUSH2 0x69F JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x154 SWAP2 SWAP1 PUSH2 0xC4F JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x177 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 PUSH2 0x172 SWAP2 SWAP1 PUSH2 0xB40 JUMP JUMPDEST PUSH2 0x6B2 JUMP JUMPDEST STOP JUMPDEST PUSH2 0x193 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 PUSH2 0x18E SWAP2 SWAP1 PUSH2 0xC6A JUMP JUMPDEST PUSH2 0x78B JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x1A0 SWAP2 SWAP1 PUSH2 0xBC5 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x1B1 PUSH2 0x7A3 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x1BE SWAP2 SWAP1 PUSH2 0xA85 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x1E1 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 PUSH2 0x1DC SWAP2 SWAP1 PUSH2 0xB40 JUMP JUMPDEST PUSH2 0x831 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x1EE SWAP2 SWAP1 PUSH2 0xB9B JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x211 PUSH1 0x4 DUP1 CALLDATASIZE SUB DUP2 ADD SWAP1 PUSH2 0x20C SWAP2 SWAP1 PUSH2 0xC97 JUMP JUMPDEST PUSH2 0x9D0 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x21E SWAP2 SWAP1 PUSH2 0xBC5 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH2 0x234 SWAP1 PUSH2 0xD06 JUMP JUMPDEST DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP1 SLOAD PUSH2 0x260 SWAP1 PUSH2 0xD06 JUMP JUMPDEST DUP1 ISZERO PUSH2 0x2AD JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x282 JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x2AD JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE SWAP1 PUSH1 0x1 ADD SWAP1 PUSH1 0x20 ADD DUP1 DUP4 GT PUSH2 0x290 JUMPI DUP3 SWAP1 SUB PUSH1 0x1F AND DUP3 ADD SWAP2 JUMPDEST POP POP POP POP POP DUP2 JUMP JUMPDEST PUSH1 0x0 DUP2 PUSH1 0x5 PUSH1 0x0 CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 DUP6 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 DUP2 SWAP1 SSTORE POP DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH32 0x8C5BE1E5EBEC7D5BD14F71427D1E84F3DD0314C0F7B2291E5B200AC8C7C3B925 DUP5 PUSH1 0x40 MLOAD PUSH2 0x395 SWAP2 SWAP1 PUSH2 0xBC5 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG3 PUSH1 0x1 SWAP1 POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x3 SLOAD DUP2 JUMP JUMPDEST PUSH1 0x0 DUP2 PUSH1 0x4 PUSH1 0x0 DUP7 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 SLOAD LT ISZERO PUSH2 0x431 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x428 SWAP1 PUSH2 0xD83 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST DUP2 PUSH1 0x5 PUSH1 0x0 DUP7 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 SLOAD LT ISZERO PUSH2 0x4F0 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x4E7 SWAP1 PUSH2 0xDEF JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST DUP2 PUSH1 0x4 PUSH1 0x0 DUP7 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 DUP3 DUP3 SLOAD PUSH2 0x53F SWAP2 SWAP1 PUSH2 0xE3E JUMP JUMPDEST SWAP3 POP POP DUP2 SWAP1 SSTORE POP DUP2 PUSH1 0x4 PUSH1 0x0 DUP6 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 DUP3 DUP3 SLOAD PUSH2 0x595 SWAP2 SWAP1 PUSH2 0xE72 JUMP JUMPDEST SWAP3 POP POP DUP2 SWAP1 SSTORE POP DUP2 PUSH1 0x5 PUSH1 0x0 DUP7 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 DUP3 DUP3 SLOAD PUSH2 0x628 SWAP2 SWAP1 PUSH2 0xE3E JUMP JUMPDEST SWAP3 POP POP DUP2 SWAP1 SSTORE POP DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP5 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH32 0xDDF252AD1BE2C89B69C2B068FC378DAA952BA7F163C4A11628F55A4DF523B3EF DUP5 PUSH1 0x40 MLOAD PUSH2 0x68C SWAP2 SWAP1 PUSH2 0xBC5 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG3 PUSH1 0x1 SWAP1 POP SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x2 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH1 0xFF AND DUP2 JUMP JUMPDEST DUP1 PUSH1 0x4 PUSH1 0x0 DUP5 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 DUP3 DUP3 SLOAD PUSH2 0x701 SWAP2 SWAP1 PUSH2 0xE72 JUMP JUMPDEST SWAP3 POP POP DUP2 SWAP1 SSTORE POP DUP1 PUSH1 0x3 PUSH1 0x0 DUP3 DUP3 SLOAD PUSH2 0x71A SWAP2 SWAP1 PUSH2 0xE72 JUMP JUMPDEST SWAP3 POP POP DUP2 SWAP1 SSTORE POP DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH1 0x0 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH32 0xDDF252AD1BE2C89B69C2B068FC378DAA952BA7F163C4A11628F55A4DF523B3EF DUP4 PUSH1 0x40 MLOAD PUSH2 0x77F SWAP2 SWAP1 PUSH2 0xBC5 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 0x4 PUSH1 0x20 MSTORE DUP1 PUSH1 0x0 MSTORE PUSH1 0x40 PUSH1 0x0 KECCAK256 PUSH1 0x0 SWAP2 POP SWAP1 POP SLOAD DUP2 JUMP JUMPDEST PUSH1 0x1 DUP1 SLOAD PUSH2 0x7B0 SWAP1 PUSH2 0xD06 JUMP JUMPDEST DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP1 SLOAD PUSH2 0x7DC SWAP1 PUSH2 0xD06 JUMP JUMPDEST DUP1 ISZERO PUSH2 0x829 JUMPI DUP1 PUSH1 0x1F LT PUSH2 0x7FE JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0x829 JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 KECCAK256 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE SWAP1 PUSH1 0x1 ADD SWAP1 PUSH1 0x20 ADD DUP1 DUP4 GT PUSH2 0x80C JUMPI DUP3 SWAP1 SUB PUSH1 0x1F AND DUP3 ADD SWAP2 JUMPDEST POP POP POP POP POP DUP2 JUMP JUMPDEST PUSH1 0x0 DUP2 PUSH1 0x4 PUSH1 0x0 CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 SLOAD LT ISZERO PUSH2 0x8B5 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x8AC SWAP1 PUSH2 0xD83 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST DUP2 PUSH1 0x4 PUSH1 0x0 CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 DUP3 DUP3 SLOAD PUSH2 0x904 SWAP2 SWAP1 PUSH2 0xE3E JUMP JUMPDEST SWAP3 POP POP DUP2 SWAP1 SSTORE POP DUP2 PUSH1 0x4 PUSH1 0x0 DUP6 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 DUP3 DUP3 SLOAD PUSH2 0x95A SWAP2 SWAP1 PUSH2 0xE72 JUMP JUMPDEST SWAP3 POP POP DUP2 SWAP1 SSTORE POP DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH32 0xDDF252AD1BE2C89B69C2B068FC378DAA952BA7F163C4A11628F55A4DF523B3EF DUP5 PUSH1 0x40 MLOAD PUSH2 0x9BE SWAP2 SWAP1 PUSH2 0xBC5 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG3 PUSH1 0x1 SWAP1 POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x5 PUSH1 0x20 MSTORE DUP2 PUSH1 0x0 MSTORE PUSH1 0x40 PUSH1 0x0 KECCAK256 PUSH1 0x20 MSTORE DUP1 PUSH1 0x0 MSTORE PUSH1 0x40 PUSH1 0x0 KECCAK256 PUSH1 0x0 SWAP2 POP SWAP2 POP POP SLOAD DUP2 JUMP JUMPDEST PUSH1 0x0 DUP2 MLOAD SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP3 DUP3 MSTORE PUSH1 0x20 DUP3 ADD SWAP1 POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0xA2F JUMPI DUP1 DUP3 ADD MLOAD DUP2 DUP5 ADD MSTORE PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH2 0xA14 JUMP JUMPDEST PUSH1 0x0 DUP5 DUP5 ADD MSTORE POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x1F NOT PUSH1 0x1F DUP4 ADD AND SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xA57 DUP3 PUSH2 0x9F5 JUMP JUMPDEST PUSH2 0xA61 DUP2 DUP6 PUSH2 0xA00 JUMP JUMPDEST SWAP4 POP PUSH2 0xA71 DUP2 DUP6 PUSH1 0x20 DUP7 ADD PUSH2 0xA11 JUMP JUMPDEST PUSH2 0xA7A DUP2 PUSH2 0xA3B JUMP JUMPDEST DUP5 ADD SWAP2 POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD SWAP1 POP DUP2 DUP2 SUB PUSH1 0x0 DUP4 ADD MSTORE PUSH2 0xA9F DUP2 DUP5 PUSH2 0xA4C JUMP JUMPDEST SWAP1 POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP3 AND SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xAD7 DUP3 PUSH2 0xAAC JUMP JUMPDEST SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0xAE7 DUP2 PUSH2 0xACC JUMP JUMPDEST DUP2 EQ PUSH2 0xAF2 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 DUP2 CALLDATALOAD SWAP1 POP PUSH2 0xB04 DUP2 PUSH2 0xADE JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0xB1D DUP2 PUSH2 0xB0A JUMP JUMPDEST DUP2 EQ PUSH2 0xB28 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 DUP2 CALLDATALOAD SWAP1 POP PUSH2 0xB3A DUP2 PUSH2 0xB14 JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH2 0xB57 JUMPI PUSH2 0xB56 PUSH2 0xAA7 JUMP JUMPDEST JUMPDEST PUSH1 0x0 PUSH2 0xB65 DUP6 DUP3 DUP7 ADD PUSH2 0xAF5 JUMP JUMPDEST SWAP3 POP POP PUSH1 0x20 PUSH2 0xB76 DUP6 DUP3 DUP7 ADD PUSH2 0xB2B JUMP JUMPDEST SWAP2 POP POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP2 ISZERO ISZERO SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0xB95 DUP2 PUSH2 0xB80 JUMP JUMPDEST DUP3 MSTORE POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD SWAP1 POP PUSH2 0xBB0 PUSH1 0x0 DUP4 ADD DUP5 PUSH2 0xB8C JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH2 0xBBF DUP2 PUSH2 0xB0A JUMP JUMPDEST DUP3 MSTORE POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD SWAP1 POP PUSH2 0xBDA PUSH1 0x0 DUP4 ADD DUP5 PUSH2 0xBB6 JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x60 DUP5 DUP7 SUB SLT ISZERO PUSH2 0xBF9 JUMPI PUSH2 0xBF8 PUSH2 0xAA7 JUMP JUMPDEST JUMPDEST PUSH1 0x0 PUSH2 0xC07 DUP7 DUP3 DUP8 ADD PUSH2 0xAF5 JUMP JUMPDEST SWAP4 POP POP PUSH1 0x20 PUSH2 0xC18 DUP7 DUP3 DUP8 ADD PUSH2 0xAF5 JUMP JUMPDEST SWAP3 POP POP PUSH1 0x40 PUSH2 0xC29 DUP7 DUP3 DUP8 ADD PUSH2 0xB2B JUMP JUMPDEST SWAP2 POP POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH1 0x0 PUSH1 0xFF DUP3 AND SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0xC49 DUP2 PUSH2 0xC33 JUMP JUMPDEST DUP3 MSTORE POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD SWAP1 POP PUSH2 0xC64 PUSH1 0x0 DUP4 ADD DUP5 PUSH2 0xC40 JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0xC80 JUMPI PUSH2 0xC7F PUSH2 0xAA7 JUMP JUMPDEST JUMPDEST PUSH1 0x0 PUSH2 0xC8E DUP5 DUP3 DUP6 ADD PUSH2 0xAF5 JUMP JUMPDEST SWAP2 POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH2 0xCAE JUMPI PUSH2 0xCAD PUSH2 0xAA7 JUMP JUMPDEST JUMPDEST PUSH1 0x0 PUSH2 0xCBC DUP6 DUP3 DUP7 ADD PUSH2 0xAF5 JUMP JUMPDEST SWAP3 POP POP PUSH1 0x20 PUSH2 0xCCD DUP6 DUP3 DUP7 ADD PUSH2 0xAF5 JUMP JUMPDEST SWAP2 POP POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH32 0x4E487B7100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 MSTORE PUSH1 0x22 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 PUSH1 0x2 DUP3 DIV SWAP1 POP PUSH1 0x1 DUP3 AND DUP1 PUSH2 0xD1E JUMPI PUSH1 0x7F DUP3 AND SWAP2 POP JUMPDEST PUSH1 0x20 DUP3 LT DUP2 SUB PUSH2 0xD31 JUMPI PUSH2 0xD30 PUSH2 0xCD7 JUMP JUMPDEST JUMPDEST POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH32 0x696E73756666696369656E742062616C616E6365000000000000000000000000 PUSH1 0x0 DUP3 ADD MSTORE POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xD6D PUSH1 0x14 DUP4 PUSH2 0xA00 JUMP JUMPDEST SWAP2 POP PUSH2 0xD78 DUP3 PUSH2 0xD37 JUMP JUMPDEST PUSH1 0x20 DUP3 ADD SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD SWAP1 POP DUP2 DUP2 SUB PUSH1 0x0 DUP4 ADD MSTORE PUSH2 0xD9C DUP2 PUSH2 0xD60 JUMP JUMPDEST SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH32 0x6578636565647320616C6C6F77616E6365000000000000000000000000000000 PUSH1 0x0 DUP3 ADD MSTORE POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xDD9 PUSH1 0x11 DUP4 PUSH2 0xA00 JUMP JUMPDEST SWAP2 POP PUSH2 0xDE4 DUP3 PUSH2 0xDA3 JUMP JUMPDEST PUSH1 0x20 DUP3 ADD SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD SWAP1 POP DUP2 DUP2 SUB PUSH1 0x0 DUP4 ADD MSTORE PUSH2 0xE08 DUP2 PUSH2 0xDCC JUMP JUMPDEST SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH32 0x4E487B7100000000000000000000000000000000000000000000000000000000 PUSH1 0x0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 PUSH2 0xE49 DUP3 PUSH2 0xB0A JUMP JUMPDEST SWAP2 POP PUSH2 0xE54 DUP4 PUSH2 0xB0A JUMP JUMPDEST SWAP3 POP DUP3 DUP3 SUB SWAP1 POP DUP2 DUP2 GT ISZERO PUSH2 0xE6C JUMPI PUSH2 0xE6B PUSH2 0xE0F JUMP JUMPDEST JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0xE7D DUP3 PUSH2 0xB0A JUMP JUMPDEST SWAP2 POP PUSH2 0xE88 DUP4 PUSH2 0xB0A JUMP JUMPDEST SWAP3 POP DUP3 DUP3 ADD SWAP1 POP DUP1 DUP3 GT ISZERO PUSH2 0xEA0 JUMPI PUSH2 0xE9F PUSH2 0xE0F JUMP JUMPDEST JUMPDEST SWAP3 SWAP2 POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 COINBASE STATICCALL PUSH10 0x3DA1C1DECF8C3E4932E0 0xC8 0xAE ISZERO DUP16 0xB0 0x1E SWAP12 MLOAD SMOD SWAP4 SLOAD SWAP5 0xEE SWAP1 0xFB 0xCD 0xD5 0xF6 0xDC PUSH5 0x736F6C6343 STOP ADDMOD XOR STOP CALLER ","sourceMap":"58:1667:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;83:30;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;926:206;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;185:26;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;1138:416;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;153:26;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;1560:163;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;217:44;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;119:28;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;626:294;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;267:64;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;83:30;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;926:206::-;991:12;1048:5;1015:9;:21;1025:10;1015:21;;;;;;;;;;;;;;;:30;1037:7;1015:30;;;;;;;;;;;;;;;:38;;;;1089:7;1068:36;;1077:10;1068:36;;;1098:5;1068:36;;;;;;:::i;:::-;;;;;;;;1121:4;1114:11;;926:206;;;;:::o;185:26::-;;;;:::o;1138:416::-;1217:12;1268:5;1249:9;:15;1259:4;1249:15;;;;;;;;;;;;;;;;:24;;1241:57;;;;;;;;;;;;:::i;:::-;;;;;;;;;1347:5;1316:9;:15;1326:4;1316:15;;;;;;;;;;;;;;;:27;1332:10;1316:27;;;;;;;;;;;;;;;;:36;;1308:66;;;;;;;;;;;;:::i;:::-;;;;;;;;;1403:5;1384:9;:15;1394:4;1384:15;;;;;;;;;;;;;;;;:24;;;;;;;:::i;:::-;;;;;;;;1435:5;1418:9;:13;1428:2;1418:13;;;;;;;;;;;;;;;;:22;;;;;;;:::i;:::-;;;;;;;;1481:5;1450:9;:15;1460:4;1450:15;;;;;;;;;;;;;;;:27;1466:10;1450:27;;;;;;;;;;;;;;;;:36;;;;;;;:::i;:::-;;;;;;;;1516:2;1501:25;;1510:4;1501:25;;;1520:5;1501:25;;;;;;:::i;:::-;;;;;;;;1543:4;1536:11;;1138:416;;;;;:::o;153:26::-;;;;;;;;;;;;;:::o;1560:163::-;1635:5;1618:9;:13;1628:2;1618:13;;;;;;;;;;;;;;;;:22;;;;;;;:::i;:::-;;;;;;;;1665:5;1650:11;;:20;;;;;;;:::i;:::-;;;;;;;;1706:2;1685:31;;1702:1;1685:31;;;1710:5;1685:31;;;;;;:::i;:::-;;;;;;;;1560:163;;:::o;217:44::-;;;;;;;;;;;;;;;;;:::o;119:28::-;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;626:294::-;687:12;744:5;719:9;:21;729:10;719:21;;;;;;;;;;;;;;;;:30;;711:63;;;;;;;;;;;;:::i;:::-;;;;;;;;;809:5;784:9;:21;794:10;784:21;;;;;;;;;;;;;;;;:30;;;;;;;:::i;:::-;;;;;;;;841:5;824:9;:13;834:2;824:13;;;;;;;;;;;;;;;;:22;;;;;;;:::i;:::-;;;;;;;;882:2;861:31;;870:10;861:31;;;886:5;861:31;;;;;;:::i;:::-;;;;;;;;909:4;902:11;;626:294;;;;:::o;267:64::-;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;7:99:1:-;59:6;93:5;87:12;77:22;;7:99;;;:::o;112:169::-;196:11;230:6;225:3;218:19;270:4;265:3;261:14;246:29;;112:169;;;;:::o;287:246::-;368:1;378:113;392:6;389:1;386:13;378:113;;;477:1;472:3;468:11;462:18;458:1;453:3;449:11;442:39;414:2;411:1;407:10;402:15;;378:113;;;525:1;516:6;511:3;507:16;500:27;349:184;287:246;;;:::o;539:102::-;580:6;631:2;627:7;622:2;615:5;611:14;607:28;597:38;;539:102;;;:::o;647:377::-;735:3;763:39;796:5;763:39;:::i;:::-;818:71;882:6;877:3;818:71;:::i;:::-;811:78;;898:65;956:6;951:3;944:4;937:5;933:16;898:65;:::i;:::-;988:29;1010:6;988:29;:::i;:::-;983:3;979:39;972:46;;739:285;647:377;;;;:::o;1030:313::-;1143:4;1181:2;1170:9;1166:18;1158:26;;1230:9;1224:4;1220:20;1216:1;1205:9;1201:17;1194:47;1258:78;1331:4;1322:6;1258:78;:::i;:::-;1250:86;;1030:313;;;;:::o;1430:117::-;1539:1;1536;1529:12;1676:126;1713:7;1753:42;1746:5;1742:54;1731:65;;1676:126;;;:::o;1808:96::-;1845:7;1874:24;1892:5;1874:24;:::i;:::-;1863:35;;1808:96;;;:::o;1910:122::-;1983:24;2001:5;1983:24;:::i;:::-;1976:5;1973:35;1963:63;;2022:1;2019;2012:12;1963:63;1910:122;:::o;2038:139::-;2084:5;2122:6;2109:20;2100:29;;2138:33;2165:5;2138:33;:::i;:::-;2038:139;;;;:::o;2183:77::-;2220:7;2249:5;2238:16;;2183:77;;;:::o;2266:122::-;2339:24;2357:5;2339:24;:::i;:::-;2332:5;2329:35;2319:63;;2378:1;2375;2368:12;2319:63;2266:122;:::o;2394:139::-;2440:5;2478:6;2465:20;2456:29;;2494:33;2521:5;2494:33;:::i;:::-;2394:139;;;;:::o;2539:474::-;2607:6;2615;2664:2;2652:9;2643:7;2639:23;2635:32;2632:119;;;2670:79;;:::i;:::-;2632:119;2790:1;2815:53;2860:7;2851:6;2840:9;2836:22;2815:53;:::i;:::-;2805:63;;2761:117;2917:2;2943:53;2988:7;2979:6;2968:9;2964:22;2943:53;:::i;:::-;2933:63;;2888:118;2539:474;;;;;:::o;3019:90::-;3053:7;3096:5;3089:13;3082:21;3071:32;;3019:90;;;:::o;3115:109::-;3196:21;3211:5;3196:21;:::i;:::-;3191:3;3184:34;3115:109;;:::o;3230:210::-;3317:4;3355:2;3344:9;3340:18;3332:26;;3368:65;3430:1;3419:9;3415:17;3406:6;3368:65;:::i;:::-;3230:210;;;;:::o;3446:118::-;3533:24;3551:5;3533:24;:::i;:::-;3528:3;3521:37;3446:118;;:::o;3570:222::-;3663:4;3701:2;3690:9;3686:18;3678:26;;3714:71;3782:1;3771:9;3767:17;3758:6;3714:71;:::i;:::-;3570:222;;;;:::o;3798:619::-;3875:6;3883;3891;3940:2;3928:9;3919:7;3915:23;3911:32;3908:119;;;3946:79;;:::i;:::-;3908:119;4066:1;4091:53;4136:7;4127:6;4116:9;4112:22;4091:53;:::i;:::-;4081:63;;4037:117;4193:2;4219:53;4264:7;4255:6;4244:9;4240:22;4219:53;:::i;:::-;4209:63;;4164:118;4321:2;4347:53;4392:7;4383:6;4372:9;4368:22;4347:53;:::i;:::-;4337:63;;4292:118;3798:619;;;;;:::o;4423:86::-;4458:7;4498:4;4491:5;4487:16;4476:27;;4423:86;;;:::o;4515:112::-;4598:22;4614:5;4598:22;:::i;:::-;4593:3;4586:35;4515:112;;:::o;4633:214::-;4722:4;4760:2;4749:9;4745:18;4737:26;;4773:67;4837:1;4826:9;4822:17;4813:6;4773:67;:::i;:::-;4633:214;;;;:::o;4853:329::-;4912:6;4961:2;4949:9;4940:7;4936:23;4932:32;4929:119;;;4967:79;;:::i;:::-;4929:119;5087:1;5112:53;5157:7;5148:6;5137:9;5133:22;5112:53;:::i;:::-;5102:63;;5058:117;4853:329;;;;:::o;5188:474::-;5256:6;5264;5313:2;5301:9;5292:7;5288:23;5284:32;5281:119;;;5319:79;;:::i;:::-;5281:119;5439:1;5464:53;5509:7;5500:6;5489:9;5485:22;5464:53;:::i;:::-;5454:63;;5410:117;5566:2;5592:53;5637:7;5628:6;5617:9;5613:22;5592:53;:::i;:::-;5582:63;;5537:118;5188:474;;;;;:::o;5668:180::-;5716:77;5713:1;5706:88;5813:4;5810:1;5803:15;5837:4;5834:1;5827:15;5854:320;5898:6;5935:1;5929:4;5925:12;5915:22;;5982:1;5976:4;5972:12;6003:18;5993:81;;6059:4;6051:6;6047:17;6037:27;;5993:81;6121:2;6113:6;6110:14;6090:18;6087:38;6084:84;;6140:18;;:::i;:::-;6084:84;5905:269;5854:320;;;:::o;6180:170::-;6320:22;6316:1;6308:6;6304:14;6297:46;6180:170;:::o;6356:366::-;6498:3;6519:67;6583:2;6578:3;6519:67;:::i;:::-;6512:74;;6595:93;6684:3;6595:93;:::i;:::-;6713:2;6708:3;6704:12;6697:19;;6356:366;;;:::o;6728:419::-;6894:4;6932:2;6921:9;6917:18;6909:26;;6981:9;6975:4;6971:20;6967:1;6956:9;6952:17;6945:47;7009:131;7135:4;7009:131;:::i;:::-;7001:139;;6728:419;;;:::o;7153:167::-;7293:19;7289:1;7281:6;7277:14;7270:43;7153:167;:::o;7326:366::-;7468:3;7489:67;7553:2;7548:3;7489:67;:::i;:::-;7482:74;;7565:93;7654:3;7565:93;:::i;:::-;7683:2;7678:3;7674:12;7667:19;;7326:366;;;:::o;7698:419::-;7864:4;7902:2;7891:9;7887:18;7879:26;;7951:9;7945:4;7941:20;7937:1;7926:9;7922:17;7915:47;7979:131;8105:4;7979:131;:::i;:::-;7971:139;;7698:419;;;:::o;8123:180::-;8171:77;8168:1;8161:88;8268:4;8265:1;8258:15;8292:4;8289:1;8282:15;8309:194;8349:4;8369:20;8387:1;8369:20;:::i;:::-;8364:25;;8403:20;8421:1;8403:20;:::i;:::-;8398:25;;8447:1;8444;8440:9;8432:17;;8471:1;8465:4;8462:11;8459:37;;;8476:18;;:::i;:::-;8459:37;8309:194;;;;:::o;8509:191::-;8549:3;8568:20;8586:1;8568:20;:::i;:::-;8563:25;;8602:20;8620:1;8602:20;:::i;:::-;8597:25;;8645:1;8642;8638:9;8631:16;;8666:3;8663:1;8660:10;8657:36;;;8673:18;;:::i;:::-;8657:36;8509:191;;;;:::o"},"methodIdentifiers":{"allowance(address,address)":"dd62ed3e","approve(address,uint256)":"095ea7b3","balanceOf(address)":"70a08231","decimals()":"313ce567","mint(address,uint256)":"40c10f19","name()":"06fdde03","symbol()":"95d89b41","totalSupply()":"18160ddd","transfer(address,uint256)":"a9059cbb","transferFrom(address,address,uint256)":"23b872dd"}},"metadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/TestToken.sol\":\"TestToken\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/TestToken.sol\":{\"keccak256\":\"0xcc2f6cad2cc1af002c25976d39fb5ae2ead24e87ab687728297db858d1f4be4b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://23ec38a5a4a99511d904dd8c40d4ba18a9cc8f523668ffb7bc32b215b8f7c1e2\",\"dweb:/ipfs/QmViwAngs81bYSi4sXoykkrjTdUnhU6gec6dzpCKY5jcCj\"]}},\"version\":1}"}}}}}

================
File: artifacts/contracts/TestToken.sol/TestToken.dbg.json
================
{
  "_format": "hh-sol-dbg-1",
  "buildInfo": "../../build-info/a41376ba4fdfb875b722abb085e468b4.json"
}

================
File: artifacts/contracts/TestToken.sol/TestToken.json
================
{
  "_format": "hh-sol-artifact-1",
  "contractName": "TestToken",
  "sourceName": "contracts/TestToken.sol",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "allowance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "mint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "bytecode": "0x60806040526040518060400160405280600781526020017f4d79546f6b656e00000000000000000000000000000000000000000000000000815250600090816200004a9190620003b9565b506040518060400160405280600381526020017f4d4350000000000000000000000000000000000000000000000000000000000081525060019081620000919190620003b9565b506012600260006101000a81548160ff021916908360ff160217905550348015620000bb57600080fd5b50600260009054906101000a900460ff1660ff16600a620000dd919062000623565b620f4240620000ed919062000674565b600381905550600354600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550620006bf565b600081519050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680620001c157607f821691505b602082108103620001d757620001d662000179565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b600060088302620002417fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000202565b6200024d868362000202565b95508019841693508086168417925050509392505050565b6000819050919050565b6000819050919050565b60006200029a620002946200028e8462000265565b6200026f565b62000265565b9050919050565b6000819050919050565b620002b68362000279565b620002ce620002c582620002a1565b8484546200020f565b825550505050565b600090565b620002e5620002d6565b620002f2818484620002ab565b505050565b5b818110156200031a576200030e600082620002db565b600181019050620002f8565b5050565b601f82111562000369576200033381620001dd565b6200033e84620001f2565b810160208510156200034e578190505b620003666200035d85620001f2565b830182620002f7565b50505b505050565b600082821c905092915050565b60006200038e600019846008026200036e565b1980831691505092915050565b6000620003a983836200037b565b9150826002028217905092915050565b620003c4826200013f565b67ffffffffffffffff811115620003e057620003df6200014a565b5b620003ec8254620001a8565b620003f98282856200031e565b600060209050601f8311600181146200043157600084156200041c578287015190505b6200042885826200039b565b86555062000498565b601f1984166200044186620001dd565b60005b828110156200046b5784890151825560018201915060208501945060208101905062000444565b868310156200048b578489015162000487601f8916826200037b565b8355505b6001600288020188555050505b505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008160011c9050919050565b6000808291508390505b60018511156200052e57808604811115620005065762000505620004a0565b5b6001851615620005165780820291505b80810290506200052685620004cf565b9450620004e6565b94509492505050565b6000826200054957600190506200061c565b816200055957600090506200061c565b81600181146200057257600281146200057d57620005b3565b60019150506200061c565b60ff841115620005925762000591620004a0565b5b8360020a915084821115620005ac57620005ab620004a0565b5b506200061c565b5060208310610133831016604e8410600b8410161715620005ed5782820a905083811115620005e757620005e6620004a0565b5b6200061c565b620005fc8484846001620004dc565b92509050818404811115620006165762000615620004a0565b5b81810290505b9392505050565b6000620006308262000265565b91506200063d8362000265565b92506200066c7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff848462000537565b905092915050565b6000620006818262000265565b91506200068e8362000265565b92508282026200069e8162000265565b91508282048414831517620006b857620006b7620004a0565b5b5092915050565b610edc80620006cf6000396000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c806340c10f191161006657806340c10f191461015d57806370a082311461017957806395d89b41146101a9578063a9059cbb146101c7578063dd62ed3e146101f75761009e565b806306fdde03146100a3578063095ea7b3146100c157806318160ddd146100f157806323b872dd1461010f578063313ce5671461013f575b600080fd5b6100ab610227565b6040516100b89190610a85565b60405180910390f35b6100db60048036038101906100d69190610b40565b6102b5565b6040516100e89190610b9b565b60405180910390f35b6100f96103a7565b6040516101069190610bc5565b60405180910390f35b61012960048036038101906101249190610be0565b6103ad565b6040516101369190610b9b565b60405180910390f35b61014761069f565b6040516101549190610c4f565b60405180910390f35b61017760048036038101906101729190610b40565b6106b2565b005b610193600480360381019061018e9190610c6a565b61078b565b6040516101a09190610bc5565b60405180910390f35b6101b16107a3565b6040516101be9190610a85565b60405180910390f35b6101e160048036038101906101dc9190610b40565b610831565b6040516101ee9190610b9b565b60405180910390f35b610211600480360381019061020c9190610c97565b6109d0565b60405161021e9190610bc5565b60405180910390f35b6000805461023490610d06565b80601f016020809104026020016040519081016040528092919081815260200182805461026090610d06565b80156102ad5780601f10610282576101008083540402835291602001916102ad565b820191906000526020600020905b81548152906001019060200180831161029057829003601f168201915b505050505081565b600081600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040516103959190610bc5565b60405180910390a36001905092915050565b60035481565b600081600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015610431576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161042890610d83565b60405180910390fd5b81600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410156104f0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104e790610def565b60405180910390fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461053f9190610e3e565b9250508190555081600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546105959190610e72565b9250508190555081600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546106289190610e3e565b925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8460405161068c9190610bc5565b60405180910390a3600190509392505050565b600260009054906101000a900460ff1681565b80600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546107019190610e72565b92505081905550806003600082825461071a9190610e72565b925050819055508173ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8360405161077f9190610bc5565b60405180910390a35050565b60046020528060005260406000206000915090505481565b600180546107b090610d06565b80601f01602080910402602001604051908101604052809291908181526020018280546107dc90610d06565b80156108295780601f106107fe57610100808354040283529160200191610829565b820191906000526020600020905b81548152906001019060200180831161080c57829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410156108b5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108ac90610d83565b60405180910390fd5b81600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546109049190610e3e565b9250508190555081600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461095a9190610e72565b925050819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516109be9190610bc5565b60405180910390a36001905092915050565b6005602052816000526040600020602052806000526040600020600091509150505481565b600081519050919050565b600082825260208201905092915050565b60005b83811015610a2f578082015181840152602081019050610a14565b60008484015250505050565b6000601f19601f8301169050919050565b6000610a57826109f5565b610a618185610a00565b9350610a71818560208601610a11565b610a7a81610a3b565b840191505092915050565b60006020820190508181036000830152610a9f8184610a4c565b905092915050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610ad782610aac565b9050919050565b610ae781610acc565b8114610af257600080fd5b50565b600081359050610b0481610ade565b92915050565b6000819050919050565b610b1d81610b0a565b8114610b2857600080fd5b50565b600081359050610b3a81610b14565b92915050565b60008060408385031215610b5757610b56610aa7565b5b6000610b6585828601610af5565b9250506020610b7685828601610b2b565b9150509250929050565b60008115159050919050565b610b9581610b80565b82525050565b6000602082019050610bb06000830184610b8c565b92915050565b610bbf81610b0a565b82525050565b6000602082019050610bda6000830184610bb6565b92915050565b600080600060608486031215610bf957610bf8610aa7565b5b6000610c0786828701610af5565b9350506020610c1886828701610af5565b9250506040610c2986828701610b2b565b9150509250925092565b600060ff82169050919050565b610c4981610c33565b82525050565b6000602082019050610c646000830184610c40565b92915050565b600060208284031215610c8057610c7f610aa7565b5b6000610c8e84828501610af5565b91505092915050565b60008060408385031215610cae57610cad610aa7565b5b6000610cbc85828601610af5565b9250506020610ccd85828601610af5565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680610d1e57607f821691505b602082108103610d3157610d30610cd7565b5b50919050565b7f696e73756666696369656e742062616c616e6365000000000000000000000000600082015250565b6000610d6d601483610a00565b9150610d7882610d37565b602082019050919050565b60006020820190508181036000830152610d9c81610d60565b9050919050565b7f6578636565647320616c6c6f77616e6365000000000000000000000000000000600082015250565b6000610dd9601183610a00565b9150610de482610da3565b602082019050919050565b60006020820190508181036000830152610e0881610dcc565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610e4982610b0a565b9150610e5483610b0a565b9250828203905081811115610e6c57610e6b610e0f565b5b92915050565b6000610e7d82610b0a565b9150610e8883610b0a565b9250828201905080821115610ea057610e9f610e0f565b5b9291505056fea264697066735822122041fa693da1c1decf8c3e4932e0c8ae158fb01e9b5107935494ee90fbcdd5f6dc64736f6c63430008180033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061009e5760003560e01c806340c10f191161006657806340c10f191461015d57806370a082311461017957806395d89b41146101a9578063a9059cbb146101c7578063dd62ed3e146101f75761009e565b806306fdde03146100a3578063095ea7b3146100c157806318160ddd146100f157806323b872dd1461010f578063313ce5671461013f575b600080fd5b6100ab610227565b6040516100b89190610a85565b60405180910390f35b6100db60048036038101906100d69190610b40565b6102b5565b6040516100e89190610b9b565b60405180910390f35b6100f96103a7565b6040516101069190610bc5565b60405180910390f35b61012960048036038101906101249190610be0565b6103ad565b6040516101369190610b9b565b60405180910390f35b61014761069f565b6040516101549190610c4f565b60405180910390f35b61017760048036038101906101729190610b40565b6106b2565b005b610193600480360381019061018e9190610c6a565b61078b565b6040516101a09190610bc5565b60405180910390f35b6101b16107a3565b6040516101be9190610a85565b60405180910390f35b6101e160048036038101906101dc9190610b40565b610831565b6040516101ee9190610b9b565b60405180910390f35b610211600480360381019061020c9190610c97565b6109d0565b60405161021e9190610bc5565b60405180910390f35b6000805461023490610d06565b80601f016020809104026020016040519081016040528092919081815260200182805461026090610d06565b80156102ad5780601f10610282576101008083540402835291602001916102ad565b820191906000526020600020905b81548152906001019060200180831161029057829003601f168201915b505050505081565b600081600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040516103959190610bc5565b60405180910390a36001905092915050565b60035481565b600081600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015610431576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161042890610d83565b60405180910390fd5b81600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410156104f0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104e790610def565b60405180910390fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461053f9190610e3e565b9250508190555081600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546105959190610e72565b9250508190555081600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546106289190610e3e565b925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8460405161068c9190610bc5565b60405180910390a3600190509392505050565b600260009054906101000a900460ff1681565b80600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546107019190610e72565b92505081905550806003600082825461071a9190610e72565b925050819055508173ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8360405161077f9190610bc5565b60405180910390a35050565b60046020528060005260406000206000915090505481565b600180546107b090610d06565b80601f01602080910402602001604051908101604052809291908181526020018280546107dc90610d06565b80156108295780601f106107fe57610100808354040283529160200191610829565b820191906000526020600020905b81548152906001019060200180831161080c57829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410156108b5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108ac90610d83565b60405180910390fd5b81600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546109049190610e3e565b9250508190555081600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461095a9190610e72565b925050819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516109be9190610bc5565b60405180910390a36001905092915050565b6005602052816000526040600020602052806000526040600020600091509150505481565b600081519050919050565b600082825260208201905092915050565b60005b83811015610a2f578082015181840152602081019050610a14565b60008484015250505050565b6000601f19601f8301169050919050565b6000610a57826109f5565b610a618185610a00565b9350610a71818560208601610a11565b610a7a81610a3b565b840191505092915050565b60006020820190508181036000830152610a9f8184610a4c565b905092915050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610ad782610aac565b9050919050565b610ae781610acc565b8114610af257600080fd5b50565b600081359050610b0481610ade565b92915050565b6000819050919050565b610b1d81610b0a565b8114610b2857600080fd5b50565b600081359050610b3a81610b14565b92915050565b60008060408385031215610b5757610b56610aa7565b5b6000610b6585828601610af5565b9250506020610b7685828601610b2b565b9150509250929050565b60008115159050919050565b610b9581610b80565b82525050565b6000602082019050610bb06000830184610b8c565b92915050565b610bbf81610b0a565b82525050565b6000602082019050610bda6000830184610bb6565b92915050565b600080600060608486031215610bf957610bf8610aa7565b5b6000610c0786828701610af5565b9350506020610c1886828701610af5565b9250506040610c2986828701610b2b565b9150509250925092565b600060ff82169050919050565b610c4981610c33565b82525050565b6000602082019050610c646000830184610c40565b92915050565b600060208284031215610c8057610c7f610aa7565b5b6000610c8e84828501610af5565b91505092915050565b60008060408385031215610cae57610cad610aa7565b5b6000610cbc85828601610af5565b9250506020610ccd85828601610af5565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680610d1e57607f821691505b602082108103610d3157610d30610cd7565b5b50919050565b7f696e73756666696369656e742062616c616e6365000000000000000000000000600082015250565b6000610d6d601483610a00565b9150610d7882610d37565b602082019050919050565b60006020820190508181036000830152610d9c81610d60565b9050919050565b7f6578636565647320616c6c6f77616e6365000000000000000000000000000000600082015250565b6000610dd9601183610a00565b9150610de482610da3565b602082019050919050565b60006020820190508181036000830152610e0881610dcc565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610e4982610b0a565b9150610e5483610b0a565b9250828203905081811115610e6c57610e6b610e0f565b5b92915050565b6000610e7d82610b0a565b9150610e8883610b0a565b9250828201905080821115610ea057610e9f610e0f565b5b9291505056fea264697066735822122041fa693da1c1decf8c3e4932e0c8ae158fb01e9b5107935494ee90fbcdd5f6dc64736f6c63430008180033",
  "linkReferences": {},
  "deployedLinkReferences": {}
}

================
File: cache/solidity-files-cache.json
================
{
  "_format": "hh-sol-cache-2",
  "files": {
    "/Users/dennisonbertram/Develop/ModelContextProtocol/ethers-server/contracts/TestToken.sol": {
      "lastModificationDate": 1736573664417,
      "contentHash": "b37c04f89eeb3d91be4c7e3fa771060d",
      "sourceName": "contracts/TestToken.sol",
      "solcConfig": {
        "version": "0.8.24",
        "settings": {
          "evmVersion": "paris",
          "optimizer": {
            "enabled": false,
            "runs": 200
          },
          "outputSelection": {
            "*": {
              "*": [
                "abi",
                "evm.bytecode",
                "evm.deployedBytecode",
                "evm.methodIdentifiers",
                "metadata"
              ],
              "": [
                "ast"
              ]
            }
          }
        }
      },
      "imports": [],
      "versionPragmas": [
        "^0.8.24"
      ],
      "artifacts": [
        "TestToken"
      ]
    }
  }
}

================
File: contracts/TestToken.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract TestToken {
    string public name = "MyToken";
    string public symbol = "MCP";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        totalSupply = 1000000 * 10**uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, "insufficient balance");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(balanceOf[from] >= value, "insufficient balance");
        require(allowance[from][msg.sender] >= value, "exceeds allowance");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function mint(address to, uint256 value) public {
        balanceOf[to] += value;
        totalSupply += value;
        emit Transfer(address(0), to, value);
    }
}

================
File: examples/erc-standards.ts
================
/**
 * ERC Standards Helpers Examples
 * 
 * This file demonstrates how to use the ERC standard helpers in the MCP Ethers Wallet.
 */

import { EthersService } from '../src/services/ethersService';
import { ethers } from 'ethers';

// Create a provider and signer
const provider = new ethers.JsonRpcProvider(process.env.RPC_URL || 'http://localhost:8545');
const privateKey = process.env.PRIVATE_KEY;
const signer = privateKey ? new ethers.Wallet(privateKey, provider) : undefined;

// Create an instance of EthersService
const ethersService = new EthersService(provider, signer);

// Example addresses and token IDs
const ERC20_TOKEN_ADDRESS = '0x6B175474E89094C44Da98b954EedeAC495271d0F'; // DAI on Ethereum Mainnet
const ERC721_TOKEN_ADDRESS = '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D'; // BAYC on Ethereum Mainnet
const ERC1155_TOKEN_ADDRESS = '0x76BE3b62873462d2142405439777e971754E8E77'; // Parallel Alpha on Ethereum Mainnet
const WALLET_ADDRESS = '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'; // vitalik.eth
const TOKEN_ID = '1';

async function runExamples() {
  console.log('Running ERC Standards Helpers Examples...\n');

  try {
    // ERC20 Examples
    console.log('=== ERC20 Examples ===');
    
    // Get token info
    console.log('Getting ERC20 token info...');
    const tokenInfo = await ethersService.getERC20TokenInfo(ERC20_TOKEN_ADDRESS);
    console.log('Token Info:', tokenInfo);
    
    // Get token balance
    console.log('\nGetting ERC20 balance...');
    const balance = await ethersService.getERC20Balance(ERC20_TOKEN_ADDRESS, WALLET_ADDRESS);
    console.log(`Balance of ${WALLET_ADDRESS}: ${balance} ${tokenInfo.symbol}`);

    // ERC721 Examples
    console.log('\n\n=== ERC721 Examples ===');
    
    // Get collection info
    console.log('Getting ERC721 collection info...');
    const collectionInfo = await ethersService.getERC721CollectionInfo(ERC721_TOKEN_ADDRESS);
    console.log('Collection Info:', collectionInfo);
    
    // Get token owner
    console.log('\nGetting ERC721 token owner...');
    try {
      const owner = await ethersService.getERC721Owner(ERC721_TOKEN_ADDRESS, TOKEN_ID);
      console.log(`Owner of token #${TOKEN_ID}: ${owner}`);
    } catch (error) {
      console.log(`Error getting owner: ${error.message}`);
    }
    
    // Get tokens of owner
    console.log('\nGetting ERC721 tokens of owner...');
    try {
      const tokens = await ethersService.getERC721TokensOfOwner(ERC721_TOKEN_ADDRESS, WALLET_ADDRESS, false);
      console.log(`${WALLET_ADDRESS} owns ${tokens.length} tokens from collection ${collectionInfo.name}`);
      if (tokens.length > 0) {
        console.log('First token:', tokens[0]);
      }
    } catch (error) {
      console.log(`Error getting tokens: ${error.message}`);
    }

    // ERC1155 Examples
    console.log('\n\n=== ERC1155 Examples ===');
    
    // Get token balance
    console.log('Getting ERC1155 token balance...');
    try {
      const balance = await ethersService.getERC1155Balance(ERC1155_TOKEN_ADDRESS, WALLET_ADDRESS, TOKEN_ID);
      console.log(`Balance of token #${TOKEN_ID}: ${balance}`);
    } catch (error) {
      console.log(`Error getting balance: ${error.message}`);
    }
    
    // Get tokens of owner
    console.log('\nGetting ERC1155 tokens of owner...');
    try {
      const tokens = await ethersService.getERC1155TokensOfOwner(ERC1155_TOKEN_ADDRESS, WALLET_ADDRESS);
      console.log(`${WALLET_ADDRESS} owns ${tokens.length} token types from collection`);
      if (tokens.length > 0) {
        console.log('First token:', tokens[0]);
      }
    } catch (error) {
      console.log(`Error getting tokens: ${error.message}`);
    }

    // If we have a signer, demonstrate write operations
    if (signer) {
      console.log('\n\n=== Write Operations (with signer) ===');
      
      // These operations require a signer with funds
      // Uncomment and modify as needed
      
      /*
      // Transfer ERC20 tokens
      console.log('Transferring ERC20 tokens...');
      const recipient = '0x...'; // Replace with recipient address
      const amount = '0.1'; // Amount in token units
      const tx = await ethersService.transferERC20(ERC20_TOKEN_ADDRESS, recipient, amount);
      console.log('Transaction hash:', tx.hash);
      
      // Transfer ERC721 NFT
      console.log('\nTransferring ERC721 NFT...');
      const nftRecipient = '0x...'; // Replace with recipient address
      const nftId = '123'; // Replace with your NFT ID
      const nftTx = await ethersService.transferERC721(ERC721_TOKEN_ADDRESS, nftRecipient, nftId);
      console.log('Transaction hash:', nftTx.hash);
      
      // Transfer ERC1155 tokens
      console.log('\nTransferring ERC1155 tokens...');
      const tokenRecipient = '0x...'; // Replace with recipient address
      const tokenId = '1'; // Replace with your token ID
      const tokenAmount = '1'; // Amount to transfer
      const tokenTx = await ethersService.safeTransferERC1155(
        ERC1155_TOKEN_ADDRESS, 
        await signer.getAddress(), 
        tokenRecipient, 
        tokenId, 
        tokenAmount
      );
      console.log('Transaction hash:', tokenTx.hash);
      */
    }

  } catch (error) {
    console.error('Error running examples:', error);
  }
}

// Run the examples
runExamples().catch(console.error);

================
File: src/config/config.ts
================
import { z } from 'zod';
import { config as loadEnv } from 'dotenv';

// Load environment variables
loadEnv();

// Define configuration schema
const configSchema = z.object({
  ALCHEMY_API_KEY: z.string().optional(),
  PRIVATE_KEY: z.string().optional(),
  DEFAULT_NETWORK: z.string().default('mainnet'),
  SERVER_PORT: z.coerce.number().default(3000),
  LOG_LEVEL: z.enum(['error', 'warn', 'info', 'debug']).default('info'),
});

// Parse and validate configuration
export type Config = z.infer<typeof configSchema>;

// Attempt to parse environment variables
const result = configSchema.safeParse(process.env);

// Handle validation errors
if (!result.success) {
  console.error('Invalid configuration:', result.error.format());
  process.exit(1);
}

// Export the validated config
export const config: Config = result.data;

// Utility function to check if a wallet is configured
export function isWalletConfigured(): boolean {
  return Boolean(config.PRIVATE_KEY);
}

// Utility function to get configuration status
export function getConfigStatus(): Record<string, boolean> {
  return {
    hasAlchemyKey: Boolean(config.ALCHEMY_API_KEY),
    hasWallet: isWalletConfigured(),
    // Add other configuration status as needed
  };
}

================
File: src/config/networkList.ts
================
export type NetworkInfo = {
  currency: string;
  chainId: number;
  RPC: string;
  explorer: string;
}

export type NetworkName = keyof typeof networkList;

export const networkList = {
  "Ethereum": {
    "currency": "ETH",
    "chainId": 1,
    "RPC": "https://eth-mainnet.g.alchemy.com/v2/",
    "explorer": ""
  },
  "Polygon PoS": {
    "currency": "MATIC",
    "chainId": 137,
    "RPC": "https://polygon-mainnet.g.alchemy.com/v2/",
    "explorer": ""
  },
  "Arbitrum": {
    "currency": "ETH",
    "chainId": 42161,
    "RPC": "https://arb-mainnet.g.alchemy.com/v2/",
    "explorer": ""
  },
  "Arbitrum Nova": {
    "currency": "ETH",
    "chainId": 42170,
    "RPC": "https://arbnova-mainnet.g.alchemy.com/v2/",
    "explorer": ""
  },
  "Optimism": {
    "currency": "ETH",
    "chainId": 10,
    "RPC": "https://opt-mainnet.g.alchemy.com/v2/",
    "explorer": ""
  },
  "Avalanche C-Chain": {
    "currency": "AVAX",
    "chainId": 43114,
    "RPC": "https://avax-mainnet.g.alchemy.com/v2/",
    "explorer": ""
  },
  "Base": {
    "currency": "ETH",
    "chainId": 8453,
    "RPC": "https://base-mainnet.g.alchemy.com/v2/",
    "explorer": ""
  },
  "Polygon zkEVM": {
    "currency": "ETH",
    "chainId": 1101,
    "RPC": "https://polygonzkevm-mainnet.g.alchemy.com/v2/",
    "explorer": ""
  },
  "Linea": {
    "currency": "ETH",
    "chainId": 59144,
    "RPC": "https://linea-mainnet.g.alchemy.com/v2/",
    "explorer": ""
  },
  "BNB Smart Chain": {
    "currency": "BNB",
    "chainId": 56,
    "RPC": "https://bnb-mainnet.g.alchemy.com/v2/",
    "explorer": ""
  },
  "Scroll": {
    "currency": "ETH",
    "chainId": 534352,
    "RPC": "https://scroll-mainnet.g.alchemy.com/v2/",
    "explorer": ""
  }
} as const;

================
File: src/config/networks.ts
================
export type DefaultProvider =
  | "Ethereum"
  | "Polygon PoS"
  | "Arbitrum"
  | "Arbitrum Nova"
  | "Optimism"
  | "Avalanche C-Chain"
  | "Gnosis"
  | "CrossFi"
  | "Berachain"
  | "Lens"
  | "World Chain"
  | "Base"
  | "Unichain"
  | "Geist"
  | "ZKsync"
  | "Abstract"
  | "Polygon zkEVM"
  | "Blast"
  | "Linea"
  | "Flow"
  | "Soneium"
  | "Fantom Opera"
  | "BNB Smart Chain"
  | "opBNB Chain"
  | "Rootstock"
  | "Lumia"
  | "ZetaChain"
  | "Mantle"
  | "Metis"
  | "Astar"
  | "Holeky"
  | "Scroll";

export const DEFAULT_PROVIDERS: DefaultProvider[] = [
  "Ethereum",
  "Polygon PoS",
  "Arbitrum",
  "Arbitrum Nova",
  "Optimism",
  "Avalanche C-Chain",
  "Gnosis",
  "CrossFi",
  "Berachain",
  "Lens",
  "World Chain",
  "Base",
  "Unichain",
  "Geist",
  "ZKsync",
  "Abstract",
  "Polygon zkEVM",
  "Blast",
  "Linea",
  "Flow",
  "Soneium",
  "Fantom Opera",
  "BNB Smart Chain",
  "opBNB Chain",
  "Rootstock",
  "Lumia",
  "ZetaChain",
  "Mantle",
  "Metis",
  "Astar",
  "Holeky",
  "Scroll",
];

================
File: src/services/erc/constants.ts
================
/**
 * @file ERC Standards Constants
 * @version 1.0.0
 * @lastModified 2024-06-07
 * 
 * Standard ABIs and constants for ERC token standards
 */

// Minimal ABI for ERC20 tokens - includes only the methods we need
export const ERC20_ABI = [
  // Read-only functions
  'function name() view returns (string)',
  'function symbol() view returns (string)',
  'function decimals() view returns (uint8)',
  'function totalSupply() view returns (uint256)',
  'function balanceOf(address owner) view returns (uint256)',
  'function allowance(address owner, address spender) view returns (uint256)',
  
  // State-changing functions
  'function transfer(address to, uint256 value) returns (bool)',
  'function approve(address spender, uint256 value) returns (bool)',
  'function transferFrom(address from, address to, uint256 value) returns (bool)',
  
  // Events
  'event Transfer(address indexed from, address indexed to, uint256 value)',
  'event Approval(address indexed owner, address indexed spender, uint256 value)'
];

// Minimal ABI for ERC721 tokens
export const ERC721_ABI = [
  // Read-only functions
  'function name() view returns (string)',
  'function symbol() view returns (string)',
  'function tokenURI(uint256 tokenId) view returns (string)',
  'function balanceOf(address owner) view returns (uint256)',
  'function ownerOf(uint256 tokenId) view returns (address)',
  'function getApproved(uint256 tokenId) view returns (address)',
  'function isApprovedForAll(address owner, address operator) view returns (bool)',
  'function supportsInterface(bytes4 interfaceId) view returns (bool)',
  
  // State-changing functions
  'function approve(address to, uint256 tokenId)',
  'function setApprovalForAll(address operator, bool approved)',
  'function transferFrom(address from, address to, uint256 tokenId)',
  'function safeTransferFrom(address from, address to, uint256 tokenId)',
  'function safeTransferFrom(address from, address to, uint256 tokenId, bytes data)',
  
  // Events
  'event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)',
  'event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)',
  'event ApprovalForAll(address indexed owner, address indexed operator, bool approved)'
];

// Minimal ABI for ERC1155 tokens
export const ERC1155_ABI = [
  // Read-only functions
  'function balanceOf(address account, uint256 id) view returns (uint256)',
  'function balanceOfBatch(address[] accounts, uint256[] ids) view returns (uint256[])',
  'function isApprovedForAll(address account, address operator) view returns (bool)',
  'function uri(uint256 id) view returns (string)',
  'function supportsInterface(bytes4 interfaceId) view returns (bool)',
  
  // State-changing functions
  'function setApprovalForAll(address operator, bool approved)',
  'function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data)',
  'function safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data)',
  
  // Events
  'event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)',
  'event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)',
  'event ApprovalForAll(address indexed account, address indexed operator, bool approved)',
  'event URI(string value, uint256 indexed id)'
];

// Interface IDs for supportsInterface checks
export const INTERFACE_IDS = {
  ERC165: '0x01ffc9a7',
  ERC721: '0x80ac58cd',
  ERC721Metadata: '0x5b5e139f',
  ERC721Enumerable: '0x780e9d63',
  ERC1155: '0xd9b67a26',
  ERC1155MetadataURI: '0x0e89341c'
};

// Standard cache keys
export const CACHE_KEYS = {
  ERC20_INFO: 'erc20:info',
  ERC20_BALANCE: 'erc20:balance',
  ERC20_ALLOWANCE: 'erc20:allowance',
  ERC721_INFO: 'erc721:info',
  ERC721_OWNER: 'erc721:owner',
  ERC721_TOKEN_URI: 'erc721:tokenUri',
  ERC721_METADATA: 'erc721:metadata',
  ERC1155_URI: 'erc1155:uri',
  ERC1155_METADATA: 'erc1155:metadata',
  ERC1155_BALANCE: 'erc1155:balance'
};

================
File: src/services/erc/erc1155.test.ts.md
================
/**
 * @file ERC1155 Helper Tests
 */

import { ethers } from 'ethers';
import { EthersService } from '../ethersService.js';
import * as erc1155 from './erc1155.js';
import { ERC1155Error, UnauthorizedTokenActionError } from './errors.js';
import { balanceCache, contractCache, ensCache } from '../../utils/cache.js';

// Mock EthersService
jest.mock('../ethersService');

// Mock cache
jest.mock('../../utils/cache', () => ({
  balanceCache: {
    get: jest.fn(),
    set: jest.fn(),
    delete: jest.fn(),
  },
  contractCache: {
    get: jest.fn(),
    set: jest.fn(),
  },
  ensCache: {
    get: jest.fn(),
    set: jest.fn(),
  },
}));

// Mock metrics and logger
jest.mock('../../utils/metrics', () => ({
  metrics: {
    incrementCounter: jest.fn(),
  },
  timeAsync: jest.fn((name, fn) => fn()),
}));

jest.mock('../../utils/logger', () => ({
  logger: {
    debug: jest.fn(),
  },
}));

// Mock rate limiter
jest.mock('../../utils/rateLimiter', () => ({
  rateLimiter: {
    consume: jest.fn().mockReturnValue(true),
  },
}));

// Mock fetch for metadata
global.fetch = jest.fn().mockImplementation(() => 
  Promise.resolve({
    ok: true,
    json: () => Promise.resolve({
      name: 'Test Token',
      description: 'Test Description',
      image: 'https://example.com/image.png',
      attributes: [
        { trait_type: 'Background', value: 'Blue' },
      ],
    }),
  })
) as jest.Mock;

describe('ERC1155 Helpers', () => {
  let mockEthersService: jest.Mocked<EthersService>;
  let mockProvider: jest.Mocked<ethers.Provider>;
  let mockSigner: jest.Mocked<ethers.Signer>;
  let mockContract: jest.Mocked<ethers.Contract>;
  
  const TEST_CONTRACT_ADDRESS = '0x1234567890123456789012345678901234567890';
  const TEST_OWNER_ADDRESS = '0xabcdefabcdefabcdefabcdefabcdefabcdefabcd';
  const TEST_RECIPIENT_ADDRESS = '0x9876543210987654321098765432109876543210';
  const TEST_TOKEN_ID = '123';
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Create mock provider
    mockProvider = {
      getCode: jest.fn().mockResolvedValue('0x123'),
    } as unknown as jest.Mocked<ethers.Provider>;
    
    // Create mock signer
    mockSigner = {
      getAddress: jest.fn().mockResolvedValue(TEST_OWNER_ADDRESS),
    } as unknown as jest.Mocked<ethers.Signer>;
    
    // Create mock contract
    mockContract = {
      balanceOf: jest.fn().mockResolvedValue(ethers.toBigInt(50)),
      balanceOfBatch: jest.fn().mockResolvedValue([
        ethers.toBigInt(50),
        ethers.toBigInt(100),
      ]),
      uri: jest.fn().mockResolvedValue('https://example.com/token/{id}'),
      isApprovedForAll: jest.fn().mockResolvedValue(false),
      setApprovalForAll: jest.fn().mockResolvedValue({ hash: '0xabcd', wait: jest.fn() }),
      safeTransferFrom: jest.fn().mockResolvedValue({ hash: '0xabcd', wait: jest.fn() }),
      safeBatchTransferFrom: jest.fn().mockResolvedValue({ hash: '0xabcd', wait: jest.fn() }),
      supportsInterface: jest.fn().mockImplementation((interfaceId) => {
        return Promise.resolve(interfaceId === '0xd9b67a26'); // True for ERC1155
      }),
      filters: {
        TransferSingle: jest.fn().mockReturnValue({ address: TEST_CONTRACT_ADDRESS }),
        TransferBatch: jest.fn().mockReturnValue({ address: TEST_CONTRACT_ADDRESS }),
      },
      queryFilter: jest.fn().mockImplementation((filter) => {
        if (filter.address === TEST_CONTRACT_ADDRESS) {
          if (filter === mockContract.filters.TransferSingle()) {
            return Promise.resolve([
              { args: [null, null, TEST_OWNER_ADDRESS, ethers.toBigInt(123), ethers.toBigInt(1)] },
              { args: [null, null, TEST_OWNER_ADDRESS, ethers.toBigInt(456), ethers.toBigInt(10)] },
            ]);
          } else if (filter === mockContract.filters.TransferBatch()) {
            return Promise.resolve([
              {
                args: [
                  null,
                  null,
                  TEST_OWNER_ADDRESS,
                  [ethers.toBigInt(789), ethers.toBigInt(101)],
                  [ethers.toBigInt(5), ethers.toBigInt(2)]
                ]
              }
            ]);
          }
        }
        return Promise.resolve([]);
      }),
    } as unknown as jest.Mocked<ethers.Contract>;
    
    // Create mock EthersService
    mockEthersService = {
      getProvider: jest.fn().mockReturnValue(mockProvider),
      getSigner: jest.fn().mockReturnValue(mockSigner),
    } as unknown as jest.Mocked<EthersService>;
    
    // Mock ethers.Contract constructor
    jest.spyOn(ethers, 'Contract').mockImplementation(() => mockContract);
  });
  
  describe('balanceOf', () => {
    it('should return balance from cache if available', async () => {
      const cachedBalance = '50';
      
      (balanceCache.get as jest.Mock).mockReturnValue(cachedBalance);
      
      const result = await erc1155.balanceOf(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_OWNER_ADDRESS,
        TEST_TOKEN_ID
      );
      
      expect(result).toEqual(cachedBalance);
      expect(balanceCache.get).toHaveBeenCalled();
      expect(mockEthersService.getProvider).not.toHaveBeenCalled();
    });
    
    it('should fetch balance from blockchain if not in cache', async () => {
      (balanceCache.get as jest.Mock).mockReturnValue(null);
      
      const result = await erc1155.balanceOf(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_OWNER_ADDRESS,
        TEST_TOKEN_ID
      );
      
      expect(result).toEqual('50');
      
      expect(mockEthersService.getProvider).toHaveBeenCalled();
      expect(balanceCache.set).toHaveBeenCalled();
      expect(mockContract.balanceOf).toHaveBeenCalledWith(TEST_OWNER_ADDRESS, TEST_TOKEN_ID);
    });
  });
  
  describe('balanceOfBatch', () => {
    it('should fetch balances for multiple token IDs', async () => {
      const ownerAddresses = [TEST_OWNER_ADDRESS, TEST_OWNER_ADDRESS];
      const tokenIds = ['123', '456'];
      
      const result = await erc1155.balanceOfBatch(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        ownerAddresses,
        tokenIds
      );
      
      expect(result).toEqual(['50', '100']);
      expect(mockContract.balanceOfBatch).toHaveBeenCalledWith(ownerAddresses, tokenIds);
    });
    
    it('should throw error if arrays have different lengths', async () => {
      const ownerAddresses = [TEST_OWNER_ADDRESS, TEST_OWNER_ADDRESS];
      const tokenIds = ['123'];
      
      await expect(
        erc1155.balanceOfBatch(
          mockEthersService,
          TEST_CONTRACT_ADDRESS,
          ownerAddresses,
          tokenIds
        )
      ).rejects.toThrow(ERC1155Error);
    });
  });
  
  describe('getURI', () => {
    it('should return URI from cache if available', async () => {
      const cachedURI = 'https://cached.example.com/token/{id}';
      
      (ensCache.get as jest.Mock).mockReturnValue(cachedURI);
      
      const result = await erc1155.getURI(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_TOKEN_ID
      );
      
      expect(result).toEqual(cachedURI);
      expect(ensCache.get).toHaveBeenCalled();
      expect(mockEthersService.getProvider).not.toHaveBeenCalled();
    });
    
    it('should fetch URI from blockchain if not in cache', async () => {
      (ensCache.get as jest.Mock).mockReturnValue(null);
      
      const result = await erc1155.getURI(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_TOKEN_ID
      );
      
      expect(result).toEqual('https://example.com/token/{id}');
      
      expect(mockEthersService.getProvider).toHaveBeenCalled();
      expect(ensCache.set).toHaveBeenCalled();
      expect(mockContract.uri).toHaveBeenCalledWith(TEST_TOKEN_ID);
    });
  });
  
  describe('getMetadata', () => {
    it('should return metadata from cache if available', async () => {
      const cachedMetadata = {
        name: 'Cached Token',
        description: 'Cached Description',
      };
      
      (contractCache.get as jest.Mock).mockReturnValue(cachedMetadata);
      
      const result = await erc1155.getMetadata(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_TOKEN_ID
      );
      
      expect(result).toEqual(cachedMetadata);
      expect(contractCache.get).toHaveBeenCalled();
      expect(mockEthersService.getProvider).not.toHaveBeenCalled();
    });
    
    it('should fetch and parse metadata if not in cache', async () => {
      (contractCache.get as jest.Mock).mockReturnValue(null);
      (ensCache.get as jest.Mock).mockReturnValue(null);
      
      const result = await erc1155.getMetadata(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_TOKEN_ID
      );
      
      expect(result).toEqual({
        name: 'Test Token',
        description: 'Test Description',
        image: 'https://example.com/image.png',
        attributes: [
          { trait_type: 'Background', value: 'Blue' },
        ],
      });
      
      expect(mockEthersService.getProvider).toHaveBeenCalled();
      expect(contractCache.set).toHaveBeenCalled();
      expect(mockContract.uri).toHaveBeenCalled();
      expect(global.fetch).toHaveBeenCalled();
    });
  });
  
  describe('safeTransferFrom', () => {
    it('should transfer tokens successfully when caller is owner', async () => {
      (balanceCache.get as jest.Mock).mockReturnValue('50');
      
      const result = await erc1155.safeTransferFrom(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_OWNER_ADDRESS,
        TEST_RECIPIENT_ADDRESS,
        TEST_TOKEN_ID,
        '10'
      );
      
      expect(result).toEqual({ hash: '0xabcd', wait: expect.any(Function) });
      expect(mockContract.safeTransferFrom).toHaveBeenCalledWith(
        TEST_OWNER_ADDRESS,
        TEST_RECIPIENT_ADDRESS,
        TEST_TOKEN_ID,
        '10',
        '0x',
        {}
      );
      expect(balanceCache.delete).toHaveBeenCalledTimes(2);
    });
    
    it('should throw UnauthorizedTokenActionError if caller is not owner or approved', async () => {
      (balanceCache.get as jest.Mock).mockReturnValue('50');
      
      // Set a different sender than the signer
      const differentSender = '0x0123456789012345678901234567890123456789';
      
      await expect(
        erc1155.safeTransferFrom(
          mockEthersService,
          TEST_CONTRACT_ADDRESS,
          differentSender, // Not the signer
          TEST_RECIPIENT_ADDRESS,
          TEST_TOKEN_ID,
          '10'
        )
      ).rejects.toThrow(UnauthorizedTokenActionError);
    });
    
    it('should throw error if balance is insufficient', async () => {
      (balanceCache.get as jest.Mock).mockReturnValue('5');
      
      await expect(
        erc1155.safeTransferFrom(
          mockEthersService,
          TEST_CONTRACT_ADDRESS,
          TEST_OWNER_ADDRESS,
          TEST_RECIPIENT_ADDRESS,
          TEST_TOKEN_ID,
          '10'
        )
      ).rejects.toThrow(ERC1155Error);
    });
  });
  
  describe('getUserTokens', () => {
    it('should get tokens for specified token IDs', async () => {
      const mockTokenIds = ['123', '456', '789'];
      
      // Mock balanceOf to return different values for different tokens
      mockContract.balanceOf.mockImplementation((owner, tokenId) => {
        if (tokenId === '123') return ethers.toBigInt(5);
        if (tokenId === '456') return ethers.toBigInt(10);
        if (tokenId === '789') return ethers.toBigInt(0); // Zero balance
        return ethers.toBigInt(0);
      });
      
      const result = await erc1155.getUserTokens(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_OWNER_ADDRESS,
        mockTokenIds
      );
      
      // Should only include tokens with non-zero balance
      expect(result.length).toBe(2);
      expect(result[0].tokenId).toBe('123');
      expect(result[0].balance).toBe('5');
      expect(result[1].tokenId).toBe('456');
      expect(result[1].balance).toBe('10');
    });
    
    it('should discover tokens from events if no token IDs provided', async () => {
      // For TokenIds 123, 456, 789, 101
      mockContract.balanceOf.mockImplementation((owner, tokenId) => {
        if (tokenId === '123') return ethers.toBigInt(1);
        if (tokenId === '456') return ethers.toBigInt(10);
        if (tokenId === '789') return ethers.toBigInt(5);
        if (tokenId === '101') return ethers.toBigInt(2);
        return ethers.toBigInt(0);
      });
      
      const result = await erc1155.getUserTokens(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_OWNER_ADDRESS
      );
      
      // Should include all tokens with non-zero balance from events
      expect(result.length).toBe(4);
      
      // Token IDs might come in different order, so check they are all included
      const tokenIds = result.map(token => token.tokenId);
      expect(tokenIds).toContain('123');
      expect(tokenIds).toContain('456');
      expect(tokenIds).toContain('789');
      expect(tokenIds).toContain('101');
      
      // Check balances
      const tokenIdToBalance = new Map(result.map(token => [token.tokenId, token.balance]));
      expect(tokenIdToBalance.get('123')).toBe('1');
      expect(tokenIdToBalance.get('456')).toBe('10');
      expect(tokenIdToBalance.get('789')).toBe('5');
      expect(tokenIdToBalance.get('101')).toBe('2');
    });
  });
});

================
File: src/services/erc/erc1155.ts
================
/**
 * @file ERC1155 Multi-Token Helpers
 * @version 1.0.0
 * @lastModified 2024-06-07
 * 
 * Helper functions for interacting with ERC1155 multi-tokens
 */

import { ethers } from 'ethers';
import { EthersService } from '../ethersService.js';
import { ERC1155_ABI, CACHE_KEYS } from './constants.js';
import { ERC1155TokenInfo, NFTMetadata, TokenOperationOptions } from './types.js';
import {
  ERC1155Error,
  TokenNotFoundError,
  UnauthorizedTokenActionError,
  TokenMetadataError,
  handleTokenError
} from './errors.js';
import { createTokenCacheKey, fetchMetadata } from './utils.js';
import { balanceCache, contractCache, ensCache } from '../../utils/cache.js';
import { logger } from '../../utils/logger.js';
import { metrics, timeAsync } from '../../utils/metrics.js';
import { rateLimiter } from '../../utils/rateLimiter.js';

/**
 * Get token balance for a specific token ID
 * 
 * @param ethersService EthersService instance
 * @param contractAddress ERC1155 contract address
 * @param ownerAddress Owner address to check
 * @param tokenId Token ID to check balance
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with token balance as string
 */
export async function balanceOf(
  ethersService: EthersService,
  contractAddress: string,
  ownerAddress: string,
  tokenId: string | number,
  provider?: string,
  chainId?: number
): Promise<string> {
  metrics.incrementCounter('erc1155.balanceOf');
  
  return timeAsync('erc1155.balanceOf', async () => {
    try {
      // Create cache key
      const cacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC1155_BALANCE,
        contractAddress,
        ownerAddress,
        tokenId,
        chainId
      );
      
      // Check cache first
      const cachedBalance = balanceCache.get(cacheKey);
      if (cachedBalance) {
        return cachedBalance;
      }
      
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Create contract instance
      const contract = new ethers.Contract(contractAddress, ERC1155_ABI, ethersProvider);
      
      // Get balance
      const balance = await contract.balanceOf(ownerAddress, tokenId);
      const balanceStr = balance.toString();
      
      // Cache result for future use (30 second TTL)
      balanceCache.set(cacheKey, balanceStr, { ttl: 30000 });
      
      return balanceStr;
    } catch (error) {
      logger.debug('Error getting ERC1155 balance', { contractAddress, ownerAddress, tokenId, error });
      throw handleTokenError(error, 'Failed to get token balance');
    }
  });
}

/**
 * Get token balances for multiple token IDs at once
 * 
 * @param ethersService EthersService instance
 * @param contractAddress ERC1155 contract address
 * @param ownerAddresses Array of owner addresses
 * @param tokenIds Array of token IDs
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with array of token balances
 */
export async function balanceOfBatch(
  ethersService: EthersService,
  contractAddress: string,
  ownerAddresses: string[],
  tokenIds: (string | number)[],
  provider?: string,
  chainId?: number
): Promise<string[]> {
  metrics.incrementCounter('erc1155.balanceOfBatch');
  
  return timeAsync('erc1155.balanceOfBatch', async () => {
    try {
      // Validate input lengths
      if (ownerAddresses.length !== tokenIds.length) {
        throw new ERC1155Error(
          'Owner addresses and token IDs arrays must have the same length'
        );
      }
      
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Create contract instance
      const contract = new ethers.Contract(contractAddress, ERC1155_ABI, ethersProvider);
      
      // Get balances
      const balances = await contract.balanceOfBatch(ownerAddresses, tokenIds);
      
      // Convert to strings
      return balances.map((balance: bigint) => balance.toString());
    } catch (error) {
      logger.debug('Error getting ERC1155 batch balances', { contractAddress, error });
      throw handleTokenError(error, 'Failed to get token balances');
    }
  });
}

/**
 * Get the URI for a specific token ID
 * 
 * @param ethersService EthersService instance
 * @param contractAddress ERC1155 contract address
 * @param tokenId Token ID to get URI for
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with token URI
 */
export async function getURI(
  ethersService: EthersService,
  contractAddress: string,
  tokenId: string | number,
  provider?: string,
  chainId?: number
): Promise<string> {
  metrics.incrementCounter('erc1155.getURI');
  
  return timeAsync('erc1155.getURI', async () => {
    try {
      // Create cache key
      const cacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC1155_URI,
        contractAddress,
        tokenId,
        chainId
      );
      
      // Check cache first
      const cachedURI = ensCache.get(cacheKey);
      if (cachedURI) {
        return cachedURI;
      }
      
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Create contract instance
      const contract = new ethers.Contract(contractAddress, ERC1155_ABI, ethersProvider);
      
      // Get token URI
      const uri = await contract.uri(tokenId);
      
      // Cache result for future use (1 hour TTL)
      ensCache.set(cacheKey, uri, { ttl: 3600000 });
      
      return uri;
    } catch (error) {
      logger.debug('Error getting ERC1155 URI', { contractAddress, tokenId, error });
      throw handleTokenError(error, 'Failed to get token URI');
    }
  });
}

/**
 * Get metadata for a specific token ID
 * 
 * @param ethersService EthersService instance
 * @param contractAddress ERC1155 contract address
 * @param tokenId Token ID to get metadata for
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with token metadata
 */
export async function getMetadata(
  ethersService: EthersService,
  contractAddress: string,
  tokenId: string | number,
  provider?: string,
  chainId?: number
): Promise<NFTMetadata> {
  metrics.incrementCounter('erc1155.getMetadata');
  
  return timeAsync('erc1155.getMetadata', async () => {
    try {
      // Create cache key
      const cacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC1155_METADATA,
        contractAddress,
        tokenId,
        chainId
      );
      
      // Check cache first
      const cachedMetadata = contractCache.get(cacheKey);
      if (cachedMetadata) {
        return cachedMetadata as NFTMetadata;
      }
      
      // Get token URI
      const uri = await getURI(ethersService, contractAddress, tokenId, provider, chainId);
      
      // Fetch and parse metadata
      const metadata = await fetchMetadata(uri, contractAddress, tokenId);
      
      // Cache result for future use (1 hour TTL)
      contractCache.set(cacheKey, metadata, { ttl: 3600000 });
      
      return metadata;
    } catch (error) {
      logger.debug('Error getting ERC1155 metadata', { contractAddress, tokenId, error });
      
      // Handle metadata parsing errors
      if (!(error instanceof TokenMetadataError)) {
        throw new TokenMetadataError(contractAddress, tokenId, undefined, {
          originalError: error instanceof Error ? error.message : String(error)
        });
      }
      
      throw error;
    }
  });
}

/**
 * Check if an operator is approved for all tokens
 * 
 * @param ethersService EthersService instance
 * @param contractAddress ERC1155 contract address
 * @param ownerAddress Owner address
 * @param operatorAddress Operator address to check
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with approval status
 */
export async function isApprovedForAll(
  ethersService: EthersService,
  contractAddress: string,
  ownerAddress: string,
  operatorAddress: string,
  provider?: string,
  chainId?: number
): Promise<boolean> {
  metrics.incrementCounter('erc1155.isApprovedForAll');
  
  return timeAsync('erc1155.isApprovedForAll', async () => {
    try {
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Create contract instance
      const contract = new ethers.Contract(contractAddress, ERC1155_ABI, ethersProvider);
      
      // Check approval
      const isApproved = await contract.isApprovedForAll(ownerAddress, operatorAddress);
      
      return isApproved;
    } catch (error) {
      logger.debug('Error checking ERC1155 approval', { contractAddress, ownerAddress, operatorAddress, error });
      throw handleTokenError(error, 'Failed to check token approval status');
    }
  });
}

/**
 * Set approval for an operator to manage all tokens
 * 
 * @param ethersService EthersService instance
 * @param contractAddress ERC1155 contract address
 * @param operatorAddress Operator address to approve
 * @param approved Approval status to set
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @param options Optional transaction options
 * @returns Promise with transaction response
 */
export async function setApprovalForAll(
  ethersService: EthersService,
  contractAddress: string,
  operatorAddress: string,
  approved: boolean,
  provider?: string,
  chainId?: number,
  options: TokenOperationOptions = {}
): Promise<ethers.TransactionResponse> {
  metrics.incrementCounter('erc1155.setApprovalForAll');
  
  return timeAsync('erc1155.setApprovalForAll', async () => {
    try {
      // Get signer from ethers service
      const signer = ethersService['getSigner'](provider, chainId);
      
      // Create contract instance with signer
      const contractWithSigner = new ethers.Contract(contractAddress, ERC1155_ABI, signer);
      
      // Prepare transaction overrides
      const overrides: ethers.Overrides = {};
      if (options.gasLimit) overrides.gasLimit = options.gasLimit;
      if (options.gasPrice) overrides.gasPrice = options.gasPrice;
      if (options.maxFeePerGas) overrides.maxFeePerGas = options.maxFeePerGas;
      if (options.maxPriorityFeePerGas) overrides.maxPriorityFeePerGas = options.maxPriorityFeePerGas;
      if (options.nonce !== undefined) overrides.nonce = options.nonce;
      
      // Set approval
      const tx = await contractWithSigner.setApprovalForAll(operatorAddress, approved, overrides);
      
      return tx;
    } catch (error) {
      logger.debug('Error setting ERC1155 approval', { contractAddress, operatorAddress, approved, error });
      throw handleTokenError(error, 'Failed to set token approval');
    }
  });
}

/**
 * Safely transfer tokens to another address
 * 
 * @param ethersService EthersService instance
 * @param contractAddress ERC1155 contract address
 * @param fromAddress Sender address
 * @param toAddress Recipient address
 * @param tokenId Token ID to transfer
 * @param amount Amount to transfer
 * @param data Additional data to include with the transfer
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @param options Optional transaction options
 * @returns Promise with transaction response
 */
export async function safeTransferFrom(
  ethersService: EthersService,
  contractAddress: string,
  fromAddress: string,
  toAddress: string,
  tokenId: string | number,
  amount: string,
  data: string = '0x',
  provider?: string,
  chainId?: number,
  options: TokenOperationOptions = {}
): Promise<ethers.TransactionResponse> {
  metrics.incrementCounter('erc1155.safeTransferFrom');
  
  return timeAsync('erc1155.safeTransferFrom', async () => {
    try {
      // Check rate limiting for write operations
      const identity = `${contractAddress}:transfer`;
      if (!rateLimiter.consume('transaction', identity)) {
        throw new ERC1155Error('Rate limit exceeded for token transfers');
      }
      
      // Get provider and signer from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      const signer = ethersService['getSigner'](provider, chainId);
      const signerAddress = await signer.getAddress();
      
      // Verify ownership and approval
      if (fromAddress.toLowerCase() !== signerAddress.toLowerCase()) {
        const isApproved = await isApprovedForAll(
          ethersService,
          contractAddress,
          fromAddress,
          signerAddress,
          provider,
          chainId
        );
        
        if (!isApproved) {
          throw new UnauthorizedTokenActionError(
            'Not authorized to transfer tokens from this address'
          );
        }
      }
      
      // Check balance
      const balance = BigInt(await balanceOf(
        ethersService,
        contractAddress,
        fromAddress,
        tokenId,
        provider,
        chainId
      ));
      
      const amountBigInt = BigInt(amount);
      
      if (balance < amountBigInt) {
        throw new ERC1155Error(
          `Insufficient balance for token ID ${tokenId}. Required: ${amount}, Available: ${balance.toString()}`
        );
      }
      
      // Create contract instance with signer
      const contractWithSigner = new ethers.Contract(contractAddress, ERC1155_ABI, signer);
      
      // Prepare transaction overrides
      const overrides: ethers.Overrides = {};
      if (options.gasLimit) overrides.gasLimit = options.gasLimit;
      if (options.gasPrice) overrides.gasPrice = options.gasPrice;
      if (options.maxFeePerGas) overrides.maxFeePerGas = options.maxFeePerGas;
      if (options.maxPriorityFeePerGas) overrides.maxPriorityFeePerGas = options.maxPriorityFeePerGas;
      if (options.nonce !== undefined) overrides.nonce = options.nonce;
      if (options.value) overrides.value = options.value;
      
      // Send transaction
      const tx = await contractWithSigner.safeTransferFrom(
        fromAddress,
        toAddress,
        tokenId,
        amount,
        data,
        overrides
      );
      
      // Invalidate balance caches
      const fromCacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC1155_BALANCE,
        contractAddress,
        fromAddress,
        tokenId,
        chainId
      );
      
      const toCacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC1155_BALANCE,
        contractAddress,
        toAddress,
        tokenId,
        chainId
      );
      
      balanceCache.delete(fromCacheKey);
      balanceCache.delete(toCacheKey);
      
      return tx;
    } catch (error) {
      logger.debug('Error in ERC1155 safeTransferFrom', {
        contractAddress,
        fromAddress,
        toAddress,
        tokenId,
        amount,
        error
      });
      throw handleTokenError(error, 'Failed to transfer tokens');
    }
  });
}

/**
 * Safely transfer multiple tokens in a batch
 * 
 * @param ethersService EthersService instance
 * @param contractAddress ERC1155 contract address
 * @param fromAddress Sender address
 * @param toAddress Recipient address
 * @param tokenIds Array of token IDs to transfer
 * @param amounts Array of amounts to transfer
 * @param data Additional data to include with the transfer
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @param options Optional transaction options
 * @returns Promise with transaction response
 */
export async function safeBatchTransferFrom(
  ethersService: EthersService,
  contractAddress: string,
  fromAddress: string,
  toAddress: string,
  tokenIds: (string | number)[],
  amounts: string[],
  data: string = '0x',
  provider?: string,
  chainId?: number,
  options: TokenOperationOptions = {}
): Promise<ethers.TransactionResponse> {
  metrics.incrementCounter('erc1155.safeBatchTransferFrom');
  
  return timeAsync('erc1155.safeBatchTransferFrom', async () => {
    try {
      // Validate input lengths
      if (tokenIds.length !== amounts.length) {
        throw new ERC1155Error(
          'Token IDs and amounts arrays must have the same length'
        );
      }
      
      // Check rate limiting for write operations
      const identity = `${contractAddress}:batchTransfer`;
      if (!rateLimiter.consume('transaction', identity)) {
        throw new ERC1155Error('Rate limit exceeded for token transfers');
      }
      
      // Get signer from ethers service
      const signer = ethersService['getSigner'](provider, chainId);
      const signerAddress = await signer.getAddress();
      
      // Verify ownership and approval
      if (fromAddress.toLowerCase() !== signerAddress.toLowerCase()) {
        const isApproved = await isApprovedForAll(
          ethersService,
          contractAddress,
          fromAddress,
          signerAddress,
          provider,
          chainId
        );
        
        if (!isApproved) {
          throw new UnauthorizedTokenActionError(
            'Not authorized to transfer tokens from this address'
          );
        }
      }
      
      // Check balances for all tokens
      const balancePromises = tokenIds.map((tokenId, index) =>
        balanceOf(ethersService, contractAddress, fromAddress, tokenId, provider, chainId)
          .then(balance => {
            const availableBalance = BigInt(balance);
            const requiredAmount = BigInt(amounts[index]);
            
            if (availableBalance < requiredAmount) {
              throw new ERC1155Error(
                `Insufficient balance for token ID ${tokenId}. Required: ${amounts[index]}, Available: ${balance}`
              );
            }
            
            return true;
          })
      );
      
      await Promise.all(balancePromises);
      
      // Create contract instance with signer
      const contractWithSigner = new ethers.Contract(contractAddress, ERC1155_ABI, signer);
      
      // Prepare transaction overrides
      const overrides: ethers.Overrides = {};
      if (options.gasLimit) overrides.gasLimit = options.gasLimit;
      if (options.gasPrice) overrides.gasPrice = options.gasPrice;
      if (options.maxFeePerGas) overrides.maxFeePerGas = options.maxFeePerGas;
      if (options.maxPriorityFeePerGas) overrides.maxPriorityFeePerGas = options.maxPriorityFeePerGas;
      if (options.nonce !== undefined) overrides.nonce = options.nonce;
      if (options.value) overrides.value = options.value;
      
      // Send transaction
      const tx = await contractWithSigner.safeBatchTransferFrom(
        fromAddress,
        toAddress,
        tokenIds,
        amounts,
        data,
        overrides
      );
      
      // Invalidate balance caches for all tokens
      tokenIds.forEach(tokenId => {
        const fromCacheKey = createTokenCacheKey(
          CACHE_KEYS.ERC1155_BALANCE,
          contractAddress,
          fromAddress,
          tokenId,
          chainId
        );
        
        const toCacheKey = createTokenCacheKey(
          CACHE_KEYS.ERC1155_BALANCE,
          contractAddress,
          toAddress,
          tokenId,
          chainId
        );
        
        balanceCache.delete(fromCacheKey);
        balanceCache.delete(toCacheKey);
      });
      
      return tx;
    } catch (error) {
      logger.debug('Error in ERC1155 safeBatchTransferFrom', {
        contractAddress,
        fromAddress,
        toAddress,
        tokenIds,
        amounts,
        error
      });
      throw handleTokenError(error, 'Failed to batch transfer tokens');
    }
  });
}

/**
 * Get all tokens owned by an address with balances and optional metadata
 * 
 * @param ethersService EthersService instance
 * @param contractAddress ERC1155 contract address
 * @param ownerAddress Owner address to check
 * @param tokenIds Optional array of specific token IDs to check (if not provided, will try to discover tokens)
 * @param includeMetadata Whether to include metadata
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with array of token info
 */
export async function getUserTokens(
  ethersService: EthersService,
  contractAddress: string,
  ownerAddress: string,
  tokenIds?: (string | number)[],
  includeMetadata: boolean = false,
  provider?: string,
  chainId?: number
): Promise<ERC1155TokenInfo[]> {
  metrics.incrementCounter('erc1155.getUserTokens');
  
  return timeAsync('erc1155.getUserTokens', async () => {
    try {
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Create contract instance
      const contract = new ethers.Contract(contractAddress, ERC1155_ABI, ethersProvider);
      
      let ownedTokens: ERC1155TokenInfo[] = [];
      
      if (tokenIds && tokenIds.length > 0) {
        // If specific token IDs are provided, check those
        const balancePromises = tokenIds.map(async tokenId => {
          const balance = await balanceOf(ethersService, contractAddress, ownerAddress, tokenId, provider, chainId);
          
          // Only include tokens with a non-zero balance
          if (balance !== '0') {
            return {
              tokenId: tokenId.toString(),
              balance
            };
          }
          
          return null;
        });
        
        const tokensWithBalances = await Promise.all(balancePromises);
        ownedTokens = tokensWithBalances.filter(token => token !== null) as ERC1155TokenInfo[];
      } else {
        // If no token IDs are provided, try to discover tokens using events
        logger.debug('No token IDs provided, discovering tokens from events', { contractAddress, ownerAddress });
        
        // Find transfers to this owner
        const filter = contract.filters.TransferSingle(null, null, ownerAddress);
        const events = await contract.queryFilter(filter);
        
        // Find batch transfers to this owner
        const batchFilter = contract.filters.TransferBatch(null, null, ownerAddress);
        const batchEvents = await contract.queryFilter(batchFilter);
        
        // Map of token IDs to ensure uniqueness
        const tokenMap = new Map<string, boolean>();
        
        // Process single transfers
        events.forEach(event => {
          // Use type guard to safely access args for EventLog
          const isEventLog = 'args' in event;
          
          // Access token ID safely with fallback to topics
          const tokenId = isEventLog ? 
            (event as ethers.EventLog).args[3].toString() : 
            (event.topics && event.topics.length > 3 ? ethers.dataSlice(event.topics[3], 0) : '0');
          
          tokenMap.set(tokenId, true);
        });
        
        // Process batch transfers
        batchEvents.forEach(event => {
          // For batch transfers we need to handle arrays of token IDs
          // Try to safely access the token IDs or parse from topics/data
          const isEventLog = 'args' in event;
          
          // Extract token IDs either from args (if EventLog) or from topics
          const tokenIdsFromArgs = isEventLog ? 
            (event as ethers.EventLog).args[3] : 
            undefined;
          
          const tokenIdsFromTopics = event.topics && event.topics.length > 3 
            ? [ethers.dataSlice(event.topics[3], 0)]
            : [];
          
          const tokenIds = tokenIdsFromArgs || tokenIdsFromTopics;
          
          if (Array.isArray(tokenIds)) {
            tokenIds.forEach((id: any) => {
              const idStr = typeof id === 'bigint' ? id.toString() : 
                            typeof id === 'string' ? id :
                            id?.toString?.() || '0';
              tokenMap.set(idStr, true);
            });
          } else if (tokenIds) {
            // Handle single token ID case
            const idStr = typeof tokenIds === 'bigint' ? tokenIds.toString() : 
                          typeof tokenIds === 'string' ? tokenIds : 
                          tokenIds?.toString?.() || '0';
            tokenMap.set(idStr, true);
          }
        });
        
        // Check balances for discovered tokens
        const discoveredTokenIds = Array.from(tokenMap.keys());
        logger.debug(`Discovered ${discoveredTokenIds.length} potential tokens`, { contractAddress });
        
        const balancePromises = discoveredTokenIds.map(async tokenId => {
          const balance = await balanceOf(ethersService, contractAddress, ownerAddress, tokenId, provider, chainId);
          
          // Only include tokens with a non-zero balance
          if (balance !== '0') {
            return {
              tokenId,
              balance
            };
          }
          
          return null;
        });
        
        const tokensWithBalances = await Promise.all(balancePromises);
        ownedTokens = tokensWithBalances.filter(token => token !== null) as ERC1155TokenInfo[];
      }
      
      // Include metadata if requested
      if (includeMetadata && ownedTokens.length > 0) {
        const metadataPromises = ownedTokens.map(async token => {
          try {
            token.metadata = await getMetadata(
              ethersService,
              contractAddress,
              token.tokenId,
              provider,
              chainId
            );
          } catch (error) {
            // Ignore metadata errors, just return token without metadata
            logger.debug('Error fetching metadata for token', { tokenId: token.tokenId, error });
          }
          return token;
        });
        
        ownedTokens = await Promise.all(metadataPromises);
      }
      
      return ownedTokens;
    } catch (error) {
      logger.debug('Error getting user tokens', { contractAddress, ownerAddress, error });
      throw handleTokenError(error, 'Failed to get user tokens');
    }
  });
}

================
File: src/services/erc/erc20.test.ts.md
================
/**
 * @file ERC20 Helper Tests
 */

import { ethers } from 'ethers';
import { EthersService } from '../ethersService.js';
import * as erc20 from './erc20.js';
import { InsufficientBalanceError, TokenNotFoundError } from './errors.js';
import { balanceCache, contractCache } from '../../utils/cache.js';

// Mock EthersService
jest.mock('../ethersService');

// Mock cache
jest.mock('../../utils/cache', () => ({
  balanceCache: {
    get: jest.fn(),
    set: jest.fn(),
    delete: jest.fn(),
  },
  contractCache: {
    get: jest.fn(),
    set: jest.fn(),
  },
}));

// Mock metrics and logger
jest.mock('../../utils/metrics', () => ({
  metrics: {
    incrementCounter: jest.fn(),
  },
  timeAsync: jest.fn((name, fn) => fn()),
}));

jest.mock('../../utils/logger', () => ({
  logger: {
    debug: jest.fn(),
  },
}));

// Mock rate limiter
jest.mock('../../utils/rateLimiter', () => ({
  rateLimiter: {
    consume: jest.fn().mockReturnValue(true),
  },
}));

describe('ERC20 Helpers', () => {
  let mockEthersService: jest.Mocked<EthersService>;
  let mockProvider: jest.Mocked<ethers.Provider>;
  let mockSigner: jest.Mocked<ethers.Signer>;
  let mockContract: jest.Mocked<ethers.Contract>;
  
  const TEST_TOKEN_ADDRESS = '0x1234567890123456789012345678901234567890';
  const TEST_OWNER_ADDRESS = '0xabcdefabcdefabcdefabcdefabcdefabcdefabcd';
  const TEST_RECIPIENT_ADDRESS = '0x9876543210987654321098765432109876543210';
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Create mock provider
    mockProvider = {
      getCode: jest.fn().mockResolvedValue('0x123'),
    } as unknown as jest.Mocked<ethers.Provider>;
    
    // Create mock signer
    mockSigner = {
      getAddress: jest.fn().mockResolvedValue(TEST_OWNER_ADDRESS),
    } as unknown as jest.Mocked<ethers.Signer>;
    
    // Create mock contract
    mockContract = {
      name: jest.fn().mockResolvedValue('Test Token'),
      symbol: jest.fn().mockResolvedValue('TEST'),
      decimals: jest.fn().mockResolvedValue(18),
      totalSupply: jest.fn().mockResolvedValue(ethers.parseEther('1000000')),
      balanceOf: jest.fn().mockResolvedValue(ethers.parseEther('100')),
      allowance: jest.fn().mockResolvedValue(ethers.parseEther('50')),
      transfer: jest.fn().mockResolvedValue({ hash: '0xabcd', wait: jest.fn() }),
      approve: jest.fn().mockResolvedValue({ hash: '0xabcd', wait: jest.fn() }),
      transferFrom: jest.fn().mockResolvedValue({ hash: '0xabcd', wait: jest.fn() }),
    } as unknown as jest.Mocked<ethers.Contract>;
    
    // Create mock EthersService
    mockEthersService = {
      getProvider: jest.fn().mockReturnValue(mockProvider),
      getSigner: jest.fn().mockReturnValue(mockSigner),
    } as unknown as jest.Mocked<EthersService>;
    
    // Mock ethers.Contract constructor
    jest.spyOn(ethers, 'Contract').mockImplementation(() => mockContract);
  });
  
  describe('getTokenInfo', () => {
    it('should return token info from cache if available', async () => {
      const cachedInfo = {
        name: 'Cached Token',
        symbol: 'CACHE',
        decimals: 18,
        totalSupply: '1000000000000000000000000'
      };
      
      (contractCache.get as jest.Mock).mockReturnValue(cachedInfo);
      
      const result = await erc20.getTokenInfo(
        mockEthersService,
        TEST_TOKEN_ADDRESS
      );
      
      expect(result).toEqual(cachedInfo);
      expect(contractCache.get).toHaveBeenCalled();
      expect(mockEthersService.getProvider).not.toHaveBeenCalled();
    });
    
    it('should fetch token info from blockchain if not in cache', async () => {
      (contractCache.get as jest.Mock).mockReturnValue(null);
      
      const result = await erc20.getTokenInfo(
        mockEthersService,
        TEST_TOKEN_ADDRESS
      );
      
      expect(result).toEqual({
        name: 'Test Token',
        symbol: 'TEST',
        decimals: 18,
        totalSupply: '1000000000000000000000000'
      });
      
      expect(mockEthersService.getProvider).toHaveBeenCalled();
      expect(contractCache.set).toHaveBeenCalled();
      expect(mockContract.name).toHaveBeenCalled();
      expect(mockContract.symbol).toHaveBeenCalled();
      expect(mockContract.decimals).toHaveBeenCalled();
      expect(mockContract.totalSupply).toHaveBeenCalled();
    });
    
    it('should throw TokenNotFoundError if contract does not exist', async () => {
      (contractCache.get as jest.Mock).mockReturnValue(null);
      mockProvider.getCode.mockResolvedValue('0x');
      
      await expect(
        erc20.getTokenInfo(mockEthersService, TEST_TOKEN_ADDRESS)
      ).rejects.toThrow(TokenNotFoundError);
    });
  });
  
  describe('getBalance', () => {
    it('should return balance from cache if available', async () => {
      const cachedBalance = '100.0';
      
      (balanceCache.get as jest.Mock).mockReturnValue(cachedBalance);
      
      const result = await erc20.getBalance(
        mockEthersService,
        TEST_TOKEN_ADDRESS,
        TEST_OWNER_ADDRESS
      );
      
      expect(result).toEqual(cachedBalance);
      expect(balanceCache.get).toHaveBeenCalled();
      expect(mockEthersService.getProvider).not.toHaveBeenCalled();
    });
    
    it('should fetch balance from blockchain if not in cache', async () => {
      (balanceCache.get as jest.Mock).mockReturnValue(null);
      (contractCache.get as jest.Mock).mockReturnValue({
        name: 'Test Token',
        symbol: 'TEST',
        decimals: 18,
        totalSupply: '1000000000000000000000000'
      });
      
      const result = await erc20.getBalance(
        mockEthersService,
        TEST_TOKEN_ADDRESS,
        TEST_OWNER_ADDRESS
      );
      
      expect(result).toEqual('100.0');
      
      expect(mockEthersService.getProvider).toHaveBeenCalled();
      expect(balanceCache.set).toHaveBeenCalled();
      expect(mockContract.balanceOf).toHaveBeenCalledWith(TEST_OWNER_ADDRESS);
    });
  });
  
  describe('transfer', () => {
    it('should transfer tokens successfully', async () => {
      (contractCache.get as jest.Mock).mockReturnValue({
        name: 'Test Token',
        symbol: 'TEST',
        decimals: 18,
        totalSupply: '1000000000000000000000000'
      });
      
      const result = await erc20.transfer(
        mockEthersService,
        TEST_TOKEN_ADDRESS,
        TEST_RECIPIENT_ADDRESS,
        '10'
      );
      
      expect(result).toEqual({ hash: '0xabcd', wait: expect.any(Function) });
      expect(mockContract.transfer).toHaveBeenCalledWith(
        TEST_RECIPIENT_ADDRESS,
        ethers.parseEther('10'),
        {}
      );
      expect(balanceCache.delete).toHaveBeenCalledTimes(2);
    });
    
    it('should throw InsufficientBalanceError if balance is too low', async () => {
      (contractCache.get as jest.Mock).mockReturnValue({
        name: 'Test Token',
        symbol: 'TEST',
        decimals: 18,
        totalSupply: '1000000000000000000000000'
      });
      
      mockContract.balanceOf.mockResolvedValue(ethers.parseEther('5'));
      
      await expect(
        erc20.transfer(
          mockEthersService,
          TEST_TOKEN_ADDRESS,
          TEST_RECIPIENT_ADDRESS,
          '10'
        )
      ).rejects.toThrow(InsufficientBalanceError);
    });
  });
});

================
File: src/services/erc/erc20.ts
================
/**
 * @file ERC20 Token Helpers
 * @version 1.0.0
 * @lastModified 2024-06-07
 * 
 * Helper functions for interacting with ERC20 tokens
 */

import { ethers } from 'ethers';
import { EthersService } from '../ethersService.js';
import { ERC20_ABI, CACHE_KEYS } from './constants.js';
import { ERC20Info, TokenOperationOptions } from './types.js';
import { 
  ERC20Error, 
  InsufficientAllowanceError, 
  InsufficientBalanceError,
  TokenNotFoundError, 
  handleTokenError 
} from './errors.js';
import { createTokenCacheKey } from './utils.js';
import { balanceCache, contractCache } from '../../utils/cache.js';
import { logger } from '../../utils/logger.js';
import { metrics, timeAsync } from '../../utils/metrics.js';
import { rateLimiter } from '../../utils/rateLimiter.js';

/**
 * Get basic information about an ERC20 token
 * 
 * @param tokenAddress Token contract address
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with token information
 */
export async function getTokenInfo(
  ethersService: EthersService,
  tokenAddress: string,
  provider?: string,
  chainId?: number
): Promise<ERC20Info> {
  metrics.incrementCounter('erc20.getTokenInfo');
  
  return timeAsync('erc20.getTokenInfo', async () => {
    try {
      // Check rate limiting
      const identity = `${tokenAddress}:${provider || 'default'}`;
      if (!rateLimiter.consume('token', identity)) {
        throw new ERC20Error('Rate limit exceeded for token operations');
      }
      
      // Create cache key
      const cacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC20_INFO,
        tokenAddress,
        chainId
      );
      
      // Check cache first
      const cachedInfo = contractCache.get(cacheKey);
      if (cachedInfo) {
        return cachedInfo as ERC20Info;
      }
      
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Create contract instance
      const contract = new ethers.Contract(tokenAddress, ERC20_ABI, ethersProvider);
      
      // Fetch token information
      const [name, symbol, decimals, totalSupply] = await Promise.all([
        contract.name(),
        contract.symbol(),
        contract.decimals(),
        contract.totalSupply()
      ]);
      
      // Format data
      const tokenInfo: ERC20Info = {
        name,
        symbol,
        decimals,
        totalSupply: totalSupply.toString()
      };
      
      // Cache result for future use (1 day TTL)
      contractCache.set(cacheKey, tokenInfo, { ttl: 86400000 });
      
      return tokenInfo;
    } catch (error) {
      logger.debug('Error getting ERC20 token info', { tokenAddress, error });
      
      if (error instanceof Error && (
        error.message.includes('contract not deployed') || 
        error.message.includes('invalid address')
      )) {
        throw new TokenNotFoundError(tokenAddress);
      }
      
      throw handleTokenError(error, 'Failed to get token information');
    }
  });
}

/**
 * Get ERC20 token balance for an address
 * 
 * @param tokenAddress ERC20 token contract address
 * @param ownerAddress Address to check balance for
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with formatted balance as string
 */
export async function getBalance(
  ethersService: EthersService,
  tokenAddress: string,
  ownerAddress: string,
  provider?: string,
  chainId?: number
): Promise<string> {
  metrics.incrementCounter('erc20.getBalance');
  
  return timeAsync('erc20.getBalance', async () => {
    try {
      // Check rate limiting
      const identity = `${tokenAddress}:${ownerAddress}`;
      if (!rateLimiter.consume('token', identity)) {
        throw new ERC20Error('Rate limit exceeded for token operations');
      }
      
      // Create cache key
      const cacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC20_BALANCE,
        tokenAddress,
        ownerAddress,
        chainId
      );
      
      // Check cache first
      const cachedBalance = balanceCache.get(cacheKey);
      if (cachedBalance) {
        return cachedBalance;
      }
      
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Create contract instance
      const contract = new ethers.Contract(tokenAddress, ERC20_ABI, ethersProvider);
      
      // Get raw balance
      let balance;
      try {
        balance = await contract.balanceOf(ownerAddress);
      } catch (error: any) {
        // Check for empty response (0x) which often indicates a non-ERC20 contract
        if (error.code === 'BAD_DATA' && error.value === '0x') {
          logger.debug('Contract returned empty data for balanceOf call', { tokenAddress });
          throw new ERC20Error(
            `Contract at ${tokenAddress} does not appear to be a valid ERC20 token. It returned empty data for the balanceOf call.`
          );
        }
        // Re-throw the original error
        throw error;
      }
      
      // Get token decimals for formatting
      const tokenInfo = await getTokenInfo(ethersService, tokenAddress, provider, chainId);
      
      // Format the balance based on decimals
      const formattedBalance = ethers.formatUnits(balance, tokenInfo.decimals);
      
      // Cache result for future use (30 second TTL)
      balanceCache.set(cacheKey, formattedBalance, { ttl: 30000 });
      
      return formattedBalance;
    } catch (error) {
      logger.debug('Error getting ERC20 balance', { tokenAddress, ownerAddress, error });
      throw handleTokenError(error, 'Failed to get token balance');
    }
  });
}

/**
 * Get the allowance amount approved for a spender
 * 
 * @param tokenAddress ERC20 token contract address
 * @param ownerAddress Token owner address
 * @param spenderAddress Spender address
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with formatted allowance as string
 */
export async function getAllowance(
  ethersService: EthersService,
  tokenAddress: string,
  ownerAddress: string,
  spenderAddress: string,
  provider?: string,
  chainId?: number
): Promise<string> {
  metrics.incrementCounter('erc20.getAllowance');
  
  return timeAsync('erc20.getAllowance', async () => {
    try {
      // Create cache key
      const cacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC20_ALLOWANCE,
        tokenAddress,
        ownerAddress,
        spenderAddress,
        chainId
      );
      
      // Check cache first
      const cachedAllowance = balanceCache.get(cacheKey);
      if (cachedAllowance) {
        return cachedAllowance;
      }
      
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Create contract instance
      const contract = new ethers.Contract(tokenAddress, ERC20_ABI, ethersProvider);
      
      // Get allowance
      const allowance = await contract.allowance(ownerAddress, spenderAddress);
      
      // Get token decimals for formatting
      const tokenInfo = await getTokenInfo(ethersService, tokenAddress, provider, chainId);
      
      // Format the allowance based on decimals
      const formattedAllowance = ethers.formatUnits(allowance, tokenInfo.decimals);
      
      // Cache result for future use (30 second TTL)
      balanceCache.set(cacheKey, formattedAllowance, { ttl: 30000 });
      
      return formattedAllowance;
    } catch (error) {
      logger.debug('Error getting ERC20 allowance', { tokenAddress, ownerAddress, spenderAddress, error });
      throw handleTokenError(error, 'Failed to get token allowance');
    }
  });
}

/**
 * Transfer ERC20 tokens to a recipient
 * 
 * @param tokenAddress ERC20 token contract address
 * @param recipientAddress Recipient address
 * @param amount Amount to transfer in token units (e.g., "1.5" not wei)
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @param options Optional transaction options
 * @returns Promise with transaction response
 */
export async function transfer(
  ethersService: EthersService,
  tokenAddress: string,
  recipientAddress: string,
  amount: string,
  provider?: string,
  chainId?: number,
  options: TokenOperationOptions = {}
): Promise<ethers.TransactionResponse> {
  metrics.incrementCounter('erc20.transfer');
  
  return timeAsync('erc20.transfer', async () => {
    try {
      // Check rate limiting for write operations
      const identity = `${tokenAddress}:transfer`;
      if (!rateLimiter.consume('transaction', identity)) {
        throw new ERC20Error('Rate limit exceeded for token transfers');
      }
      
      // Get provider and signer from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      const signer = ethersService['getSigner'](provider, chainId);
      
      // Get token info for decimals
      const tokenInfo = await getTokenInfo(ethersService, tokenAddress, provider, chainId);
      
      // Parse input amount to wei equivalent based on token decimals
      const amountInWei = ethers.parseUnits(amount, tokenInfo.decimals);
      
      // Get current balance
      const contract = new ethers.Contract(tokenAddress, ERC20_ABI, ethersProvider);
      const walletAddress = await signer.getAddress();
      const balance = await contract.balanceOf(walletAddress);
      
      // Check if balance is sufficient
      if (balance < amountInWei) {
        throw new InsufficientBalanceError(
          tokenAddress,
          ethers.formatUnits(amountInWei, tokenInfo.decimals),
          ethers.formatUnits(balance, tokenInfo.decimals)
        );
      }
      
      // Create contract instance with signer
      const contractWithSigner = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
      
      // Prepare transaction overrides
      const overrides: ethers.Overrides = {};
      if (options.gasLimit) overrides.gasLimit = options.gasLimit;
      if (options.gasPrice) overrides.gasPrice = options.gasPrice;
      if (options.maxFeePerGas) overrides.maxFeePerGas = options.maxFeePerGas;
      if (options.maxPriorityFeePerGas) overrides.maxPriorityFeePerGas = options.maxPriorityFeePerGas;
      if (options.nonce !== undefined) overrides.nonce = options.nonce;
      
      // Send transaction
      const tx = await contractWithSigner.transfer(recipientAddress, amountInWei, overrides);
      
      // Invalidate balance caches
      const senderCacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC20_BALANCE,
        tokenAddress,
        walletAddress,
        chainId
      );
      const recipientCacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC20_BALANCE,
        tokenAddress,
        recipientAddress,
        chainId
      );
      balanceCache.delete(senderCacheKey);
      balanceCache.delete(recipientCacheKey);
      
      return tx;
    } catch (error) {
      logger.debug('Error transferring ERC20 tokens', { tokenAddress, recipientAddress, amount, error });
      throw handleTokenError(error, 'Failed to transfer tokens');
    }
  });
}

/**
 * Approve a spender to use tokens
 * 
 * @param tokenAddress ERC20 token contract address
 * @param spenderAddress Spender address to approve
 * @param amount Amount to approve in token units (e.g., "1.5" not wei)
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @param options Optional transaction options
 * @returns Promise with transaction response
 */
export async function approve(
  ethersService: EthersService,
  tokenAddress: string,
  spenderAddress: string,
  amount: string,
  provider?: string,
  chainId?: number,
  options: TokenOperationOptions = {}
): Promise<ethers.TransactionResponse> {
  metrics.incrementCounter('erc20.approve');
  
  return timeAsync('erc20.approve', async () => {
    try {
      // Get provider and signer from ethers service
      const signer = ethersService['getSigner'](provider, chainId);
      
      // Get token info for decimals
      const tokenInfo = await getTokenInfo(ethersService, tokenAddress, provider, chainId);
      
      // Parse input amount to wei equivalent based on token decimals
      const amountInWei = ethers.parseUnits(amount, tokenInfo.decimals);
      
      // Create contract instance with signer
      const contractWithSigner = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
      
      // Prepare transaction overrides
      const overrides: ethers.Overrides = {};
      if (options.gasLimit) overrides.gasLimit = options.gasLimit;
      if (options.gasPrice) overrides.gasPrice = options.gasPrice;
      if (options.maxFeePerGas) overrides.maxFeePerGas = options.maxFeePerGas;
      if (options.maxPriorityFeePerGas) overrides.maxPriorityFeePerGas = options.maxPriorityFeePerGas;
      if (options.nonce !== undefined) overrides.nonce = options.nonce;
      
      // Send transaction
      const tx = await contractWithSigner.approve(spenderAddress, amountInWei, overrides);
      
      // Invalidate allowance cache
      const walletAddress = await signer.getAddress();
      const allowanceCacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC20_ALLOWANCE,
        tokenAddress,
        walletAddress,
        spenderAddress,
        chainId
      );
      balanceCache.delete(allowanceCacheKey);
      
      return tx;
    } catch (error) {
      logger.debug('Error approving ERC20 tokens', { tokenAddress, spenderAddress, amount, error });
      throw handleTokenError(error, 'Failed to approve token spending');
    }
  });
}

/**
 * Transfer tokens from one address to another (requires approval)
 * 
 * @param tokenAddress ERC20 token contract address
 * @param senderAddress Address to transfer from
 * @param recipientAddress Recipient address
 * @param amount Amount to transfer in token units (e.g., "1.5" not wei)
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @param options Optional transaction options
 * @returns Promise with transaction response
 */
export async function transferFrom(
  ethersService: EthersService,
  tokenAddress: string,
  senderAddress: string,
  recipientAddress: string,
  amount: string,
  provider?: string,
  chainId?: number,
  options: TokenOperationOptions = {}
): Promise<ethers.TransactionResponse> {
  metrics.incrementCounter('erc20.transferFrom');
  
  return timeAsync('erc20.transferFrom', async () => {
    try {
      // Get provider and signer from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      const signer = ethersService['getSigner'](provider, chainId);
      const signerAddress = await signer.getAddress();
      
      // Get token info for decimals
      const tokenInfo = await getTokenInfo(ethersService, tokenAddress, provider, chainId);
      
      // Parse input amount to wei equivalent based on token decimals
      const amountInWei = ethers.parseUnits(amount, tokenInfo.decimals);
      
      // Create contract instance
      const contract = new ethers.Contract(tokenAddress, ERC20_ABI, ethersProvider);
      
      // Check sender's balance
      const balance = await contract.balanceOf(senderAddress);
      if (balance < amountInWei) {
        throw new InsufficientBalanceError(
          tokenAddress,
          ethers.formatUnits(amountInWei, tokenInfo.decimals),
          ethers.formatUnits(balance, tokenInfo.decimals)
        );
      }
      
      // Check allowance
      const allowance = await contract.allowance(senderAddress, signerAddress);
      if (allowance < amountInWei) {
        throw new InsufficientAllowanceError(
          tokenAddress,
          signerAddress,
          ethers.formatUnits(amountInWei, tokenInfo.decimals),
          ethers.formatUnits(allowance, tokenInfo.decimals)
        );
      }
      
      // Create contract instance with signer
      const contractWithSigner = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
      
      // Prepare transaction overrides
      const overrides: ethers.Overrides = {};
      if (options.gasLimit) overrides.gasLimit = options.gasLimit;
      if (options.gasPrice) overrides.gasPrice = options.gasPrice;
      if (options.maxFeePerGas) overrides.maxFeePerGas = options.maxFeePerGas;
      if (options.maxPriorityFeePerGas) overrides.maxPriorityFeePerGas = options.maxPriorityFeePerGas;
      if (options.nonce !== undefined) overrides.nonce = options.nonce;
      
      // Send transaction
      const tx = await contractWithSigner.transferFrom(
        senderAddress,
        recipientAddress,
        amountInWei,
        overrides
      );
      
      // Invalidate caches
      const senderCacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC20_BALANCE,
        tokenAddress,
        senderAddress,
        chainId
      );
      const recipientCacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC20_BALANCE,
        tokenAddress,
        recipientAddress,
        chainId
      );
      const allowanceCacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC20_ALLOWANCE,
        tokenAddress,
        senderAddress,
        signerAddress,
        chainId
      );
      balanceCache.delete(senderCacheKey);
      balanceCache.delete(recipientCacheKey);
      balanceCache.delete(allowanceCacheKey);
      
      return tx;
    } catch (error) {
      logger.debug('Error in transferFrom for ERC20 tokens', { tokenAddress, senderAddress, recipientAddress, amount, error });
      throw handleTokenError(error, 'Failed to transfer tokens from sender');
    }
  });
}

/**
 * Parse a token amount from human-readable to raw units
 * 
 * @param amount Amount in human-readable format (e.g., "1.5")
 * @param tokenAddress ERC20 token contract address
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with parsed amount as bigint
 */
export async function parseTokenAmount(
  ethersService: EthersService,
  amount: string,
  tokenAddress: string,
  provider?: string,
  chainId?: number
): Promise<bigint> {
  try {
    // Get token info for decimals
    const tokenInfo = await getTokenInfo(ethersService, tokenAddress, provider, chainId);
    
    // Parse the amount
    return ethers.parseUnits(amount, tokenInfo.decimals);
  } catch (error) {
    logger.debug('Error parsing token amount', { amount, tokenAddress, error });
    throw handleTokenError(error, 'Failed to parse token amount');
  }
}

/**
 * Format a token amount from raw units to human-readable format
 * 
 * @param amount Amount in raw units (wei equivalent)
 * @param tokenAddress ERC20 token contract address
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with formatted amount as string
 */
export async function formatTokenAmount(
  ethersService: EthersService,
  amount: string | bigint,
  tokenAddress: string,
  provider?: string,
  chainId?: number
): Promise<string> {
  try {
    // Get token info for decimals
    const tokenInfo = await getTokenInfo(ethersService, tokenAddress, provider, chainId);
    
    // Format the amount
    return ethers.formatUnits(amount, tokenInfo.decimals);
  } catch (error) {
    logger.debug('Error formatting token amount', { amount, tokenAddress, error });
    throw handleTokenError(error, 'Failed to format token amount');
  }
}

================
File: src/services/erc/erc721.test.ts.md
================
/**
 * @file ERC721 Helper Tests
 */

import { ethers } from 'ethers';
import { EthersService } from '../ethersService.js';
import * as erc721 from './erc721.js';
import { TokenNotFoundError, UnauthorizedTokenActionError } from './errors.js';
import { contractCache, ensCache } from '../../utils/cache.js';

// Mock EthersService
jest.mock('../ethersService');

// Mock cache
jest.mock('../../utils/cache', () => ({
  contractCache: {
    get: jest.fn(),
    set: jest.fn(),
  },
  ensCache: {
    get: jest.fn(),
    set: jest.fn(),
    delete: jest.fn(),
  },
}));

// Mock metrics and logger
jest.mock('../../utils/metrics', () => ({
  metrics: {
    incrementCounter: jest.fn(),
  },
  timeAsync: jest.fn((name, fn) => fn()),
}));

jest.mock('../../utils/logger', () => ({
  logger: {
    debug: jest.fn(),
  },
}));

// Mock rate limiter
jest.mock('../../utils/rateLimiter', () => ({
  rateLimiter: {
    consume: jest.fn().mockReturnValue(true),
  },
}));

// Mock fetch for metadata
global.fetch = jest.fn().mockImplementation(() => 
  Promise.resolve({
    ok: true,
    json: () => Promise.resolve({
      name: 'Test NFT',
      description: 'Test Description',
      image: 'https://example.com/image.png',
      attributes: [
        { trait_type: 'Background', value: 'Blue' },
      ],
    }),
  })
) as jest.Mock;

describe('ERC721 Helpers', () => {
  let mockEthersService: jest.Mocked<EthersService>;
  let mockProvider: jest.Mocked<ethers.Provider>;
  let mockSigner: jest.Mocked<ethers.Signer>;
  let mockContract: jest.Mocked<ethers.Contract>;
  
  const TEST_CONTRACT_ADDRESS = '0x1234567890123456789012345678901234567890';
  const TEST_OWNER_ADDRESS = '0xabcdefabcdefabcdefabcdefabcdefabcdefabcd';
  const TEST_RECIPIENT_ADDRESS = '0x9876543210987654321098765432109876543210';
  const TEST_TOKEN_ID = '123';
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Create mock provider
    mockProvider = {
      getCode: jest.fn().mockResolvedValue('0x123'),
    } as unknown as jest.Mocked<ethers.Provider>;
    
    // Create mock signer
    mockSigner = {
      getAddress: jest.fn().mockResolvedValue(TEST_OWNER_ADDRESS),
    } as unknown as jest.Mocked<ethers.Signer>;
    
    // Create mock contract
    mockContract = {
      name: jest.fn().mockResolvedValue('Test Collection'),
      symbol: jest.fn().mockResolvedValue('TEST'),
      totalSupply: jest.fn().mockResolvedValue(ethers.toBigInt(1000)),
      balanceOf: jest.fn().mockResolvedValue(ethers.toBigInt(5)),
      ownerOf: jest.fn().mockResolvedValue(TEST_OWNER_ADDRESS),
      tokenURI: jest.fn().mockResolvedValue('https://example.com/token/123'),
      getApproved: jest.fn().mockResolvedValue('0x0000000000000000000000000000000000000000'),
      isApprovedForAll: jest.fn().mockResolvedValue(false),
      supportsInterface: jest.fn().mockImplementation((interfaceId) => {
        return Promise.resolve(interfaceId === '0x80ac58cd'); // True for ERC721
      }),
      approve: jest.fn().mockResolvedValue({ hash: '0xabcd', wait: jest.fn() }),
      setApprovalForAll: jest.fn().mockResolvedValue({ hash: '0xabcd', wait: jest.fn() }),
      transferFrom: jest.fn().mockResolvedValue({ hash: '0xabcd', wait: jest.fn() }),
      safeTransferFrom: jest.fn().mockResolvedValue({ hash: '0xabcd', wait: jest.fn() }),
      filters: {
        Transfer: jest.fn().mockReturnValue({ address: TEST_CONTRACT_ADDRESS }),
      },
      queryFilter: jest.fn().mockResolvedValue([
        { args: [null, TEST_OWNER_ADDRESS, ethers.toBigInt(123)] },
        { args: [null, TEST_OWNER_ADDRESS, ethers.toBigInt(456)] },
      ]),
      tokenOfOwnerByIndex: jest.fn().mockImplementation((owner, index) => {
        return Promise.resolve(ethers.toBigInt(100 + Number(index)));
      }),
    } as unknown as jest.Mocked<ethers.Contract>;
    
    // Create mock EthersService
    mockEthersService = {
      getProvider: jest.fn().mockReturnValue(mockProvider),
      getSigner: jest.fn().mockReturnValue(mockSigner),
    } as unknown as jest.Mocked<EthersService>;
    
    // Mock ethers.Contract constructor
    jest.spyOn(ethers, 'Contract').mockImplementation(() => mockContract);
  });
  
  describe('getNFTInfo', () => {
    it('should return NFT info from cache if available', async () => {
      const cachedInfo = {
        name: 'Cached Collection',
        symbol: 'CACHE',
        totalSupply: '1000'
      };
      
      (contractCache.get as jest.Mock).mockReturnValue(cachedInfo);
      
      const result = await erc721.getNFTInfo(
        mockEthersService,
        TEST_CONTRACT_ADDRESS
      );
      
      expect(result).toEqual(cachedInfo);
      expect(contractCache.get).toHaveBeenCalled();
      expect(mockEthersService.getProvider).not.toHaveBeenCalled();
    });
    
    it('should fetch NFT info from blockchain if not in cache', async () => {
      (contractCache.get as jest.Mock).mockReturnValue(null);
      
      const result = await erc721.getNFTInfo(
        mockEthersService,
        TEST_CONTRACT_ADDRESS
      );
      
      expect(result).toEqual({
        name: 'Test Collection',
        symbol: 'TEST',
        totalSupply: '1000'
      });
      
      expect(mockEthersService.getProvider).toHaveBeenCalled();
      expect(contractCache.set).toHaveBeenCalled();
      expect(mockContract.name).toHaveBeenCalled();
      expect(mockContract.symbol).toHaveBeenCalled();
      expect(mockContract.totalSupply).toHaveBeenCalled();
    });
    
    it('should throw TokenNotFoundError if contract does not exist', async () => {
      (contractCache.get as jest.Mock).mockReturnValue(null);
      mockProvider.getCode.mockResolvedValue('0x');
      
      await expect(
        erc721.getNFTInfo(mockEthersService, TEST_CONTRACT_ADDRESS)
      ).rejects.toThrow(TokenNotFoundError);
    });
    
    it('should handle missing name and symbol', async () => {
      (contractCache.get as jest.Mock).mockReturnValue(null);
      
      mockContract.name.mockRejectedValue(new Error('Function not implemented'));
      mockContract.symbol.mockRejectedValue(new Error('Function not implemented'));
      
      const result = await erc721.getNFTInfo(
        mockEthersService,
        TEST_CONTRACT_ADDRESS
      );
      
      expect(result).toEqual({
        name: 'Unknown Collection',
        symbol: 'NFT',
        totalSupply: '1000'
      });
    });
  });
  
  describe('ownerOf', () => {
    it('should return owner from cache if available', async () => {
      const cachedOwner = TEST_OWNER_ADDRESS;
      
      (ensCache.get as jest.Mock).mockReturnValue(cachedOwner);
      
      const result = await erc721.ownerOf(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_TOKEN_ID
      );
      
      expect(result).toEqual(cachedOwner);
      expect(ensCache.get).toHaveBeenCalled();
      expect(mockEthersService.getProvider).not.toHaveBeenCalled();
    });
    
    it('should fetch owner from blockchain if not in cache', async () => {
      (ensCache.get as jest.Mock).mockReturnValue(null);
      
      const result = await erc721.ownerOf(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_TOKEN_ID
      );
      
      expect(result).toEqual(TEST_OWNER_ADDRESS);
      
      expect(mockEthersService.getProvider).toHaveBeenCalled();
      expect(ensCache.set).toHaveBeenCalled();
      expect(mockContract.ownerOf).toHaveBeenCalledWith(TEST_TOKEN_ID);
    });
    
    it('should throw TokenNotFoundError if token does not exist', async () => {
      (ensCache.get as jest.Mock).mockReturnValue(null);
      mockContract.ownerOf.mockRejectedValue(new Error('owner query for nonexistent token'));
      
      await expect(
        erc721.ownerOf(mockEthersService, TEST_CONTRACT_ADDRESS, TEST_TOKEN_ID)
      ).rejects.toThrow(TokenNotFoundError);
    });
  });
  
  describe('transferNFT', () => {
    it('should transfer NFT successfully when caller is owner', async () => {
      (ensCache.get as jest.Mock).mockReturnValue(null);
      
      const result = await erc721.transferNFT(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_RECIPIENT_ADDRESS,
        TEST_TOKEN_ID
      );
      
      expect(result).toEqual({ hash: '0xabcd', wait: expect.any(Function) });
      expect(mockContract.transferFrom).toHaveBeenCalledWith(
        TEST_OWNER_ADDRESS,
        TEST_RECIPIENT_ADDRESS,
        TEST_TOKEN_ID,
        {}
      );
      expect(ensCache.delete).toHaveBeenCalled();
    });
    
    it('should throw UnauthorizedTokenActionError if caller is not owner or approved', async () => {
      (ensCache.get as jest.Mock).mockReturnValue(null);
      
      // Set a different owner than the signer
      mockContract.ownerOf.mockResolvedValue(TEST_RECIPIENT_ADDRESS);
      
      await expect(
        erc721.transferNFT(
          mockEthersService,
          TEST_CONTRACT_ADDRESS,
          TEST_RECIPIENT_ADDRESS,
          TEST_TOKEN_ID
        )
      ).rejects.toThrow(UnauthorizedTokenActionError);
    });
    
    it('should transfer NFT if caller is approved for the token', async () => {
      (ensCache.get as jest.Mock).mockReturnValue(null);
      
      // Set a different owner than the signer
      mockContract.ownerOf.mockResolvedValue(TEST_RECIPIENT_ADDRESS);
      
      // But make the signer approved for this token
      mockContract.getApproved.mockResolvedValue(TEST_OWNER_ADDRESS);
      
      const result = await erc721.transferNFT(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_RECIPIENT_ADDRESS,
        TEST_TOKEN_ID
      );
      
      expect(result).toEqual({ hash: '0xabcd', wait: expect.any(Function) });
      expect(mockContract.transferFrom).toHaveBeenCalled();
    });
  });
  
  describe('getUserNFTs', () => {
    it('should return empty array if user has no NFTs', async () => {
      mockContract.balanceOf.mockResolvedValue(ethers.toBigInt(0));
      
      const result = await erc721.getUserNFTs(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_OWNER_ADDRESS
      );
      
      expect(result).toEqual([]);
    });
    
    it('should use tokenOfOwnerByIndex for enumerable collections', async () => {
      mockContract.supportsInterface.mockImplementation((interfaceId) => {
        return Promise.resolve(interfaceId === '0x780e9d63'); // True for ERC721Enumerable
      });
      
      const result = await erc721.getUserNFTs(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_OWNER_ADDRESS
      );
      
      expect(result.length).toBe(5); // Based on balanceOf returning 5
      expect(result[0].tokenId).toBe('100');
      expect(mockContract.tokenOfOwnerByIndex).toHaveBeenCalled();
      expect(mockContract.queryFilter).not.toHaveBeenCalled();
    });
    
    it('should use events for non-enumerable collections', async () => {
      // Make supportsInterface return false for enumerable
      mockContract.supportsInterface.mockImplementation((interfaceId) => {
        return Promise.resolve(interfaceId !== '0x780e9d63');
      });
      
      // Make tokenOfOwnerByIndex fail
      mockContract.tokenOfOwnerByIndex.mockRejectedValue(new Error('not implemented'));
      
      const result = await erc721.getUserNFTs(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_OWNER_ADDRESS
      );
      
      expect(mockContract.queryFilter).toHaveBeenCalled();
      expect(result.length).toBe(2); // Based on mock events
    });
    
    it('should fetch metadata if includeMetadata is true', async () => {
      (contractCache.get as jest.Mock).mockReturnValue(null);
      
      mockContract.balanceOf.mockResolvedValue(ethers.toBigInt(1));
      mockContract.tokenOfOwnerByIndex.mockResolvedValue(ethers.toBigInt(123));
      
      const result = await erc721.getUserNFTs(
        mockEthersService,
        TEST_CONTRACT_ADDRESS,
        TEST_OWNER_ADDRESS,
        true // includeMetadata
      );
      
      expect(result.length).toBe(1);
      expect(result[0].tokenId).toBe('123');
      expect(result[0].metadata).toBeDefined();
      expect(global.fetch).toHaveBeenCalled();
    });
  });
});

================
File: src/services/erc/erc721.ts
================
/**
 * @file ERC721 NFT Helpers
 * @version 1.0.0
 * @lastModified 2024-06-07
 * 
 * Helper functions for interacting with ERC721 NFT tokens
 */

import { ethers } from 'ethers';
import { EthersService } from '../ethersService.js';
import { ERC721_ABI, CACHE_KEYS } from './constants.js';
import { ERC721Info, ERC721TokenInfo, NFTMetadata, TokenOperationOptions } from './types.js';
import { 
  ERC721Error, 
  TokenNotFoundError, 
  TokenMetadataError,
  UnauthorizedTokenActionError,
  handleTokenError 
} from './errors.js';
import { createTokenCacheKey, fetchMetadata } from './utils.js';
import { contractCache, ensCache } from '../../utils/cache.js';
import { logger } from '../../utils/logger.js';
import { metrics, timeAsync } from '../../utils/metrics.js';
import { rateLimiter } from '../../utils/rateLimiter.js';

/**
 * Get basic information about an ERC721 NFT collection
 * 
 * @param ethersService EthersService instance
 * @param contractAddress NFT contract address
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with NFT collection information
 */
export async function getNFTInfo(
  ethersService: EthersService,
  contractAddress: string,
  provider?: string,
  chainId?: number
): Promise<ERC721Info> {
  metrics.incrementCounter('erc721.getNFTInfo');
  
  return timeAsync('erc721.getNFTInfo', async () => {
    try {
      // Check rate limiting
      const identity = `${contractAddress}:${provider || 'default'}`;
      if (!rateLimiter.consume('token', identity)) {
        throw new ERC721Error('Rate limit exceeded for NFT operations');
      }
      
      // Create cache key
      const cacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC721_INFO,
        contractAddress,
        chainId
      );
      
      // Check cache first
      const cachedInfo = contractCache.get(cacheKey);
      if (cachedInfo) {
        return cachedInfo as ERC721Info;
      }
      
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Check if address is contract
      const code = await ethersProvider.getCode(contractAddress);
      if (code === '0x' || code === '0x0') {
        throw new TokenNotFoundError(contractAddress);
      }
      
      // Create contract instance
      const contract = new ethers.Contract(contractAddress, ERC721_ABI, ethersProvider);
      
      // Fetch NFT information - some contracts might not implement all methods
      let name = '';
      let symbol = '';
      let totalSupply: string | undefined = undefined;
      
      try {
        name = await contract.name();
      } catch (error) {
        logger.debug('Error getting NFT name', { contractAddress, error });
        name = 'Unknown Collection';
      }
      
      try {
        symbol = await contract.symbol();
      } catch (error) {
        logger.debug('Error getting NFT symbol', { contractAddress, error });
        symbol = 'NFT';
      }
      
      try {
        // totalSupply is optional in ERC721
        const supplyBigInt = await contract.totalSupply();
        totalSupply = supplyBigInt.toString();
      } catch (error) {
        // totalSupply function is not required in ERC721, so ignore errors
        logger.debug('NFT contract does not implement totalSupply', { contractAddress });
      }
      
      // Format data
      const nftInfo: ERC721Info = {
        name,
        symbol,
        totalSupply
      };
      
      // Cache result for future use (1 hour TTL)
      contractCache.set(cacheKey, nftInfo, { ttl: 3600000 });
      
      return nftInfo;
    } catch (error) {
      logger.debug('Error getting ERC721 NFT info', { contractAddress, error });
      
      if (error instanceof TokenNotFoundError) {
        throw error;
      }
      
      throw handleTokenError(error, 'Failed to get NFT collection information');
    }
  });
}

/**
 * Get the owner of a specific NFT
 * 
 * @param ethersService EthersService instance
 * @param contractAddress NFT contract address
 * @param tokenId Token ID to check ownership
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with owner address
 */
export async function ownerOf(
  ethersService: EthersService,
  contractAddress: string,
  tokenId: string | number,
  provider?: string,
  chainId?: number
): Promise<string> {
  metrics.incrementCounter('erc721.ownerOf');
  
  return timeAsync('erc721.ownerOf', async () => {
    try {
      // Create cache key
      const cacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC721_OWNER,
        contractAddress,
        tokenId,
        chainId
      );
      
      // Check cache first
      const cachedOwner = ensCache.get(cacheKey);
      if (cachedOwner) {
        return cachedOwner;
      }
      
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Create contract instance
      const contract = new ethers.Contract(contractAddress, ERC721_ABI, ethersProvider);
      
      // Get owner
      const owner = await contract.ownerOf(tokenId);
      
      // Cache result for future use (30 seconds TTL)
      ensCache.set(cacheKey, owner, { ttl: 30000 });
      
      return owner;
    } catch (error) {
      logger.debug('Error getting NFT owner', { contractAddress, tokenId, error });
      
      // Check for common errors
      if (error instanceof Error && 
          (error.message.includes('owner query for nonexistent token') ||
           error.message.includes('invalid token ID'))) {
        throw new TokenNotFoundError(contractAddress, tokenId);
      }
      
      throw handleTokenError(error, 'Failed to get NFT owner');
    }
  });
}

/**
 * Get the token URI for a specific NFT
 * 
 * @param ethersService EthersService instance
 * @param contractAddress NFT contract address
 * @param tokenId Token ID
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with token URI
 */
export async function getTokenURI(
  ethersService: EthersService,
  contractAddress: string,
  tokenId: string | number,
  provider?: string,
  chainId?: number
): Promise<string> {
  metrics.incrementCounter('erc721.getTokenURI');
  
  return timeAsync('erc721.getTokenURI', async () => {
    try {
      // Create cache key
      const cacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC721_TOKEN_URI,
        contractAddress,
        tokenId,
        chainId
      );
      
      // Check cache first
      const cachedURI = ensCache.get(cacheKey);
      if (cachedURI) {
        return cachedURI;
      }
      
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Create contract instance
      const contract = new ethers.Contract(contractAddress, ERC721_ABI, ethersProvider);
      
      // Try to get token URI
      let tokenURI;
      try {
        // Try standard tokenURI method
        tokenURI = await contract.tokenURI(tokenId);
      } catch (error) {
        // If tokenURI fails, try uri method (some contracts use this instead)
        try {
          tokenURI = await contract.uri(tokenId);
        } catch (innerError) {
          throw error; // If both fail, use the original error
        }
      }
      
      // Cache result for future use (1 hour TTL)
      ensCache.set(cacheKey, tokenURI, { ttl: 3600000 });
      
      return tokenURI;
    } catch (error) {
      logger.debug('Error getting NFT token URI', { contractAddress, tokenId, error });
      
      // Check for common errors
      if (error instanceof Error && 
          (error.message.includes('nonexistent token') ||
           error.message.includes('invalid token ID'))) {
        throw new TokenNotFoundError(contractAddress, tokenId);
      }
      
      throw handleTokenError(error, 'Failed to get NFT token URI');
    }
  });
}

/**
 * Get and parse metadata for a specific NFT
 * 
 * @param ethersService EthersService instance
 * @param contractAddress NFT contract address
 * @param tokenId Token ID
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with parsed metadata
 */
export async function getMetadata(
  ethersService: EthersService,
  contractAddress: string,
  tokenId: string | number,
  provider?: string,
  chainId?: number
): Promise<NFTMetadata> {
  metrics.incrementCounter('erc721.getMetadata');
  
  return timeAsync('erc721.getMetadata', async () => {
    try {
      // Create cache key
      const cacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC721_METADATA,
        contractAddress,
        tokenId,
        chainId
      );
      
      // Check cache first
      const cachedMetadata = contractCache.get(cacheKey);
      if (cachedMetadata) {
        return cachedMetadata as NFTMetadata;
      }
      
      // Get token URI
      const tokenURI = await getTokenURI(ethersService, contractAddress, tokenId, provider, chainId);
      
      // Fetch and parse metadata
      const metadata = await fetchMetadata(tokenURI, contractAddress, tokenId);
      
      // Cache result for future use (1 hour TTL)
      contractCache.set(cacheKey, metadata, { ttl: 3600000 });
      
      return metadata;
    } catch (error) {
      logger.debug('Error getting NFT metadata', { contractAddress, tokenId, error });
      
      if (error instanceof TokenNotFoundError) {
        throw error;
      }
      
      // Handle metadata parsing errors
      if (!(error instanceof TokenMetadataError)) {
        throw new TokenMetadataError(contractAddress, tokenId, undefined, {
          originalError: error instanceof Error ? error.message : String(error)
        });
      }
      
      throw error;
    }
  });
}

/**
 * Get the NFT balance of an address
 * 
 * @param ethersService EthersService instance
 * @param contractAddress NFT contract address
 * @param ownerAddress Owner address to check
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with number of NFTs owned
 */
export async function balanceOf(
  ethersService: EthersService,
  contractAddress: string,
  ownerAddress: string,
  provider?: string,
  chainId?: number
): Promise<number> {
  metrics.incrementCounter('erc721.balanceOf');
  
  return timeAsync('erc721.balanceOf', async () => {
    try {
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Create contract instance
      const contract = new ethers.Contract(contractAddress, ERC721_ABI, ethersProvider);
      
      // Get balance
      const balance = await contract.balanceOf(ownerAddress);
      
      return Number(balance);
    } catch (error) {
      logger.debug('Error getting NFT balance', { contractAddress, ownerAddress, error });
      throw handleTokenError(error, 'Failed to get NFT balance');
    }
  });
}

/**
 * Check if an operator is approved to manage all NFTs
 * 
 * @param ethersService EthersService instance
 * @param contractAddress NFT contract address
 * @param ownerAddress Owner address
 * @param operatorAddress Operator address to check
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with approval status
 */
export async function isApprovedForAll(
  ethersService: EthersService,
  contractAddress: string,
  ownerAddress: string,
  operatorAddress: string,
  provider?: string,
  chainId?: number
): Promise<boolean> {
  metrics.incrementCounter('erc721.isApprovedForAll');
  
  return timeAsync('erc721.isApprovedForAll', async () => {
    try {
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Create contract instance
      const contract = new ethers.Contract(contractAddress, ERC721_ABI, ethersProvider);
      
      // Check approval
      const isApproved = await contract.isApprovedForAll(ownerAddress, operatorAddress);
      
      return isApproved;
    } catch (error) {
      logger.debug('Error checking NFT approval', { contractAddress, ownerAddress, operatorAddress, error });
      throw handleTokenError(error, 'Failed to check NFT approval status');
    }
  });
}

/**
 * Get the approved address for a specific NFT
 * 
 * @param ethersService EthersService instance
 * @param contractAddress NFT contract address
 * @param tokenId Token ID to check
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with approved address
 */
export async function getApproved(
  ethersService: EthersService,
  contractAddress: string,
  tokenId: string | number,
  provider?: string,
  chainId?: number
): Promise<string> {
  metrics.incrementCounter('erc721.getApproved');
  
  return timeAsync('erc721.getApproved', async () => {
    try {
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Create contract instance
      const contract = new ethers.Contract(contractAddress, ERC721_ABI, ethersProvider);
      
      // Get approved address
      const approved = await contract.getApproved(tokenId);
      
      return approved;
    } catch (error) {
      logger.debug('Error getting approved address for NFT', { contractAddress, tokenId, error });
      
      // Check for common errors
      if (error instanceof Error && 
          (error.message.includes('nonexistent token') ||
           error.message.includes('invalid token ID'))) {
        throw new TokenNotFoundError(contractAddress, tokenId);
      }
      
      throw handleTokenError(error, 'Failed to get approved address for NFT');
    }
  });
}

/**
 * Transfer an NFT to a new owner
 * 
 * @param ethersService EthersService instance
 * @param contractAddress NFT contract address
 * @param toAddress Recipient address
 * @param tokenId Token ID to transfer
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @param options Optional transaction options
 * @returns Promise with transaction response
 */
export async function transferNFT(
  ethersService: EthersService,
  contractAddress: string,
  toAddress: string,
  tokenId: string | number,
  provider?: string,
  chainId?: number,
  options: TokenOperationOptions = {}
): Promise<ethers.TransactionResponse> {
  metrics.incrementCounter('erc721.transferNFT');
  
  return timeAsync('erc721.transferNFT', async () => {
    try {
      // Check rate limiting for write operations
      const identity = `${contractAddress}:transfer`;
      if (!rateLimiter.consume('transaction', identity)) {
        throw new ERC721Error('Rate limit exceeded for NFT transfers');
      }
      
      // Get provider and signer from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      const signer = ethersService['getSigner'](provider, chainId);
      const fromAddress = await signer.getAddress();
      
      // Check ownership
      const owner = await ownerOf(ethersService, contractAddress, tokenId, provider, chainId);
      
      if (owner.toLowerCase() !== fromAddress.toLowerCase()) {
        // Check if signer is approved
        const approved = await getApproved(ethersService, contractAddress, tokenId, provider, chainId);
        const isApproved = await isApprovedForAll(ethersService, contractAddress, owner, fromAddress, provider, chainId);
        
        if (approved.toLowerCase() !== fromAddress.toLowerCase() && !isApproved) {
          throw new UnauthorizedTokenActionError(
            `Not authorized to transfer token #${tokenId}. You are not the owner or approved operator.`
          );
        }
      }
      
      // Create contract instance with signer
      const contractWithSigner = new ethers.Contract(contractAddress, ERC721_ABI, signer);
      
      // Prepare transaction overrides
      const overrides: ethers.Overrides = {};
      if (options.gasLimit) overrides.gasLimit = options.gasLimit;
      if (options.gasPrice) overrides.gasPrice = options.gasPrice;
      if (options.maxFeePerGas) overrides.maxFeePerGas = options.maxFeePerGas;
      if (options.maxPriorityFeePerGas) overrides.maxPriorityFeePerGas = options.maxPriorityFeePerGas;
      if (options.nonce !== undefined) overrides.nonce = options.nonce;
      if (options.value) overrides.value = options.value;
      
      // Send transaction
      const tx = await contractWithSigner.transferFrom(fromAddress, toAddress, tokenId, overrides);
      
      // Invalidate caches
      const ownerCacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC721_OWNER,
        contractAddress,
        tokenId,
        chainId
      );
      ensCache.delete(ownerCacheKey);
      
      return tx;
    } catch (error) {
      logger.debug('Error transferring NFT', { contractAddress, tokenId, error });
      throw handleTokenError(error, 'Failed to transfer NFT');
    }
  });
}

/**
 * Safely transfer an NFT to a new owner
 * 
 * @param ethersService EthersService instance
 * @param contractAddress NFT contract address
 * @param toAddress Recipient address
 * @param tokenId Token ID to transfer
 * @param data Optional data to include
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @param options Optional transaction options
 * @returns Promise with transaction response
 */
export async function safeTransferNFT(
  ethersService: EthersService,
  contractAddress: string,
  toAddress: string,
  tokenId: string | number,
  data: string = '0x',
  provider?: string,
  chainId?: number,
  options: TokenOperationOptions = {}
): Promise<ethers.TransactionResponse> {
  metrics.incrementCounter('erc721.safeTransferNFT');
  
  return timeAsync('erc721.safeTransferNFT', async () => {
    try {
      // Check rate limiting for write operations
      const identity = `${contractAddress}:safeTransfer`;
      if (!rateLimiter.consume('transaction', identity)) {
        throw new ERC721Error('Rate limit exceeded for NFT transfers');
      }
      
      // Get provider and signer from ethers service
      const signer = ethersService['getSigner'](provider, chainId);
      const fromAddress = await signer.getAddress();
      
      // Check ownership (reuses previous function)
      const owner = await ownerOf(ethersService, contractAddress, tokenId, provider, chainId);
      
      if (owner.toLowerCase() !== fromAddress.toLowerCase()) {
        // Check if signer is approved
        const approved = await getApproved(ethersService, contractAddress, tokenId, provider, chainId);
        const isApproved = await isApprovedForAll(ethersService, contractAddress, owner, fromAddress, provider, chainId);
        
        if (approved.toLowerCase() !== fromAddress.toLowerCase() && !isApproved) {
          throw new UnauthorizedTokenActionError(
            `Not authorized to transfer token #${tokenId}. You are not the owner or approved operator.`
          );
        }
      }
      
      // Create contract instance with signer
      const contractWithSigner = new ethers.Contract(contractAddress, ERC721_ABI, signer);
      
      // Prepare transaction overrides
      const overrides: ethers.Overrides = {};
      if (options.gasLimit) overrides.gasLimit = options.gasLimit;
      if (options.gasPrice) overrides.gasPrice = options.gasPrice;
      if (options.maxFeePerGas) overrides.maxFeePerGas = options.maxFeePerGas;
      if (options.maxPriorityFeePerGas) overrides.maxPriorityFeePerGas = options.maxPriorityFeePerGas;
      if (options.nonce !== undefined) overrides.nonce = options.nonce;
      if (options.value) overrides.value = options.value;
      
      // Send transaction with data parameter
      const tx = await contractWithSigner.safeTransferFrom(fromAddress, toAddress, tokenId, data, overrides);
      
      // Invalidate caches
      const ownerCacheKey = createTokenCacheKey(
        CACHE_KEYS.ERC721_OWNER,
        contractAddress,
        tokenId,
        chainId
      );
      ensCache.delete(ownerCacheKey);
      
      return tx;
    } catch (error) {
      logger.debug('Error safely transferring NFT', { contractAddress, tokenId, error });
      throw handleTokenError(error, 'Failed to safely transfer NFT');
    }
  });
}

/**
 * Approve an address to manage a specific NFT
 * 
 * @param ethersService EthersService instance
 * @param contractAddress NFT contract address
 * @param approvedAddress Address to approve
 * @param tokenId Token ID to approve for
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @param options Optional transaction options
 * @returns Promise with transaction response
 */
export async function approve(
  ethersService: EthersService,
  contractAddress: string,
  approvedAddress: string,
  tokenId: string | number,
  provider?: string,
  chainId?: number,
  options: TokenOperationOptions = {}
): Promise<ethers.TransactionResponse> {
  metrics.incrementCounter('erc721.approve');
  
  return timeAsync('erc721.approve', async () => {
    try {
      // Get provider and signer from ethers service
      const signer = ethersService['getSigner'](provider, chainId);
      const signerAddress = await signer.getAddress();
      
      // Check ownership
      const owner = await ownerOf(ethersService, contractAddress, tokenId, provider, chainId);
      
      if (owner.toLowerCase() !== signerAddress.toLowerCase()) {
        // Check if signer is approved for all
        const isApproved = await isApprovedForAll(ethersService, contractAddress, owner, signerAddress, provider, chainId);
        
        if (!isApproved) {
          throw new UnauthorizedTokenActionError(
            `Not authorized to approve token #${tokenId}. You are not the owner or approved operator.`
          );
        }
      }
      
      // Create contract instance with signer
      const contractWithSigner = new ethers.Contract(contractAddress, ERC721_ABI, signer);
      
      // Prepare transaction overrides
      const overrides: ethers.Overrides = {};
      if (options.gasLimit) overrides.gasLimit = options.gasLimit;
      if (options.gasPrice) overrides.gasPrice = options.gasPrice;
      if (options.maxFeePerGas) overrides.maxFeePerGas = options.maxFeePerGas;
      if (options.maxPriorityFeePerGas) overrides.maxPriorityFeePerGas = options.maxPriorityFeePerGas;
      if (options.nonce !== undefined) overrides.nonce = options.nonce;
      
      // Send transaction
      const tx = await contractWithSigner.approve(approvedAddress, tokenId, overrides);
      
      return tx;
    } catch (error) {
      logger.debug('Error approving address for NFT', { contractAddress, tokenId, approvedAddress, error });
      throw handleTokenError(error, 'Failed to approve address for NFT');
    }
  });
}

/**
 * Approve an operator to manage all NFTs
 * 
 * @param ethersService EthersService instance
 * @param contractAddress NFT contract address
 * @param operatorAddress Operator address to approve
 * @param approved Approval status to set
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @param options Optional transaction options
 * @returns Promise with transaction response
 */
export async function setApprovalForAll(
  ethersService: EthersService,
  contractAddress: string,
  operatorAddress: string,
  approved: boolean,
  provider?: string,
  chainId?: number,
  options: TokenOperationOptions = {}
): Promise<ethers.TransactionResponse> {
  metrics.incrementCounter('erc721.setApprovalForAll');
  
  return timeAsync('erc721.setApprovalForAll', async () => {
    try {
      // Get signer from ethers service
      const signer = ethersService['getSigner'](provider, chainId);
      
      // Create contract instance with signer
      const contractWithSigner = new ethers.Contract(contractAddress, ERC721_ABI, signer);
      
      // Prepare transaction overrides
      const overrides: ethers.Overrides = {};
      if (options.gasLimit) overrides.gasLimit = options.gasLimit;
      if (options.gasPrice) overrides.gasPrice = options.gasPrice;
      if (options.maxFeePerGas) overrides.maxFeePerGas = options.maxFeePerGas;
      if (options.maxPriorityFeePerGas) overrides.maxPriorityFeePerGas = options.maxPriorityFeePerGas;
      if (options.nonce !== undefined) overrides.nonce = options.nonce;
      
      // Send transaction
      const tx = await contractWithSigner.setApprovalForAll(operatorAddress, approved, overrides);
      
      return tx;
    } catch (error) {
      logger.debug('Error setting approval for all NFTs', { contractAddress, operatorAddress, approved, error });
      throw handleTokenError(error, 'Failed to set approval for all NFTs');
    }
  });
}

/**
 * Get all NFTs owned by an address
 * 
 * @param ethersService EthersService instance
 * @param contractAddress NFT contract address
 * @param ownerAddress Owner address to check
 * @param includeMetadata Whether to include metadata
 * @param provider Optional provider name or instance
 * @param chainId Optional chain ID
 * @returns Promise with array of owned NFTs
 */
export async function getUserNFTs(
  ethersService: EthersService,
  contractAddress: string,
  ownerAddress: string,
  includeMetadata: boolean = false,
  provider?: string,
  chainId?: number
): Promise<ERC721TokenInfo[]> {
  metrics.incrementCounter('erc721.getUserNFTs');
  
  return timeAsync('erc721.getUserNFTs', async () => {
    try {
      // Get provider from ethers service
      const ethersProvider = ethersService['getProvider'](provider, chainId);
      
      // Create contract instance
      const contract = new ethers.Contract(contractAddress, ERC721_ABI, ethersProvider);
      
      // Check if contract supports enumeration
      let supportsEnumeration = false;
      try {
        supportsEnumeration = await contract.supportsInterface('0x780e9d63'); // ERC721Enumerable
      } catch (error) {
        // Contract doesn't support supportsInterface, try with heuristic
        try {
          await contract.tokenOfOwnerByIndex(ownerAddress, 0);
          supportsEnumeration = true;
        } catch (error2) {
          supportsEnumeration = false;
        }
      }
      
      // Get NFT count for owner
      const balance = await contract.balanceOf(ownerAddress);
      const balanceNumber = Number(balance);
      
      if (balanceNumber === 0) {
        return [];
      }
      
      let ownedTokens: ERC721TokenInfo[] = [];
      
      if (supportsEnumeration) {
        // Contract supports enumeration, we can get tokens directly
        const tokenPromises = Array.from({ length: balanceNumber }, (_, i) => 
          contract.tokenOfOwnerByIndex(ownerAddress, i)
            .then(tokenId => ({ tokenId: tokenId.toString() }))
        );
        
        ownedTokens = await Promise.all(tokenPromises);
      } else {
        // Contract doesn't support enumeration, we need to scan events
        logger.debug('NFT contract does not support enumeration, using events', { contractAddress });
        
        // Find transfer events to this owner
        const filter = contract.filters.Transfer(null, ownerAddress);
        const events = await contract.queryFilter(filter);
        
        // Map of token IDs to ensure uniqueness (owner might have received same token multiple times)
        const tokenMap = new Map<string, boolean>();
        
        // Check current ownership of each token from events
        const ownershipChecks = events.map(async event => {
          // Check event type and use appropriate method to get tokenId
          const isEventLog = 'args' in event;
          
          // Access tokenId safely depending on event type
          const tokenId = isEventLog ? 
            (event as ethers.EventLog).args[2].toString() : 
            (event.topics && event.topics.length > 3 ? ethers.dataSlice(event.topics[3], 0) : '0');
          
          // Skip if we've already processed this token
          if (tokenMap.has(tokenId)) {
            return null;
          }
          
          tokenMap.set(tokenId, true);
          
          // Verify current ownership
          try {
            const currentOwner = await contract.ownerOf(tokenId);
            if (currentOwner.toLowerCase() === ownerAddress.toLowerCase()) {
              return { tokenId };
            }
          } catch {
            // Token no longer exists or not owned by user
          }
          
          return null;
        });
        
        // Filter out tokens that are no longer owned
        const tokensResults = await Promise.all(ownershipChecks);
        ownedTokens = tokensResults.filter(token => token !== null) as ERC721TokenInfo[];
      }
      
      // Include metadata if requested
      if (includeMetadata && ownedTokens.length > 0) {
        const metadataPromises = ownedTokens.map(async token => {
          try {
            token.metadata = await getMetadata(
              ethersService, 
              contractAddress, 
              token.tokenId, 
              provider, 
              chainId
            );
          } catch (error) {
            // Ignore metadata errors, just return token without metadata
            logger.debug('Error fetching metadata for token', { tokenId: token.tokenId, error });
          }
          return token;
        });
        
        ownedTokens = await Promise.all(metadataPromises);
      }
      
      return ownedTokens;
    } catch (error) {
      logger.debug('Error getting user NFTs', { contractAddress, ownerAddress, error });
      throw handleTokenError(error, 'Failed to get user NFTs');
    }
  });
}

================
File: src/services/erc/errors.ts
================
/**
 * @file ERC Standards Errors
 * @version 1.0.0
 * @lastModified 2024-06-07
 * 
 * Custom error classes for ERC token standards
 */

import { EthersServerError } from '../../utils/errors.js';

/**
 * Base class for token-related errors
 */
export class TokenError extends EthersServerError {
  constructor(message: string, code: string = 'TOKEN_ERROR', details?: Record<string, any>) {
    super(message, code, details, 400);
  }
}

/**
 * ERC20-specific errors
 */
export class ERC20Error extends TokenError {
  constructor(message: string, details?: Record<string, any>) {
    super(message, 'ERC20_ERROR', details);
  }
}

/**
 * ERC721-specific errors
 */
export class ERC721Error extends TokenError {
  constructor(message: string, details?: Record<string, any>) {
    super(message, 'ERC721_ERROR', details);
  }
}

/**
 * ERC1155-specific errors
 */
export class ERC1155Error extends TokenError {
  constructor(message: string, details?: Record<string, any>) {
    super(message, 'ERC1155_ERROR', details);
  }
}

/**
 * Error for insufficient token balance
 */
export class InsufficientBalanceError extends TokenError {
  constructor(tokenAddress: string, required: string, available: string, details?: Record<string, any>) {
    super(
      `Insufficient token balance. Required: ${required}, Available: ${available}`,
      'INSUFFICIENT_BALANCE',
      {
        tokenAddress,
        required,
        available,
        ...details
      }
    );
  }
}

/**
 * Error for insufficient allowance
 */
export class InsufficientAllowanceError extends ERC20Error {
  constructor(tokenAddress: string, spender: string, required: string, available: string, details?: Record<string, any>) {
    super(
      `Insufficient token allowance for spender. Required: ${required}, Available: ${available}`,
      {
        tokenAddress,
        spender,
        required,
        available,
        ...details
      }
    );
  }
}

/**
 * Error when token doesn't exist
 */
export class TokenNotFoundError extends TokenError {
  constructor(tokenAddress: string, tokenId?: string | number, details?: Record<string, any>) {
    super(
      tokenId 
        ? `Token ID ${tokenId} not found in contract ${tokenAddress}`
        : `Token contract not found at address ${tokenAddress}`,
      'TOKEN_NOT_FOUND',
      {
        tokenAddress,
        tokenId,
        ...details
      }
    );
  }
}

/**
 * Error when caller is not authorized
 */
export class UnauthorizedTokenActionError extends TokenError {
  constructor(message: string, details?: Record<string, any>) {
    super(
      message,
      'UNAUTHORIZED_TOKEN_ACTION',
      details
    );
  }
}

/**
 * Error when a token metadata URI is invalid or unreachable
 */
export class TokenMetadataError extends TokenError {
  constructor(tokenAddress: string, tokenId: string | number, uri?: string, details?: Record<string, any>) {
    super(
      `Failed to fetch metadata for token ID ${tokenId} in contract ${tokenAddress}`,
      'TOKEN_METADATA_ERROR',
      {
        tokenAddress,
        tokenId,
        uri,
        ...details
      }
    );
  }
}

/**
 * Helper function to handle common token errors
 */
export function handleTokenError(error: unknown, context: string): never {
  // Check if it's already a TokenError
  if (error instanceof TokenError) {
    throw error;
  }
  
  // Handle common Ethereum errors
  if (error instanceof Error) {
    const errorMessage = error.message.toLowerCase();
    
    if (errorMessage.includes('insufficient funds')) {
      throw new InsufficientBalanceError(
        'native', 
        'unknown',
        'unknown',
        { originalError: error.message }
      );
    }
    
    if (errorMessage.includes('execution reverted')) {
      if (errorMessage.includes('erc20: transfer amount exceeds balance')) {
        throw new InsufficientBalanceError(
          'unknown',
          'unknown',
          'unknown',
          { originalError: error.message }
        );
      }
      
      if (errorMessage.includes('erc20: transfer amount exceeds allowance')) {
        throw new InsufficientAllowanceError(
          'unknown',
          'unknown',
          'unknown',
          'unknown',
          { originalError: error.message }
        );
      }
      
      if (errorMessage.includes('owner query for nonexistent token')) {
        throw new TokenNotFoundError(
          'unknown',
          'unknown',
          { originalError: error.message }
        );
      }
      
      if (errorMessage.includes('not owner') || 
          errorMessage.includes('caller is not owner') ||
          errorMessage.includes('caller is not token owner')) {
        throw new UnauthorizedTokenActionError(
          'Not authorized to perform this action on the token',
          { originalError: error.message }
        );
      }
    }
    
    throw new TokenError(
      `${context}: ${error.message}`,
      'TOKEN_ERROR',
      { originalError: error.message }
    );
  }
  
  // Handle unknown errors
  throw new TokenError(
    `${context}: Unknown error`,
    'TOKEN_ERROR',
    { originalError: error }
  );
}

================
File: src/services/erc/index.ts
================
/**
 * @file ERC Standards Helpers Index
 * @version 1.0.0
 * @lastModified 2024-06-07
 * 
 * Exports all ERC token standard helpers
 */

// Re-export all helpers and types
export * as erc20 from './erc20.js';
export * as erc721 from './erc721.js';
export * as erc1155 from './erc1155.js';
export * from './types.js';
export * from './errors.js';
export * from './utils.js';
export * from './constants.js';

================
File: src/services/erc/types.ts
================
/**
 * @file ERC Standards Types
 * @version 1.0.0
 * @lastModified 2024-06-07
 * 
 * Type definitions for ERC token standards
 */

import { ethers } from 'ethers';

/**
 * Basic ERC20 token information
 */
export interface ERC20Info {
  name: string;
  symbol: string;
  decimals: number;
  totalSupply: string;
}

/**
 * Basic ERC721 NFT information
 */
export interface ERC721Info {
  name: string;
  symbol: string;
  totalSupply?: string;
}

/**
 * Extended NFT metadata based on ERC721 metadata standard
 */
export interface NFTMetadata {
  name?: string;
  description?: string;
  image?: string;
  image_data?: string;
  external_url?: string;
  animation_url?: string;
  background_color?: string;
  attributes?: Array<{
    trait_type?: string;
    value?: string | number;
    display_type?: string;
  }>;
  [key: string]: any; // Allow for additional properties
}

/**
 * ERC1155 token information with balance
 */
export interface ERC1155TokenInfo {
  tokenId: string;
  balance: string;
  metadata?: NFTMetadata;
}

/**
 * ERC721 token information
 */
export interface ERC721TokenInfo {
  tokenId: string;
  metadata?: NFTMetadata;
}

/**
 * Options for token operations
 */
export interface TokenOperationOptions {
  gasLimit?: string | number;
  gasPrice?: string | number;
  maxFeePerGas?: string | number;
  maxPriorityFeePerGas?: string | number;
  nonce?: number;
  value?: string;
  chainId?: number;
}

/**
 * Result of a token transaction
 */
export interface TokenTransactionResult {
  hash: string;
  wait: () => Promise<ethers.TransactionReceipt>;
}

================
File: src/services/erc/utils.ts
================
/**
 * @file ERC Standards Utilities
 * @version 1.0.0
 * @lastModified 2024-06-07
 * 
 * Utility functions for ERC token standards
 */

import { ethers } from 'ethers';
import { createCacheKey } from '../../utils/cache.js';
import { metrics, timeAsync } from '../../utils/metrics.js';
import { logger } from '../../utils/logger.js';
import { TokenNotFoundError, handleTokenError } from './errors.js';
import { INTERFACE_IDS } from './constants.js';
import { NFTMetadata } from './types.js';

/**
 * Interface check result with contract type
 */
interface ContractTypeResult {
  isERC20: boolean;
  isERC721: boolean;
  isERC1155: boolean;
}

/**
 * Check if an address is a valid contract and determine its type
 * 
 * @param address Contract address to check
 * @param provider Ethers provider
 * @returns ContractTypeResult with flags for contract types
 */
export async function checkContractType(
  address: string,
  provider: ethers.Provider
): Promise<ContractTypeResult> {
  try {
    // Check if the address has code (is a contract)
    const code = await provider.getCode(address);
    if (code === '0x' || code === '0x0') {
      throw new TokenNotFoundError(address);
    }
    
    // Create contract instance for interface checks
    const contract = new ethers.Contract(
      address,
      ['function supportsInterface(bytes4 interfaceId) view returns (bool)'],
      provider
    );
    
    let isERC721 = false;
    let isERC1155 = false;
    
    // Try ERC165 interface check first
    try {
      // Check if contract supports ERC165 interface
      const supportsERC165 = await contract.supportsInterface(INTERFACE_IDS.ERC165);
      
      if (supportsERC165) {
        // Check for ERC721
        isERC721 = await contract.supportsInterface(INTERFACE_IDS.ERC721);
        
        // Check for ERC1155
        isERC1155 = await contract.supportsInterface(INTERFACE_IDS.ERC1155);
      }
    } catch (error) {
      // Contract doesn't implement ERC165, continue with heuristic checks
      logger.debug('Contract does not support ERC165 interface check', { address });
    }
    
    // If we couldn't determine through supportsInterface, use heuristic approach
    if (!isERC721 && !isERC1155) {
      // Create contract with combined ABI for detection
      const detectContract = new ethers.Contract(
        address,
        [
          // ERC20 functions
          'function name() view returns (string)',
          'function symbol() view returns (string)',
          'function decimals() view returns (uint8)',
          'function totalSupply() view returns (uint256)',
          'function balanceOf(address) view returns (uint256)',
          'function transfer(address, uint256) returns (bool)',
          
          // ERC721 specific functions
          'function ownerOf(uint256) view returns (address)',
          'function tokenURI(uint256) view returns (string)',
          
          // ERC1155 specific functions
          'function balanceOfBatch(address[], uint256[]) view returns (uint256[])',
          'function uri(uint256) view returns (string)'
        ],
        provider
      );
      
      // Try to detect ERC20 by checking for common methods
      let isERC20 = false;
      try {
        // Check for basic ERC20 functions
        const [name, symbol, decimals] = await Promise.all([
          detectContract.name(),
          detectContract.symbol(),
          detectContract.decimals()
        ]);
        
        // If we got this far, it likely implements ERC20
        isERC20 = true;
      } catch (error) {
        isERC20 = false;
      }
      
      // If not already detected as ERC721, try additional checks
      if (!isERC721) {
        try {
          // Try calling ownerOf for token ID 1 - will fail if not ERC721
          // but we don't care about the result, just if the method exists
          await detectContract.ownerOf(1);
          isERC721 = true;
        } catch (error) {
          // If the error indicates "nonexistent token" it's likely an ERC721
          // with no token ID 1, otherwise it's not an ERC721
          const errorMsg = error instanceof Error ? error.message.toLowerCase() : '';
          isERC721 = errorMsg.includes('nonexistent token') || errorMsg.includes('invalid token id');
        }
      }
      
      // If not already detected as ERC1155, try additional checks
      if (!isERC1155) {
        try {
          // Try calling uri for token ID 1
          await detectContract.uri(1);
          isERC1155 = true;
        } catch (error) {
          isERC1155 = false;
        }
      }
      
      return { isERC20, isERC721, isERC1155 };
    }
    
    // If we determined through supportsInterface, assume it's not ERC20 if it's ERC721 or ERC1155
    const isERC20 = !isERC721 && !isERC1155;
    
    return { isERC20, isERC721, isERC1155 };
  } catch (error) {
    if (error instanceof TokenNotFoundError) {
      throw error;
    }
    
    logger.debug('Error checking contract type', { address, error });
    throw handleTokenError(error, 'Failed to determine contract type');
  }
}

/**
 * Fetches and parses metadata from a token URI
 * 
 * @param uri The URI to fetch metadata from
 * @param tokenAddress The token contract address
 * @param tokenId The token ID
 * @returns Parsed NFT metadata
 */
export async function fetchMetadata(
  uri: string,
  tokenAddress: string,
  tokenId: string | number
): Promise<NFTMetadata> {
  metrics.incrementCounter('token.metadata.fetch');
  return timeAsync('token.metadata.fetch', async () => {
    try {
      // Handle different URI formats
      let metadataUrl = uri;
      
      // Replace ipfs:// with https gateway
      if (uri.startsWith('ipfs://')) {
        metadataUrl = uri.replace('ipfs://', 'https://ipfs.io/ipfs/');
      }
      
      // Handle tokenID placeholder in URI
      metadataUrl = metadataUrl.replace('{id}', tokenId.toString());
      
      // Add timeout for fetch
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout
      
      try {
        const response = await fetch(metadataUrl, { 
          signal: controller.signal,
          headers: { 'Accept': 'application/json' }
        });
        
        if (!response.ok) {
          throw new Error(`Failed to fetch metadata: ${response.status} ${response.statusText}`);
        }
        
        const metadata = await response.json();
        return metadata as NFTMetadata;
      } finally {
        clearTimeout(timeoutId);
      }
    } catch (error) {
      logger.debug('Error fetching token metadata', { uri, tokenAddress, tokenId, error });
      
      // Return minimal metadata when fetch fails
      return {
        name: `Token #${tokenId}`,
        description: 'Metadata could not be retrieved',
        error: error instanceof Error ? error.message : String(error)
      };
    }
  });
}

/**
 * Creates a cache key for token data
 * 
 * @param keyPrefix Cache key prefix
 * @param tokenAddress Token contract address
 * @param additionalParts Additional parts to include in the key
 * @returns Cache key string
 */
export function createTokenCacheKey(
  keyPrefix: string,
  tokenAddress: string,
  ...additionalParts: (string | number | undefined)[]
): string {
  return createCacheKey(keyPrefix, tokenAddress.toLowerCase(), ...additionalParts);
}

================
File: src/services/ethersService.ts
================
/**
 * @file EthersService
 * @version 1.0.0
 * @status STABLE - DO NOT MODIFY WITHOUT TESTS
 * @lastModified 2024-03-11
 * 
 * Service for interacting with Ethereum via ethers.js
 * 
 * IMPORTANT:
 * - Any changes must be thoroughly tested
 * - Maintain backward compatibility with existing contracts
 * 
 * Functionality:
 * - Ethereum account & network management
 * - Contract interaction
 * - Transaction processing
 * - ERC token standards support
 */

import { ethers } from "ethers";
import { z } from "zod";
import { ConfigurationError, EthersServerError, NetworkError, ProviderError, TransactionError, WalletError, handleUnknownError } from "../utils/errors.js";
import { DefaultProvider, DEFAULT_PROVIDERS } from "../config/networks.js";
import { networkList, NetworkName, NetworkInfo } from "../config/networkList.js";
import * as erc20 from "./erc/erc20.js";
import * as erc721 from "./erc/erc721.js";
import * as erc1155 from "./erc/erc1155.js";
import { ERC20Info, ERC721Info, NFTMetadata, ERC721TokenInfo, ERC1155TokenInfo, TokenOperationOptions } from "./erc/types.js";
import { TokenError } from "./erc/errors.js";

// Move addressSchema to class level to avoid duplication
const addressSchema = z.string().refine(
    (address) => ethers.isAddress(address),
    { message: "Invalid Ethereum address format" }
);

const networkToEthersMap: Record<string, string> = {
    "Ethereum": "mainnet",
    "Polygon PoS": "matic",
    "Arbitrum": "arbitrum",
    "Arbitrum Nova": "arbitrum-nova",
    "Optimism": "optimism",
    "Avalanche C-Chain": "avalanche",
    "Base": "base",
    "BNB Smart Chain": "bnb",
    "Linea": "linea",
    "Polygon zkEVM": "polygon-zkevm"
};

// Add a mapping from common network names to official names
const NETWORK_ALIASES: Record<string, string> = {
    "mainnet": "Ethereum",
    "ethereum": "Ethereum",
    "eth": "Ethereum",
    "polygon": "Polygon PoS",
    "matic": "Polygon PoS",
    "bsc": "BNB Smart Chain",
    "binance": "BNB Smart Chain",
    "avalanche": "Avalanche C-Chain",
    "avax": "Avalanche C-Chain",
    "arbitrum": "Arbitrum",
    "arb": "Arbitrum",
    "optimism": "Optimism",
    "op": "Optimism",
    "base": "Base",
    "zksync": "ZKsync",
    "linea": "Linea",
    "scroll": "Scroll",
    "zkEVM": "Polygon zkEVM",
    "polygonZkEVM": "Polygon zkEVM"
};

export class EthersService {
    private _provider: ethers.Provider;
    private _signer?: ethers.Signer;

    constructor(provider?: ethers.Provider, signer?: ethers.Signer) {
        // Find a suitable default network if provider is not provided
        let defaultNetwork: DefaultProvider = DEFAULT_PROVIDERS.includes("Ethereum") ? 
            "Ethereum" : 
            DEFAULT_PROVIDERS.length > 0 ? DEFAULT_PROVIDERS[0] : "Ethereum";
            
        this._provider = provider || this.createAlchemyProvider(defaultNetwork);
        this._signer = signer;
    }

    get provider() {
        return this._provider;
    }

    setProvider(provider: ethers.Provider): void {
        this._provider = provider;
    }

    setSigner(signer: ethers.Signer): void {
        this._signer = signer;
    }

    private getAlchemyApiKey(): string {
        const apiKey = process.env.ALCHEMY_API_KEY;
        if (!apiKey) {
            throw new ConfigurationError("Alchemy API key is not set in environment variables", {
                variableName: "ALCHEMY_API_KEY"
            });
        }
        return apiKey;
    }

    private createAlchemyProvider(network: DefaultProvider): ethers.Provider {
        try {
            const apiKey = this.getAlchemyApiKey();
            
            // Map DefaultProvider names to Alchemy network names
            let alchemyNetwork: string;
            switch (network) {
                case "Ethereum":
                    alchemyNetwork = "mainnet";
                    break;
                case "Polygon PoS":
                    alchemyNetwork = "polygon";
                    break;
                case "Arbitrum":
                    alchemyNetwork = "arbitrum";
                    break;
                case "Arbitrum Nova":
                    alchemyNetwork = "arbitrum-nova";
                    break;
                case "Optimism":
                    alchemyNetwork = "optimism";
                    break;
                case "Avalanche C-Chain":
                    alchemyNetwork = "avalanche";
                    break;
                case "Base":
                    alchemyNetwork = "base";
                    break;
                default:
                    // For other networks, convert to lowercase and replace spaces with hyphens
                    alchemyNetwork = network.toLowerCase().replace(/ /g, "-");
            }
            
            return new ethers.AlchemyProvider(alchemyNetwork, apiKey);
        } catch (error) {
            if (error instanceof ConfigurationError) {
                throw error;
            }
            throw new NetworkError(`Failed to create Alchemy provider for network ${network}`, {
                network, error
            });
        }
    }

    private validateRpcUrl(url: string): void {
        if (!url.startsWith('http://') && !url.startsWith('https://') && !url.startsWith('ws://') && !url.startsWith('wss://')) {
            throw new NetworkError(`Invalid RPC URL format: ${url}`, {
                url
            });
        }
    }

    private handleProviderError(error: unknown, context: string, details?: Record<string, any>): never {
        if (error instanceof EthersServerError) {
            throw error;
        }

        if (error instanceof Error) {
            const errorMessage = error.message.toLowerCase();
            
            if (errorMessage.includes('network') || errorMessage.includes('connection') || errorMessage.includes('timeout')) {
                throw new NetworkError(`Network error while trying to ${context}: ${error.message}`, {
                    ...details,
                    originalError: error
                });
            }
            
            if (errorMessage.includes('contract') || errorMessage.includes('abi')) {
                throw new ProviderError(`Contract error while trying to ${context}: ${error.message}`, {
                    ...details,
                    originalError: error
                });
            }
            
            if (errorMessage.includes('transaction') || errorMessage.includes('gas') || errorMessage.includes('fee')) {
                throw new TransactionError(`Transaction error while trying to ${context}: ${error.message}`, {
                    ...details,
                    originalError: error
                });
            }
        }
        
        throw handleUnknownError(error);
    }

    private serializeValue(value: any): string {
        if (value === undefined || value === null) {
            return 'null';
        }
        
        if (typeof value === 'bigint') {
            return value.toString();
        }
        
        if (Array.isArray(value)) {
            return `[${value.map(v => this.serializeValue(v)).join(', ')}]`;
        }
        
        if (typeof value === 'object') {
            // Skip internal properties of ethers
            if (value._isSigner || value._isProvider || value._isFragment) {
                return '[Object]';
            }
            
            try {
            return JSON.stringify(value, (_, v) => 
                typeof v === 'bigint' ? v.toString() : v
            );
            } catch (e) {
                return '[Object]';
        }
        }
        
        return String(value);
    }

    private getEthersNetworkName(network: string): string {
        return network in networkList ? network : 'mainnet';
    }

    private getProvider(provider?: string, chainId?: number): ethers.Provider {
        // If no provider specified, return the default provider
        if (!provider) {
            return this._provider;
        }

        let selectedProvider: ethers.Provider;
        
        // Check if the provider is an alias and convert it to the official name
        const normalizedProvider = NETWORK_ALIASES[provider.toLowerCase()] || provider;
        
        // Check if provider is a named network in our list
        if (normalizedProvider in networkList) {
            const network = normalizedProvider as NetworkName;
            const networkInfo = networkList[network];
            
            // If chainId is provided, verify it matches the network
            if (chainId !== undefined && networkInfo.chainId !== chainId) {
                throw new NetworkError(`Chain ID mismatch: requested ${chainId}, but network ${network} has chain ID ${networkInfo.chainId}`, {
                    requestedChainId: chainId,
                    networkChainId: networkInfo.chainId,
                    network
                });
            }
            
            // For Ethereum mainnet and common networks, use Alchemy
            if (DEFAULT_PROVIDERS.includes(network as DefaultProvider)) {
                try {
                    selectedProvider = this.createAlchemyProvider(network as DefaultProvider);
            } catch (error) {
                    // Fall back to custom RPC if Alchemy fails
                    // Check if this is an Alchemy URL that needs the API key appended
                    if (networkInfo.RPC.includes('alchemy.com/v2/')) {
                        try {
                            const apiKey = this.getAlchemyApiKey();
                            const rpcWithApiKey = networkInfo.RPC + apiKey;
                            this.validateRpcUrl(rpcWithApiKey);
                            selectedProvider = new ethers.JsonRpcProvider(rpcWithApiKey);
                        } catch (apiError) {
                            throw new NetworkError(`Failed to create provider for network ${network}: API key error`, {
                                network, error: apiError
                            });
                        }
                    } else {
                        this.validateRpcUrl(networkInfo.RPC);
                        selectedProvider = new ethers.JsonRpcProvider(networkInfo.RPC);
                    }
                }
            } else {
                // For other networks, use the custom RPC
                // Check if this is an Alchemy URL that needs the API key appended
                if (networkInfo.RPC.includes('alchemy.com/v2/')) {
                    try {
                        const apiKey = this.getAlchemyApiKey();
                        const rpcWithApiKey = networkInfo.RPC + apiKey;
                        this.validateRpcUrl(rpcWithApiKey);
                        selectedProvider = new ethers.JsonRpcProvider(rpcWithApiKey);
                    } catch (apiError) {
                        throw new NetworkError(`Failed to create provider for network ${network}: API key error`, {
                            network, error: apiError
                        });
                    }
                } else {
                    this.validateRpcUrl(networkInfo.RPC);
                    selectedProvider = new ethers.JsonRpcProvider(networkInfo.RPC);
                }
            }
        } else {
            // Assume provider is a custom RPC URL
            this.validateRpcUrl(normalizedProvider);
            selectedProvider = new ethers.JsonRpcProvider(normalizedProvider);
            
            // If chainId is provided, check if it matches the network
            if (chainId !== undefined) {
                // This will be checked when connecting to the network
                // and throw an error if mismatched
            }
        }

        return selectedProvider;
    }

    async getBalance(address: string, provider?: string, chainId?: number): Promise<string> {
        try {
            addressSchema.parse(address);
            const selectedProvider = this.getProvider(provider, chainId);
            const balance = await selectedProvider.getBalance(address);
            return ethers.formatEther(balance);
        } catch (error) {
            this.handleProviderError(error, "fetch balance", { address });
        }
    }

    // Note: This method signature is kept for backward compatibility
    // but internally delegates to the erc20 module
    async getERC20Balance(address: string, tokenAddress: string, provider?: string, chainId?: number): Promise<string> {
        try {
            addressSchema.parse(address);
            addressSchema.parse(tokenAddress);
            return await erc20.getBalance(this, tokenAddress, address, provider, chainId);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "fetch ERC20 balance", { address, tokenAddress });
        }
    }

    async getTransactionCount(address: string, provider?: string, chainId?: number): Promise<number> {
        try {
            addressSchema.parse(address);
            const selectedProvider = this.getProvider(provider, chainId);
            const count = await selectedProvider.getTransactionCount(address);
            return count;
        } catch (error) {
            this.handleProviderError(error, "fetch transaction count", { address });
        }
    }

    async getBlockNumber(provider?: string, chainId?: number): Promise<number> {
        try {
            const selectedProvider = this.getProvider(provider, chainId);
            return await selectedProvider.getBlockNumber();
        } catch (error) {
            this.handleProviderError(error, "fetch latest block number");
        }
    }

    async getBlockDetails(blockTag: string | number, provider?: string, chainId?: number): Promise<ethers.Block | null> {
        try {
            const selectedProvider = this.getProvider(provider, chainId);
            const block = await selectedProvider.getBlock(blockTag);
            return block;
        } catch (error) {
            this.handleProviderError(error, "fetch block details", { blockTag: String(blockTag) });
        }
    }

    async getTransactionDetails(txHash: string, provider?: string, chainId?: number): Promise<ethers.TransactionResponse | null> {
        try {
            const txSchema = z.string().regex(/^0x[a-fA-F0-9]{64}$/);
            txSchema.parse(txHash);
            let selectedProvider = this.getProvider(provider, chainId);

            if (!provider && !chainId) {
                try {
                    const derivedChainId = await this.getChainIdFromTransaction(txHash);
                    selectedProvider = this.getProvider(provider, derivedChainId);
                } catch (error) {
                    // If we can't get the chainId, continue with the default provider
                    console.warn("Could not derive chainId from transaction, using default provider");
                }
            }
            return await selectedProvider.getTransaction(txHash);
        } catch (error) {
            this.handleProviderError(error, "fetch transaction details", { txHash });
        }
    }

    async getGasPrice(provider?: string, chainId?: number): Promise<string> {
        try {
            const selectedProvider = this.getProvider(provider, chainId);
            const feeData = await selectedProvider.getFeeData();
            return ethers.formatUnits(feeData.gasPrice || 0n, "gwei");
        } catch (error) {
            this.handleProviderError(error, "get gas price");
        }
    }

    async getFeeData(provider?: string, chainId?: number): Promise<ethers.FeeData> {
        try {
            const selectedProvider = this.getProvider(provider, chainId);
            return await selectedProvider.getFeeData();
        } catch (error) {
            this.handleProviderError(error, "get fee data");
        }
    }

    async getContractCode(address: string, provider?: string, chainId?: number): Promise<string | null> {
        try {
            addressSchema.parse(address);
            const selectedProvider = this.getProvider(provider, chainId);
            return await selectedProvider.getCode(address);
        } catch (error) {
            this.handleProviderError(error, "get contract bytecode", { address });
        }
    }

    async lookupAddress(address: string, provider?: string, chainId?: number): Promise<string | null> {
        try {
            addressSchema.parse(address);
            const selectedProvider = this.getProvider(provider, chainId);
            return await selectedProvider.lookupAddress(address);
        } catch (error) {
            this.handleProviderError(error, "look up ENS name for address", { address });
        }
    }

    async resolveName(name: string, provider?: string, chainId?: number): Promise<string | null> {
        try {
            const selectedProvider = this.getProvider(provider, chainId);
            return await selectedProvider.resolveName(name);
        } catch (error) {
            this.handleProviderError(error, "resolve ENS name", { name });
        }
    }

    formatEther(wei: string | number | bigint): string {
        try {
            return ethers.formatEther(wei);
        } catch (error) {
            this.handleProviderError(error, "format Ether value", { wei: String(wei) });
        }
    }

    parseEther(ether: string): bigint {
        try {
            return ethers.parseEther(ether);
        } catch (error) {
            this.handleProviderError(error, "parse Ether string", { ether });
        }
    }

    formatUnits(value: string | number | bigint, unit: string | number): string {
        try {
            return ethers.formatUnits(value, unit);
        } catch (error) {
            this.handleProviderError(error, "format units", { value: String(value), unit: String(unit) });
        }
    }

    parseUnits(value: string, unit: string | number): bigint {
        try {
            return ethers.parseUnits(value, unit);
        } catch (error) {
            this.handleProviderError(error, "parse units", { value, unit: String(unit) });
        }
    }

    private getSigner(provider?: string, chainId?: number, signerOverride?: ethers.Signer): ethers.Signer {
        if (signerOverride) {
            return signerOverride;
        }

        if (this._signer) {
            return this._signer;
        }
        
        const privateKey = process.env.PRIVATE_KEY;
        if (!privateKey) {
            throw new Error("Missing PRIVATE_KEY in environment variables. Either provide a signer in the constructor or set PRIVATE_KEY in environment variables.");
        }
        const selectedProvider = this.getProvider(provider, chainId);
        return new ethers.Wallet(privateKey, selectedProvider);
    }

    async createTransaction(to: string, value: string, data?: string, provider?: string): Promise<ethers.TransactionRequest> {
        try {
            addressSchema.parse(to);
            const parsedValue = ethers.parseEther(value);

            const transaction: ethers.TransactionRequest = {
                to,
                value: parsedValue,
                data: data || "0x",
            };
            
            const signer = this.getSigner(provider);
            const populatedTx = await signer.populateTransaction(transaction);
            return populatedTx;
        } catch (error) {
            this.handleProviderError(error, "create transaction", { to, value });
        }
    }

    async estimateGas(tx: ethers.TransactionRequest, provider?: string): Promise<bigint> {
        try {
            const signer = this.getSigner(provider);
            const result = await signer.estimateGas(tx);
            return result;
        } catch (error) {
            this.handleProviderError(error, "estimate gas", { tx: JSON.stringify(tx) });
        }
    }

    async sendTransaction(
        toOrTx: string | ethers.TransactionRequest,
        value?: string,
        data?: string,
        provider?: string
    ): Promise<ethers.TransactionResponse> {
        try {
            let tx: ethers.TransactionRequest;
            
            if (typeof toOrTx === 'string') {
                // Handle old-style parameter based call
                addressSchema.parse(toOrTx);
                tx = {
                    to: toOrTx,
                    value: value ? ethers.parseEther(value) : undefined,
                    data: data || "0x"
                };
            } else {
                // Handle object-style call
                if (toOrTx.to) {
                    addressSchema.parse(toOrTx.to);
                }
                tx = toOrTx;
            }

            const signer = this.getSigner(provider);
            return await signer.sendTransaction(tx);
        } catch (error) {
            this.handleProviderError(error, "send transaction", { tx: toOrTx });
        }
    }

    async signMessage(message: string, provider?: string): Promise<string> {
        try {
            const signer = this.getSigner(provider);
            return await signer.signMessage(message);
        } catch (error) {
            this.handleProviderError(error, "sign message", { message });
        }
    }

    /**
     * Signs data using the Ethereum eth_sign method (legacy)
     * Note: This method is less secure than signMessage (personal_sign) as it can sign transaction-like data
     * 
     * @param data The data to sign (as a hex string)
     * @param provider Optional provider name or URL
     * @returns The signature as a hexadecimal string
     */
    async ethSign(data: string, provider?: string): Promise<string> {
        try {
            // Ensure data is properly formatted as hex
            if (!data.startsWith('0x')) {
                data = '0x' + Buffer.from(data).toString('hex');
            }
            
            const signer = this.getSigner(provider);
            
            // In ethers v6, we can use signMessage for both personal_sign and eth_sign
            // The difference is in how the message is formatted
            
            // For eth_sign, we use the raw data without the Ethereum prefix
            // This is a lower-level operation and should be used with caution
            
            // Convert hex to bytes
            const dataBytes = ethers.getBytes(data);
            
            // Sign the raw bytes
            // Note: This is equivalent to eth_sign in most cases
            const signature = await signer.signMessage(dataBytes);
            
            return signature;
        } catch (error) {
            this.handleProviderError(error, "eth_sign", { data });
        }
    }

    async contractCall(
        contractAddress: string,
        abi: string | Array<string>,
        method: string,
        args: any[] = [],
        provider?: string,
        chainId?: number
    ): Promise<any> {
        try {
            addressSchema.parse(contractAddress);
            const selectedProvider = this.getProvider(provider, chainId);
            
            // Parse ABI if it's a string
            let parsedAbi: any = abi;
            if (typeof abi === 'string') {
                try {
                    parsedAbi = JSON.parse(abi);
                } catch (e) {
                    throw new Error(`Invalid ABI: ${abi}. The ABI must be a valid JSON string or array of strings`);
                }
            }
            
            // Create contract instance with provider
            const contract = new ethers.Contract(
                contractAddress,
                parsedAbi,
                selectedProvider
            );

            // Get function fragment to check if it's view/pure
            const fragment = contract.interface.getFunction(method);
            if (!fragment) {
                throw new Error(`Method ${method} not found in contract ABI`);
            }

            // For view/pure functions, use provider directly
            if (fragment.constant || fragment.stateMutability === 'view' || fragment.stateMutability === 'pure') {
                const result = await contract.getFunction(method).staticCall(...args);
                return this.serializeEventArgs(result); // Use our serializer for the result
            }

            throw new Error(`Use contractSendTransaction for state-changing function: ${method}`);
        
        } catch (error) {
            this.handleProviderError(error, `call contract method: ${method}`, {
                contractAddress,
                abi: typeof abi === 'string' ? abi : JSON.stringify(abi),
                args: this.serializeValue(args),
            });
        }
    }

    async contractCallView(
        contractAddress: string,
        abi: string | Array<string>,
        method: string,
        args: any[] = [],
        provider?: string,
        chainId?: number
    ): Promise<any> {
        try {
            addressSchema.parse(contractAddress);
            const selectedProvider = this.getProvider(provider, chainId);
            
            // Parse ABI if it's a string
            let parsedAbi: any = abi;
            if (typeof abi === 'string') {
                try {
                    parsedAbi = JSON.parse(abi);
                } catch (e) {
                    throw new Error(`Invalid ABI: ${abi}. The ABI must be a valid JSON string or array of strings`);
                }
            }
            
            // Create contract instance with provider
            const contract = new ethers.Contract(
                contractAddress,
                parsedAbi,
                selectedProvider
            );

            // Get function fragment to check if it's view/pure
            const fragment = contract.interface.getFunction(method);
            if (!fragment) {
                throw new Error(`Method ${method} not found in contract ABI`);
            }

            // For view/pure functions, use provider directly
            if (!fragment.constant && fragment.stateMutability !== 'view' && fragment.stateMutability !== 'pure') {
                throw new Error(`Use contractSendTransaction for state-changing function: ${method}`);
            }

            const result = await contract.getFunction(method).staticCall(...args);
            return this.serializeEventArgs(result); // Use our serializer for the result
        } catch (error) {
            this.handleProviderError(error, `call contract view method: ${method}`, {
                contractAddress,
                abi: typeof abi === 'string' ? abi : JSON.stringify(abi),
                args: this.serializeValue(args),
            });
        }
    }

    async contractCallWithEstimate(
        contractAddress: string,
        abi: string,
        method: string,
        args: any[] = [],
        value: string = "0",
        provider?: string
    ): Promise<any> {
        try {
            addressSchema.parse(contractAddress);
            const signer = this.getSigner(provider);
            const contract = new ethers.Contract(
                contractAddress,
                abi,
                signer
            );
            const parsedValue = ethers.parseEther(value);
            
            // Get the function fragment for the method
            const fragment = contract.interface.getFunction(method);
            if (!fragment) {
                throw new Error(`Method ${method} not found in contract ABI`);
            }
            
            // Encode the function data
            const data = contract.interface.encodeFunctionData(fragment, args);
            
            // Create the transaction request
            const tx = {
                to: contractAddress,
                data,
                value: parsedValue
            };
            
            // Estimate the gas
            const estimatedGas = await signer.estimateGas(tx);
            
            // Add the estimated gas and send the transaction
            return await this.contractSendTransaction(
                contractAddress,
                abi,
                method,
                args,
                value,
                provider,
                { gasLimit: estimatedGas }
            );
        } catch (error) {
            this.handleProviderError(error, `call contract method with estimate: ${method}`, {
                contractAddress,
                abi: JSON.stringify(abi),
                args: JSON.stringify(args),
                value
            });
        }
    }

    async contractCallWithOverrides(
        contractAddress: string,
        abi: string,
        method: string,
        args: any[] = [],
        value: string = "0",
        provider?: string,
        overrides?: ethers.Overrides
    ): Promise<any> {
        try {
            addressSchema.parse(contractAddress);
            const signer = this.getSigner(provider);
            const contract = new ethers.Contract(
                contractAddress,
                abi,
                signer
            );
            const parsedValue = ethers.parseEther(value);
            
            // Get the function fragment for the method
            const fragment = contract.interface.getFunction(method);
            if (!fragment) {
                throw new Error(`Method ${method} not found in contract ABI`);
            }
            
            // Merge value with other overrides
            const txOverrides = {
                ...overrides,
                value: parsedValue
            };
            
            // Call the contract method with overrides
            const tx = await contract[method](...args, txOverrides);
            return tx;
        } catch (error) {
            this.handleProviderError(error, `call contract method with overrides: ${method}`, {
                contractAddress,
                abi: JSON.stringify(abi),
                args: this.serializeValue(args),
                value,
                overrides: this.serializeValue(overrides)
            });
        }
    }

    async contractSendTransaction(
        contractAddress: string,
        abi: string,
        method: string,
        args: any[] = [],
        value: string = "0",
        provider?: string,
        overrides?: ethers.Overrides
    ): Promise<ethers.TransactionResponse> {
        try {
            addressSchema.parse(contractAddress);
            const signer = this.getSigner(provider);
            const contract = new ethers.Contract(
                contractAddress,
                abi,
                signer
            );
            const parsedValue = ethers.parseEther(value);
            
            // Get the function fragment for the method
            const fragment = contract.interface.getFunction(method);
            if (!fragment) {
                throw new Error(`Method ${method} not found in contract ABI`);
            }
            
            // Encode the function data
            const data = contract.interface.encodeFunctionData(fragment, args);
            
            // Create the transaction request with overrides
            const tx = {
                to: contractAddress,
                data,
                value: parsedValue,
                ...overrides
            };
            
            // Send the transaction
            return await signer.sendTransaction(tx);
        } catch (error) {
            this.handleProviderError(error, `send transaction to contract method: ${method}`, {
                contractAddress,
                abi: JSON.stringify(abi),
                args: JSON.stringify(args),
                value
            });
        }
    }

    async contractSendTransactionWithEstimate(
        contractAddress: string,
        abi: string,
        method: string,
        args: any[],
        value: string = "0",
        provider?: string
    ): Promise<ethers.TransactionResponse> {
        try {
            const parsedAddress = addressSchema.parse(contractAddress);
            const contract = new ethers.Contract(parsedAddress, abi, await this.getSigner(provider));
            const parsedValue = ethers.parseEther(value);

            // Get the function fragment for the method
            const fragment = contract.interface.getFunction(method);
            if (!fragment) {
                throw new Error(`Method ${method} not found in contract ABI`);
            }
            
            // Encode the function data with value
            const data = contract.interface.encodeFunctionData(fragment, args);
            const tx = {
                to: parsedAddress,
                data,
                value: parsedValue
            };

            // Estimate gas
            const gasEstimate = await contract.getFunction(method).estimateGas(...args, { value: parsedValue });
            
            // Send transaction with estimated gas
            return await contract.getFunction(method)(...args, {
                value: parsedValue,
                gasLimit: gasEstimate
            });
        } catch (error) {
            throw this.handleProviderError(error, `send transaction to contract method with estimate: ${method}`, {
                contractAddress,
                abi: JSON.stringify(abi),
                args: JSON.stringify(args),
                value
            });
        }
    }

    async contractSendTransactionWithOverrides(
        contractAddress: string,
        abi: string,
        method: string,
        args: any[],
        value: string = "0",
        provider?: string,
        overrides: ethers.Overrides = {}
    ): Promise<ethers.TransactionResponse> {
        try {
            const parsedAddress = addressSchema.parse(contractAddress);
            const contract = new ethers.Contract(parsedAddress, abi, await this.getSigner(provider));
            const parsedValue = ethers.parseEther(value);

            // Get the function fragment for the method
            const fragment = contract.interface.getFunction(method);
            if (!fragment) {
                throw new Error(`Method ${method} not found in contract ABI`);
            }
            
            // Merge value with other overrides
            const txOverrides = {
                ...overrides,
                value: parsedValue
            };

            // Encode the function data
            const data = contract.interface.encodeFunctionData(fragment, args);
            
            // Send transaction with overrides
            return await contract.getFunction(method)(...args, txOverrides);
        } catch (error) {
            throw this.handleProviderError(error, `send transaction to contract method with overrides: ${method}`, {
                contractAddress,
                abi: JSON.stringify(abi),
                args: this.serializeValue(args),
                value,
                overrides: this.serializeValue(overrides)
            });
        }
    }

    async sendRawTransaction(
        signedTransaction: string,
        provider?: string
    ): Promise<ethers.TransactionResponse> {
        try {
            const selectedProvider = this.getProvider(provider);
            return await selectedProvider.broadcastTransaction(signedTransaction);
        } catch (error) {
            this.handleProviderError(error, "send raw transaction", { signedTransaction });
        }
    }

    private formatEvent(log: ethers.EventLog | ethers.Log): any {
        const formattedEvent = {
            address: log.address,
            blockNumber: log.blockNumber?.toString(),
            transactionHash: log.transactionHash,
            logIndex: log.index,
            name: 'eventName' in log ? log.eventName : undefined,
            args: 'args' in log ? this.serializeEventArgs(log.args) : undefined,
            data: log.data,
            topics: log.topics
        };
        return formattedEvent;
    }

    private serializeEventArgs(args: any): any {
        if (args === null || args === undefined) return args;
        if (typeof args === 'bigint') return args.toString();
        if (Array.isArray(args)) {
            return args.map(arg => this.serializeEventArgs(arg));
        }
        if (typeof args === 'object') {
            const serialized: any = {};
            for (const [key, value] of Object.entries(args)) {
                if (key === 'length' && Array.isArray(args)) continue;
                if (key === '_isBigNumber' || key === 'type' || key === 'hash') continue; // Skip internal ethers properties
                serialized[key] = this.serializeEventArgs(value);
            }
            return serialized;
        }
        return args;
    }

    async queryLogs(
        address?: string,
        topics?: Array<string | null | Array<string>>,
        fromBlock?: string | number,
        toBlock?: string | number,
        provider?: string,
        chainId?: number
    ): Promise<any> {
        try {
            let checksummedAddress: string | undefined;
            if (address) {
                checksummedAddress = ethers.getAddress(address);
            }
            const selectedProvider = this.getProvider(provider, chainId);
            const filter: ethers.Filter = {
                address: checksummedAddress,
                topics: topics
            };

            const logs = await selectedProvider.getLogs({
                ...filter,
                fromBlock: fromBlock,
                toBlock: toBlock
            });

            return logs.map((log) => this.formatEvent(log));
        } catch (error) {
            this.handleProviderError(error, "query logs", {
                address: address || "any",
                topics: topics ? JSON.stringify(topics) : "any",
                fromBlock: String(fromBlock || "any"),
                toBlock: String(toBlock || "any")
            });
        }
    }

    async contractEvents(
        contractAddress: string,
        abi: string | Array<string>,
        eventName?: string,
        topics?: Array<string | null | Array<string>>,
        fromBlock?: string | number,
        toBlock?: string | number,
        provider?: string,
        chainId?: number
    ): Promise<any> {
        try {
            // Use queryLogs under the hood as it's more reliable
            const checksummedAddress = ethers.getAddress(contractAddress);
            const selectedProvider = this.getProvider(provider, chainId);
            const contract = new ethers.Contract(checksummedAddress, abi, selectedProvider);

            // If no event name specified, get all events
            if (!eventName) {
                return this.queryLogs(
                    checksummedAddress,
                    topics,
                    fromBlock,
                    toBlock,
                    provider,
                    chainId
                );
            }

            // Get the event fragment to encode topics
            const fragment = contract.interface.getEvent(eventName);
            if (!fragment) {
                throw new Error(`Event ${eventName} not found in contract ABI`);
            }

            // Get the topic hash for this event
            const topicHash = fragment.topicHash;
            const eventTopics: (string | null | Array<string>)[] = [topicHash];
            if (topics && topics.length > 0) {
                eventTopics.push(...topics);
            }

            // Use queryLogs with the event-specific topic
            const logs = await this.queryLogs(
                checksummedAddress,
                eventTopics,
                fromBlock,
                toBlock,
                provider,
                chainId
            );

            // Parse the logs with the contract interface
            return logs.map((log: ethers.Log) => {
                try {
                    const parsedLog = contract.interface.parseLog({
                        topics: log.topics,
                        data: log.data
                    });
                    return {
                        ...log,
                        name: parsedLog?.name,
                        args: this.serializeEventArgs(parsedLog?.args)
                    };
                } catch (e) {
                    // If parsing fails, return the raw log
                    return log;
                }
            });
        } catch (error) {
            this.handleProviderError(error, "query contract events", {
                contractAddress,
                abi: typeof abi === 'string' ? abi : JSON.stringify(abi),
                eventName: eventName || "any",
                topics: topics ? this.serializeValue(topics) : "any",
                fromBlock: String(fromBlock || "any"),
                toBlock: String(toBlock || "any")
            });
        }
    }

    async sendTransactionWithOptions(
        toOrTx: string | ethers.TransactionRequest,
        value?: string,
        data?: string,
        gasLimit?: string,
        gasPrice?: string,
        nonce?: number,
        provider?: string,
        chainId?: number,
        signerOverride?: ethers.Signer
    ): Promise<ethers.TransactionResponse> {
        try {
            let tx: ethers.TransactionRequest;
            
            if (typeof toOrTx === 'string') {
                addressSchema.parse(toOrTx);
                tx = {
                    to: toOrTx,
                    value: value ? ethers.parseEther(value) : undefined,
                    data: data || "0x",
                    gasLimit: gasLimit ? ethers.getBigInt(gasLimit) : undefined,
                    gasPrice: gasPrice ? ethers.parseUnits(gasPrice, "gwei") : undefined,
                    nonce,
                };
            } else {
                if(toOrTx.to) {
                    addressSchema.parse(toOrTx.to);
                }
                tx = {
                    ...toOrTx,
                    gasLimit: gasLimit ? ethers.getBigInt(gasLimit) : undefined,
                    gasPrice: gasPrice ? ethers.parseUnits(gasPrice, "gwei") : undefined,
                    nonce,
                }
            }

            const signer = this.getSigner(provider, chainId, signerOverride);
            return await signer.sendTransaction(tx);
        } catch (error) {
            this.handleProviderError(error, "send transaction with options", {
                tx: toOrTx, value, data, gasLimit, gasPrice, nonce
            });
        }
    }

    getSupportedNetworks(): Array<{
        name: string;
        chainId?: number;
        isTestnet?: boolean;
        nativeCurrency?: {
            name: string;
            symbol: string;
            decimals: number;
        };
        isDefault?: boolean;
    }> {
        try {
            const defaultNetwork = process.env.DEFAULT_NETWORK || "mainnet";
            return DEFAULT_PROVIDERS.map((network) => {
                const networkInfo = networkList[network as NetworkName];
                    return {
                        name: network,
                    chainId: networkInfo?.chainId,
                    isTestnet: network.toLowerCase().includes('testnet') || 
                              network.toLowerCase().includes('goerli') || 
                              network.toLowerCase().includes('sepolia'),
                        nativeCurrency: {
                        name: networkInfo?.currency || 'Native Token',
                        symbol: networkInfo?.currency || 'NATIVE',
                            decimals: 18
                    },
                    isDefault: network === defaultNetwork
                };
            });
        } catch (error) {
            throw this.handleProviderError(error, "get supported networks");
        }
    }


    async getWalletInfo(provider?: string): Promise<{ address: string } | null> {
        try {
            if (!this._signer) {
                return null;
            }
            
            const selectedProvider = provider ? this.getProvider(provider) : this._provider;
            const signer = this._signer.connect(selectedProvider);
            const address = await signer.getAddress();
            
            return { address };
        } catch (error) {
            this.handleProviderError(error, "get wallet info");
        }
    }

    async getChainIdFromTransaction(txHash: string, provider?: string): Promise<number> {
        try {
            const txSchema = z.string().regex(/^0x[a-fA-F0-9]{64}$/);
            txSchema.parse(txHash);
            const selectedProvider = this.getProvider(provider);
            const tx = await selectedProvider.getTransaction(txHash);
            if (!tx) {
                throw new Error("Transaction not found");
            }
            
            return Number(tx.chainId);
        } catch (error) {
            this.handleProviderError(error, "fetch transaction details", { txHash });
        }
    }

    async getTransactionsByBlock(blockTag: string | number, provider?: string, chainId?: number): Promise<ethers.TransactionResponse[]> {
        try {
            const selectedProvider = this.getProvider(provider, chainId);
            const block = await selectedProvider.getBlock(blockTag, true);
            if (!block || !block.transactions) {
                return [];
            }
            const transactionRequests = await Promise.all(block.transactions.map(tx => selectedProvider.getTransaction(tx)));
            return transactionRequests.filter((tx): tx is ethers.TransactionResponse => tx != null);
        } catch (error) {
            this.handleProviderError(error, "get transactions by block", { blockTag: String(blockTag) });
        }
    }

    // ERC20 Token Methods

    /**
     * Get basic information about an ERC20 token
     * 
     * @param tokenAddress Token contract address
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @returns Promise with token information
     */
    async getERC20TokenInfo(
        tokenAddress: string,
        provider?: string,
        chainId?: number
    ): Promise<ERC20Info> {
        try {
            addressSchema.parse(tokenAddress);
            return await erc20.getTokenInfo(this, tokenAddress, provider, chainId);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "get ERC20 token info", { tokenAddress });
        }
    }

    /**
     * Get the allowance amount approved for a spender
     * 
     * @param tokenAddress ERC20 token contract address
     * @param ownerAddress Token owner address
     * @param spenderAddress Spender address
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @returns Promise with formatted allowance as string
     */
    async getERC20Allowance(
        tokenAddress: string,
        ownerAddress: string,
        spenderAddress: string,
        provider?: string,
        chainId?: number
    ): Promise<string> {
        try {
            addressSchema.parse(tokenAddress);
            addressSchema.parse(ownerAddress);
            addressSchema.parse(spenderAddress);
            return await erc20.getAllowance(this, tokenAddress, ownerAddress, spenderAddress, provider, chainId);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "get ERC20 allowance", { tokenAddress, ownerAddress, spenderAddress });
        }
    }

    /**
     * Transfer ERC20 tokens to a recipient
     * 
     * @param tokenAddress ERC20 token contract address
     * @param recipientAddress Recipient address
     * @param amount Amount to transfer in token units (e.g., "1.5" not wei)
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @param options Optional transaction options
     * @returns Promise with transaction response
     */
    async transferERC20(
        tokenAddress: string,
        recipientAddress: string,
        amount: string,
        provider?: string,
        chainId?: number,
        options: TokenOperationOptions = {}
    ): Promise<ethers.TransactionResponse> {
        try {
            addressSchema.parse(tokenAddress);
            addressSchema.parse(recipientAddress);
            return await erc20.transfer(this, tokenAddress, recipientAddress, amount, provider, chainId, options);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "transfer ERC20 tokens", { tokenAddress, recipientAddress, amount });
        }
    }

    /**
     * Approve a spender to use ERC20 tokens
     * 
     * @param tokenAddress ERC20 token contract address
     * @param spenderAddress Spender address to approve
     * @param amount Amount to approve in token units (e.g., "1.5" not wei)
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @param options Optional transaction options
     * @returns Promise with transaction response
     */
    async approveERC20(
        tokenAddress: string,
        spenderAddress: string,
        amount: string,
        provider?: string,
        chainId?: number,
        options: TokenOperationOptions = {}
    ): Promise<ethers.TransactionResponse> {
        try {
            addressSchema.parse(tokenAddress);
            addressSchema.parse(spenderAddress);
            return await erc20.approve(this, tokenAddress, spenderAddress, amount, provider, chainId, options);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "approve ERC20 tokens", { tokenAddress, spenderAddress, amount });
        }
    }

    /**
     * Transfer ERC20 tokens from one address to another (requires approval)
     * 
     * @param tokenAddress ERC20 token contract address
     * @param senderAddress Address to transfer from
     * @param recipientAddress Recipient address
     * @param amount Amount to transfer in token units (e.g., "1.5" not wei)
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @param options Optional transaction options
     * @returns Promise with transaction response
     */
    async transferFromERC20(
        tokenAddress: string,
        senderAddress: string,
        recipientAddress: string,
        amount: string,
        provider?: string,
        chainId?: number,
        options: TokenOperationOptions = {}
    ): Promise<ethers.TransactionResponse> {
        try {
            addressSchema.parse(tokenAddress);
            addressSchema.parse(senderAddress);
            addressSchema.parse(recipientAddress);
            return await erc20.transferFrom(this, tokenAddress, senderAddress, recipientAddress, amount, provider, chainId, options);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "transfer ERC20 tokens from sender", { tokenAddress, senderAddress, recipientAddress, amount });
        }
    }

    // ERC721 NFT Methods

    /**
     * Get basic information about an ERC721 NFT collection
     * 
     * @param contractAddress NFT contract address
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @returns Promise with NFT collection information
     */
    async getERC721CollectionInfo(
        contractAddress: string,
        provider?: string,
        chainId?: number
    ): Promise<ERC721Info> {
        try {
            addressSchema.parse(contractAddress);
            return await erc721.getNFTInfo(this, contractAddress, provider, chainId);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "get ERC721 collection info", { contractAddress });
        }
    }

    /**
     * Get the owner of a specific NFT
     * 
     * @param contractAddress NFT contract address
     * @param tokenId Token ID to check ownership
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @returns Promise with owner address
     */
    async getERC721Owner(
        contractAddress: string,
        tokenId: string | number,
        provider?: string,
        chainId?: number
    ): Promise<string> {
        try {
            addressSchema.parse(contractAddress);
            return await erc721.ownerOf(this, contractAddress, tokenId, provider, chainId);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "get ERC721 owner", { contractAddress, tokenId });
        }
    }

    /**
     * Get and parse metadata for a specific NFT
     * 
     * @param contractAddress NFT contract address
     * @param tokenId Token ID
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @returns Promise with parsed metadata
     */
    async getERC721Metadata(
        contractAddress: string,
        tokenId: string | number,
        provider?: string,
        chainId?: number
    ): Promise<NFTMetadata> {
        try {
            addressSchema.parse(contractAddress);
            return await erc721.getMetadata(this, contractAddress, tokenId, provider, chainId);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "get ERC721 metadata", { contractAddress, tokenId });
        }
    }

    /**
     * Get all NFTs owned by an address
     * 
     * @param contractAddress NFT contract address
     * @param ownerAddress Owner address to check
     * @param includeMetadata Whether to include metadata
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @returns Promise with array of owned NFTs
     */
    async getERC721TokensOfOwner(
        contractAddress: string,
        ownerAddress: string,
        includeMetadata: boolean = false,
        provider?: string,
        chainId?: number
    ): Promise<ERC721TokenInfo[]> {
        try {
            addressSchema.parse(contractAddress);
            addressSchema.parse(ownerAddress);
            return await erc721.getUserNFTs(this, contractAddress, ownerAddress, includeMetadata, provider, chainId);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "get ERC721 tokens of owner", { contractAddress, ownerAddress });
        }
    }

    /**
     * Transfer an NFT to a new owner
     * 
     * @param contractAddress NFT contract address
     * @param toAddress Recipient address
     * @param tokenId Token ID to transfer
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @param options Optional transaction options
     * @returns Promise with transaction response
     */
    async transferERC721(
        contractAddress: string,
        toAddress: string,
        tokenId: string | number,
        provider?: string,
        chainId?: number,
        options: TokenOperationOptions = {}
    ): Promise<ethers.TransactionResponse> {
        try {
            addressSchema.parse(contractAddress);
            addressSchema.parse(toAddress);
            return await erc721.transferNFT(this, contractAddress, toAddress, tokenId, provider, chainId, options);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "transfer ERC721 NFT", { contractAddress, toAddress, tokenId });
        }
    }

    /**
     * Safely transfer an NFT to a new owner
     * 
     * @param contractAddress NFT contract address
     * @param toAddress Recipient address
     * @param tokenId Token ID to transfer
     * @param data Optional data to include
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @param options Optional transaction options
     * @returns Promise with transaction response
     */
    async safeTransferERC721(
        contractAddress: string,
        toAddress: string,
        tokenId: string | number,
        data: string = '0x',
        provider?: string,
        chainId?: number,
        options: TokenOperationOptions = {}
    ): Promise<ethers.TransactionResponse> {
        try {
            addressSchema.parse(contractAddress);
            addressSchema.parse(toAddress);
            return await erc721.safeTransferNFT(this, contractAddress, toAddress, tokenId, data, provider, chainId, options);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "safe transfer ERC721 NFT", { contractAddress, toAddress, tokenId });
        }
    }

    // ERC1155 Multi-Token Methods

    /**
     * Get token balance for a specific ERC1155 token ID
     * 
     * @param contractAddress ERC1155 contract address
     * @param ownerAddress Owner address to check
     * @param tokenId Token ID to check balance
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @returns Promise with token balance as string
     */
    async getERC1155Balance(
        contractAddress: string,
        ownerAddress: string,
        tokenId: string | number,
        provider?: string,
        chainId?: number
    ): Promise<string> {
        try {
            addressSchema.parse(contractAddress);
            addressSchema.parse(ownerAddress);
            return await erc1155.balanceOf(this, contractAddress, ownerAddress, tokenId, provider, chainId);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "get ERC1155 balance", { contractAddress, ownerAddress, tokenId });
        }
    }

    /**
     * Get token balances for multiple ERC1155 token IDs at once
     * 
     * @param contractAddress ERC1155 contract address
     * @param ownerAddresses Array of owner addresses
     * @param tokenIds Array of token IDs
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @returns Promise with array of token balances
     */
    async getERC1155BatchBalances(
        contractAddress: string,
        ownerAddresses: string[],
        tokenIds: (string | number)[],
        provider?: string,
        chainId?: number
    ): Promise<string[]> {
        try {
            addressSchema.parse(contractAddress);
            ownerAddresses.forEach(address => addressSchema.parse(address));
            return await erc1155.balanceOfBatch(this, contractAddress, ownerAddresses, tokenIds, provider, chainId);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "get ERC1155 batch balances", { contractAddress, ownerAddresses, tokenIds });
        }
    }

    /**
     * Get and parse metadata for a specific ERC1155 token
     * 
     * @param contractAddress ERC1155 contract address
     * @param tokenId Token ID to get metadata for
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @returns Promise with token metadata
     */
    async getERC1155Metadata(
        contractAddress: string,
        tokenId: string | number,
        provider?: string,
        chainId?: number
    ): Promise<NFTMetadata> {
        try {
            addressSchema.parse(contractAddress);
            return await erc1155.getMetadata(this, contractAddress, tokenId, provider, chainId);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "get ERC1155 metadata", { contractAddress, tokenId });
        }
    }

    /**
     * Get all ERC1155 tokens owned by an address
     * 
     * @param contractAddress ERC1155 contract address
     * @param ownerAddress Owner address to check
     * @param tokenIds Optional array of specific token IDs to check
     * @param includeMetadata Whether to include metadata
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @returns Promise with array of token info
     */
    async getERC1155TokensOfOwner(
        contractAddress: string,
        ownerAddress: string,
        tokenIds?: (string | number)[],
        includeMetadata: boolean = false,
        provider?: string,
        chainId?: number
    ): Promise<ERC1155TokenInfo[]> {
        try {
            addressSchema.parse(contractAddress);
            addressSchema.parse(ownerAddress);
            return await erc1155.getUserTokens(this, contractAddress, ownerAddress, tokenIds, includeMetadata, provider, chainId);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "get ERC1155 tokens of owner", { contractAddress, ownerAddress });
        }
    }

    /**
     * Safely transfer ERC1155 tokens to another address
     * 
     * @param contractAddress ERC1155 contract address
     * @param fromAddress Sender address
     * @param toAddress Recipient address
     * @param tokenId Token ID to transfer
     * @param amount Amount to transfer
     * @param data Additional data to include with the transfer
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @param options Optional transaction options
     * @returns Promise with transaction response
     */
    async safeTransferERC1155(
        contractAddress: string,
        fromAddress: string,
        toAddress: string,
        tokenId: string | number,
        amount: string,
        data: string = '0x',
        provider?: string,
        chainId?: number,
        options: TokenOperationOptions = {}
    ): Promise<ethers.TransactionResponse> {
        try {
            addressSchema.parse(contractAddress);
            addressSchema.parse(fromAddress);
            addressSchema.parse(toAddress);
            return await erc1155.safeTransferFrom(this, contractAddress, fromAddress, toAddress, tokenId, amount, data, provider, chainId, options);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "safe transfer ERC1155 tokens", { contractAddress, fromAddress, toAddress, tokenId, amount });
        }
    }

    /**
     * Safely transfer multiple ERC1155 tokens in a batch
     * 
     * @param contractAddress ERC1155 contract address
     * @param fromAddress Sender address
     * @param toAddress Recipient address
     * @param tokenIds Array of token IDs to transfer
     * @param amounts Array of amounts to transfer
     * @param data Additional data to include with the transfer
     * @param provider Optional provider name or instance
     * @param chainId Optional chain ID
     * @param options Optional transaction options
     * @returns Promise with transaction response
     */
    async safeBatchTransferERC1155(
        contractAddress: string,
        fromAddress: string,
        toAddress: string,
        tokenIds: (string | number)[],
        amounts: string[],
        data: string = '0x',
        provider?: string,
        chainId?: number,
        options: TokenOperationOptions = {}
    ): Promise<ethers.TransactionResponse> {
        try {
            addressSchema.parse(contractAddress);
            addressSchema.parse(fromAddress);
            addressSchema.parse(toAddress);
            return await erc1155.safeBatchTransferFrom(this, contractAddress, fromAddress, toAddress, tokenIds, amounts, data, provider, chainId, options);
        } catch (error) {
            if (error instanceof TokenError) {
                throw error;
            }
            this.handleProviderError(error, "safe batch transfer ERC1155 tokens", { contractAddress, fromAddress, toAddress, tokenIds, amounts });
        }
    }
}

================
File: src/tests/contracts/TestToken.sol
================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract TestToken {
    string public name = "MyToken";
    string public symbol = "MCP";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        totalSupply = 1000000 * 10**uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value, "insufficient balance");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(balanceOf[from] >= value, "insufficient balance");
        require(allowance[from][msg.sender] >= value, "exceeds allowance");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    function mint(address to, uint256 value) public {
        balanceOf[to] += value;
        totalSupply += value;
        emit Transfer(address(0), to, value);
    }
}

================
File: src/tests/utils/globalTestSetup.ts
================
import { TestEnvironment, getHardhatTestProvider } from './hardhatTestProvider.js';

let globalTestEnv: TestEnvironment | undefined;

export async function getTestEnvironment(): Promise<TestEnvironment> {
  if (!globalTestEnv) {
    globalTestEnv = await getHardhatTestProvider();
  }
  return globalTestEnv;
}

export async function cleanupTestEnvironment(): Promise<void> {
  globalTestEnv = undefined;
}

export async function resetTestEnvironment(): Promise<void> {
  globalTestEnv = await getHardhatTestProvider();
}

================
File: src/tests/utils/hardhatTestProvider.ts
================
import { ethers } from 'ethers';
import { connect } from 'net';

export interface TestEnvironment {
  provider: ethers.JsonRpcProvider;
  signers: ethers.Signer[];
}

const HARDHAT_PRIVATE_KEYS = [
  '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
  '0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d',
  '0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a',
];

export const TEST_ACCOUNTS = {
  ACCOUNT_0: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
  ACCOUNT_1: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
  ACCOUNT_2: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
};

async function isPortInUse(port: number): Promise<boolean> {
  return new Promise((resolve) => {
    const socket = connect(port, '127.0.0.1');
    socket.once('connect', () => {
      socket.end();
      resolve(true);
    });
    socket.once('error', () => {
      resolve(false);
    });
  });
}

async function checkNodeHealth(provider: ethers.JsonRpcProvider): Promise<boolean> {
  try {
    await provider.getBlockNumber();
    return true;
  } catch (error) {
    return false;
  }
}

export async function getHardhatTestProvider(): Promise<TestEnvironment> {
  const port = 8545;
  const isRunning = await isPortInUse(port);
  
  if (!isRunning) {
    throw new Error('Hardhat node is not running. Please start it with: npx hardhat node --hostname 127.0.0.1 --port 8545');
  }

  const provider = new ethers.JsonRpcProvider('http://127.0.0.1:8545');
  
  const isHealthy = await checkNodeHealth(provider);
  if (!isHealthy) {
    throw new Error('Hardhat node is not responding correctly');
  }

  const signers = HARDHAT_PRIVATE_KEYS.map(key => new ethers.Wallet(key, provider));

  return {
    provider,
    signers,
  };
}

================
File: src/tests/utils/testContractHelper.ts
================
import { ethers } from 'ethers';
import fs from 'fs';
import path from 'path';

async function mineBlock(provider: ethers.Provider): Promise<void> {
  // Cast to JsonRpcProvider to access send method
  const jsonRpcProvider = provider as ethers.JsonRpcProvider;
  await jsonRpcProvider.send('evm_mine', []);
}

async function getNonceAfterMining(signer: ethers.Signer, provider: ethers.Provider): Promise<number> {
  // Mine a block to ensure all pending transactions are processed
  await mineBlock(provider);
  // Now get the nonce - it should be accurate since we've mined all pending transactions
  return provider.getTransactionCount(await signer.getAddress(), 'latest');
}

export interface TestTokenInterface {
  name(): Promise<string>;
  symbol(): Promise<string>;
  decimals(): Promise<number>;
  totalSupply(): Promise<bigint>;
  balanceOf(account: string): Promise<bigint>;
  transfer(to: string, value: bigint): Promise<ethers.ContractTransactionResponse>;
  approve(spender: string, value: bigint): Promise<ethers.ContractTransactionResponse>;
  transferFrom(from: string, to: string, value: bigint): Promise<ethers.ContractTransactionResponse>;
  mint(to: string, value: bigint): Promise<ethers.ContractTransactionResponse>;
  connect(signer: ethers.Signer): TestToken;
  getAddress(): Promise<string>;
}

export type TestToken = ethers.Contract & TestTokenInterface;

function getContractArtifact() {
  try {
    const artifactPath = path.join(process.cwd(), 'artifacts/contracts/TestToken.sol/TestToken.json');
    return JSON.parse(fs.readFileSync(artifactPath, 'utf8'));
  } catch (error) {
    console.error('Failed to read contract artifact:', error);
    throw new Error('Contract artifact not found. Make sure the contract is compiled.');
  }
}

function hasMethod(obj: any, method: string): boolean {
  return typeof obj[method] === 'function';
}

function isTestToken(contract: ethers.Contract): contract is TestToken {
  const requiredMethods = [
    'name',
    'symbol',
    'decimals',
    'totalSupply',
    'balanceOf',
    'transfer',
    'approve',
    'transferFrom',
    'mint',
    'connect',
    'getAddress'
  ];

  return requiredMethods.every(method => hasMethod(contract, method));
}

async function waitForTransaction(provider: ethers.Provider, hash: string, maxAttempts = 30): Promise<void> {
  for (let i = 0; i < maxAttempts; i++) {
    try {
      const receipt = await provider.getTransactionReceipt(hash);
      if (receipt) return;
    } catch (error) {
      // Ignore errors and keep trying
    }
    await new Promise(resolve => setTimeout(resolve, 1000));
  }
  throw new Error(`Transaction ${hash} was not mined within ${maxAttempts} seconds`);
}

export async function deployTestToken(
  provider: ethers.Provider,
  signer: ethers.Signer
): Promise<TestToken> {
  const artifact = getContractArtifact();
  
  try {
    const nonce = await getNonceAfterMining(signer, provider);

    // Create and deploy contract with our nonce
    const factory = new ethers.ContractFactory(artifact.abi, artifact.bytecode, signer);
    const contract = await factory.deploy({ nonce });
    await contract.waitForDeployment();
    
    const testToken = contract as unknown as TestToken;
    if (!isTestToken(testToken)) {
      throw new Error('Deployed contract does not implement TestToken interface');
    }
    return testToken;
  } catch (error) {
    console.error('Failed to deploy contract:', error);
    throw error;
  }
}

export async function getTestTokenAt(
  address: string,
  provider: ethers.Provider,
  signer?: ethers.Signer
): Promise<TestToken> {
  try {
    const artifact = getContractArtifact();
    
    const contract = new ethers.Contract(
      address,
      artifact.abi,
      signer || provider
    );

    // Verify the contract exists and has the expected interface
    const code = await provider.getCode(address);
    if (code === '0x') {
      throw new Error('No contract found at the specified address');
    }

    const testToken = contract as unknown as TestToken;
    if (!isTestToken(testToken)) {
      throw new Error('Contract at address does not implement TestToken interface');
    }
    return testToken;
  } catch (error) {
    console.error('Failed to get contract at address:', address, error);
    throw error;
  }
}

================
File: src/tests/utils/testHelpers.ts.md
================
/**
 * @file Test Helper Utilities
 * @version 1.0.0
 * @status STABLE - COMPLETE TEST COVERAGE
 * @lastModified 2024-06-07
 * 
 * Helper utilities for testing Ethereum functionality
 * 
 * IMPORTANT:
 * - Keep tests consistent
 * - Maintain isolation between tests
 * 
 * Functionality:
 * - Mock data generation
 * - Test environment setup
 * - Test assertions
 */

import { ethers } from 'ethers';
import { EthersService } from '../../services/ethersService.js';

// Test networks for testing
export const TEST_NETWORKS = {
  hardhat: {
    name: 'hardhat',
    chainId: 31337,
    provider: new ethers.JsonRpcProvider('http://localhost:8545'),
  },
  mainnetFork: {
    name: 'mainnet-fork',
    chainId: 1,
    provider: new ethers.JsonRpcProvider('http://localhost:8545'),
  }
};

// Test accounts from Hardhat
export const TEST_ACCOUNTS = {
  // Hardhat default account #0, has 10000 ETH
  deployer: {
    address: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
    privateKey: '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
  },
  // Hardhat default account #1
  user: {
    address: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
    privateKey: '0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d',
  }
};

// Test tokens for various scenarios
export const TEST_TOKENS = {
  // Mock ERC20 token information
  mockERC20: {
    name: 'Mock Token',
    symbol: 'MOCK',
    decimals: 18,
    totalSupply: ethers.parseEther('1000000'),
  }
};

// Helper to create a test service instance
export function createTestEthersService(): EthersService {
  const provider = TEST_NETWORKS.hardhat.provider;
  const signer = new ethers.Wallet(TEST_ACCOUNTS.user.privateKey, provider);
  return new EthersService(provider, signer);
}

// Helper to create a random wallet for testing
export function createRandomWallet(): ethers.Wallet {
  return ethers.Wallet.createRandom();
}

// Helper to mock a transaction for testing
export function createMockTransaction(overrides: Partial<ethers.TransactionRequest> = {}): ethers.TransactionRequest {
  return {
    to: TEST_ACCOUNTS.user.address,
    value: ethers.parseEther('1.0'),
    gasLimit: 21000,
    ...overrides,
  };
}

// Helper to wait for a transaction to be mined
export async function waitForTransaction(txHash: string, provider = TEST_NETWORKS.hardhat.provider): Promise<ethers.TransactionReceipt | null> {
  return provider.waitForTransaction(txHash);
}

// Helper to deploy a test contract
export async function deployTestContract(
  signer: ethers.Signer,
  abi: any[],
  bytecode: string,
  args: any[] = []
): Promise<ethers.Contract> {
  const factory = new ethers.ContractFactory(abi, bytecode, signer);
  const contract = await factory.deploy(...args);
  await contract.deploymentTransaction()?.wait();
  return contract;
}

// Helper to assert that a transaction failed with a specific error
export async function expectTransactionToFail(
  txPromise: Promise<any>,
  errorMessage?: string | RegExp
): Promise<void> {
  try {
    await txPromise;
    throw new Error('Transaction did not fail as expected');
  } catch (error) {
    if (errorMessage) {
      if (error instanceof Error) {
        if (typeof errorMessage === 'string') {
          expect(error.message).toContain(errorMessage);
        } else {
          expect(error.message).toMatch(errorMessage);
        }
      }
    }
  }
}

================
File: src/tests/utils/types.ts
================
import { ethers } from 'ethers';
import { EthersService } from '../../services/ethersService.js';

export interface TestEnvironment {
  provider: ethers.JsonRpcProvider;
  signers: ethers.Wallet[];
  ethersService: EthersService;
}

================
File: src/tests/contract-methods.test.ts
================
import { ethers } from 'ethers';
import { TestEnvironment } from './utils/hardhatTestProvider.js';
import { getTestEnvironment } from './utils/globalTestSetup.js';
import { deployTestToken, TestToken } from './utils/testContractHelper.js';

describe('Contract Methods', () => {
  let testEnv: TestEnvironment;
  let testToken: TestToken;

  beforeAll(async () => {
    testEnv = await getTestEnvironment();
    testToken = await deployTestToken(testEnv.provider, testEnv.signers[0]);
  });

  describe('ERC20 Token', () => {
    it('should return correct token name', async () => {
      const name = await testToken.name();
      expect(name).toBe('MyToken');
    });

    it('should return correct token symbol', async () => {
      const symbol = await testToken.symbol();
      expect(symbol).toBe('MCP');
    });

    it('should return correct token decimals', async () => {
      const decimals = await testToken.decimals();
      expect(Number(decimals)).toBe(18);
    });

    it('should return correct balance for valid address', async () => {
      const owner = testEnv.signers[0];
      const ownerAddress = await owner.getAddress();
      const balance = await testToken.balanceOf(ownerAddress);
      expect(balance.toString()).toBe(ethers.parseEther('1000000').toString());
    });

    it('should handle token transfers correctly', async () => {
      const sender = testEnv.signers[0];
      const recipient = testEnv.signers[1];
      const recipientAddress = await recipient.getAddress();
      const amount = ethers.parseEther('100');

      const initialBalance = await testToken.balanceOf(recipientAddress);
      
      await testToken.transfer(recipientAddress, amount);

      const finalBalance = await testToken.balanceOf(recipientAddress);
      expect(finalBalance.toString()).toBe((initialBalance + amount).toString());
    });

    it('should fail when transferring to invalid address', async () => {
      const amount = ethers.parseEther('100');
      await expect(testToken.transfer('0x0000000000000000000000000000000000000000', amount))
        .rejects
        .toThrow();
    });

    it('should fail when transferring more than balance', async () => {
      const sender = testEnv.signers[0];
      const recipient = testEnv.signers[1];
      const recipientAddress = await recipient.getAddress();
      const amount = ethers.parseEther('2000000'); // More than total supply

      await expect(testToken.transfer(recipientAddress, amount))
        .rejects
        .toThrow();
    });
  });
});

================
File: src/tests/test.ts
================
import { describe, expect, test, beforeAll } from '@jest/globals';
import { ethers } from 'ethers';
import { getTestEnvironment } from './utils/globalTestSetup.js';
import { deployTestToken, TestToken } from './utils/testContractHelper.js';
import { TestEnvironment } from './utils/hardhatTestProvider.js';

describe('Test', () => {
  let testEnv: TestEnvironment;
  let testToken: TestToken;
  let signer: ethers.Signer;

  beforeAll(async () => {
    testEnv = await getTestEnvironment();
    signer = testEnv.signers[0];
    testToken = await deployTestToken(testEnv.provider, signer);
  });

  test('should deploy test token', async () => {
    expect(testToken).toBeDefined();
  });
});

================
File: src/tests/write-methods.test.ts
================
import { describe, expect, test, beforeAll, beforeEach } from '@jest/globals';
import { ethers } from 'ethers';
import { EthersService } from '../services/ethersService.js';
import { getTestEnvironment } from './utils/globalTestSetup.js';
import { TestEnvironment } from './utils/hardhatTestProvider.js';
import { deployTestToken, TestToken } from './utils/testContractHelper.js';

describe('Write Methods Tests', () => {
  let ethersService: EthersService;
  let testEnv: TestEnvironment;
  let signer: ethers.Signer;
  let recipientAddress: string;
  let testToken: TestToken;

  beforeAll(async () => {
    testEnv = await getTestEnvironment();
    signer = testEnv.signers[0];
    ethersService = new EthersService(testEnv.provider, signer);
    recipientAddress = await testEnv.signers[1].getAddress();
    testToken = await deployTestToken(testEnv.provider, signer);

    // Fund the signer with some ETH
    const funder = testEnv.signers[2];
    const funderAddress = await funder.getAddress();
    const signerAddress = await signer.getAddress();
    console.log('Funder address:', funderAddress);
    console.log('Funder balance:', ethers.formatEther(await testEnv.provider.getBalance(funderAddress)));

    const fundAmount = ethers.parseEther('10.0');
    const tx = await funder.sendTransaction({
      to: signerAddress,
      value: fundAmount
    });
    await tx.wait();

    console.log('After funding signer balance:', ethers.formatEther(await testEnv.provider.getBalance(signerAddress)));
  }, 30000);

  beforeEach(async () => {
    // Check balance before each test
    const signerAddress = await signer.getAddress();
    console.log('Before test signer balance:', ethers.formatEther(await testEnv.provider.getBalance(signerAddress)));
  });

  describe('sendTransaction', () => {
    test('should send ETH between accounts', async () => {
      const signerAddress = await signer.getAddress();
      const initialBalance = await testEnv.provider.getBalance(recipientAddress);
      const signerBalance = await testEnv.provider.getBalance(signerAddress);
      console.log('Recipient initial balance:', ethers.formatEther(initialBalance));
      console.log('Signer balance before send:', ethers.formatEther(signerBalance));

      const amount = '1.0';

      const tx = await ethersService.sendTransaction({
        to: recipientAddress,
        value: ethers.parseEther(amount)
      });
      await tx.wait();

      const newBalance = await testEnv.provider.getBalance(recipientAddress);
      const expectedBalance = initialBalance + ethers.parseEther(amount);
      const tolerance = ethers.parseEther("0.0001"); // Allow for small differences due to gas costs
      expect(newBalance).toBeGreaterThan(expectedBalance - tolerance);
      expect(newBalance).toBeLessThan(expectedBalance + tolerance);
    });

    test('should fail when sending more ETH than available balance', async () => {
      const signerAddress = await signer.getAddress();
      const signerBalance = await testEnv.provider.getBalance(signerAddress);
      const tooMuch = ethers.formatEther(signerBalance + ethers.parseEther("1.0"));

      await expect(ethersService.sendTransaction({
        to: recipientAddress,
        value: ethers.parseEther(tooMuch)
      })).rejects.toThrow();
    });

    test('should fail when sending to an invalid address', async () => {
      await expect(ethersService.sendTransaction({
        to: 'invalid-address',
        value: ethers.parseEther('1.0')
      })).rejects.toThrow();
    });
  });

  describe('signMessage', () => {
    test('should sign a message', async () => {
      const message = 'Hello, World!';
      const signature = await ethersService.signMessage(message);
      expect(signature).toBeDefined();
      expect(signature.length).toBe(132); // 0x + 130 hex characters
    });
  });
});

================
File: src/tools/definitions/erc1155.ts
================
/**
 * @file ERC1155 Tool Definitions
 * @version 1.0.0
 * 
 * Tool definitions for ERC1155 multi-token standard operations
 */

export const erc1155Tools = [
  {
    name: "getERC1155Balance",
    description: "Get the balance of a specific token ID for an address in an ERC1155 contract",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the ERC1155 token contract"
        },
        ownerAddress: {
          type: "string",
          description: "The Ethereum address whose balance to check"
        },
        tokenId: {
          type: "string",
          description: "The ID of the token"
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        }
      },
      required: ["contractAddress", "ownerAddress", "tokenId"]
    }
  },
  {
    name: "getERC1155BatchBalances",
    description: "Get balances for multiple token IDs or owners in an ERC1155 contract",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the ERC1155 token contract"
        },
        ownerAddresses: {
          type: "array",
          items: {
            type: "string"
          },
          description: "Array of Ethereum addresses whose balances to check"
        },
        tokenIds: {
          type: "array",
          items: {
            type: "string"
          },
          description: "Array of token IDs to check"
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        }
      },
      required: ["contractAddress", "ownerAddresses", "tokenIds"]
    }
  },
  {
    name: "getERC1155Metadata",
    description: "Get and parse the metadata for a specific token ID in an ERC1155 contract",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the ERC1155 token contract"
        },
        tokenId: {
          type: "string",
          description: "The ID of the token"
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        }
      },
      required: ["contractAddress", "tokenId"]
    }
  },
  {
    name: "getERC1155TokensOfOwner",
    description: "Get all tokens owned by an address in an ERC1155 contract, with optional metadata",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the ERC1155 token contract"
        },
        ownerAddress: {
          type: "string",
          description: "The Ethereum address of the token owner"
        },
        tokenIds: {
          type: "array",
          items: {
            type: "string"
          },
          description: "Optional. Specific token IDs to check. If not provided, will attempt to detect all tokens owned."
        },
        includeMetadata: {
          type: "boolean",
          description: "Optional. Whether to include full metadata for each token. Default is false."
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        }
      },
      required: ["contractAddress", "ownerAddress"]
    }
  },
  {
    name: "safeTransferERC1155",
    description: "Safely transfer tokens from the connected wallet to another address",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the ERC1155 token contract"
        },
        fromAddress: {
          type: "string",
          description: "The Ethereum address to send tokens from (must be the connected wallet or have approval)"
        },
        toAddress: {
          type: "string",
          description: "The Ethereum address to receive the tokens"
        },
        tokenId: {
          type: "string",
          description: "The ID of the token to transfer"
        },
        amount: {
          type: "string",
          description: "The amount of tokens to transfer"
        },
        data: {
          type: "string",
          description: "Optional. Additional data to send with the transfer, encoded as a hex string. Default is '0x'."
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        },
        gasLimit: {
          type: "string",
          description: "Optional. The gas limit for the transaction"
        },
        gasPrice: {
          type: "string",
          description: "Optional. The gas price for the transaction in gwei"
        }
      },
      required: ["contractAddress", "fromAddress", "toAddress", "tokenId", "amount"]
    }
  },
  {
    name: "safeBatchTransferERC1155",
    description: "Safely transfer multiple tokens from the connected wallet to another address in a single transaction",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the ERC1155 token contract"
        },
        fromAddress: {
          type: "string",
          description: "The Ethereum address to send tokens from (must be the connected wallet or have approval)"
        },
        toAddress: {
          type: "string",
          description: "The Ethereum address to receive the tokens"
        },
        tokenIds: {
          type: "array",
          items: {
            type: "string"
          },
          description: "Array of token IDs to transfer"
        },
        amounts: {
          type: "array",
          items: {
            type: "string"
          },
          description: "Array of amounts to transfer, corresponding to each token ID"
        },
        data: {
          type: "string",
          description: "Optional. Additional data to send with the transfer, encoded as a hex string. Default is '0x'."
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        },
        gasLimit: {
          type: "string",
          description: "Optional. The gas limit for the transaction"
        },
        gasPrice: {
          type: "string",
          description: "Optional. The gas price for the transaction in gwei"
        }
      },
      required: ["contractAddress", "fromAddress", "toAddress", "tokenIds", "amounts"]
    }
  }
];

================
File: src/tools/definitions/erc20.ts
================
/**
 * @file ERC20 Tool Definitions
 * @version 1.0.0
 * 
 * Tool definitions for ERC20 token standard operations
 */

export const erc20Tools = [
  {
    name: "getERC20TokenInfo",
    description: "Get basic information about an ERC20 token including name, symbol, decimals, and total supply",
    inputSchema: {
      type: "object",
      properties: {
        tokenAddress: {
          type: "string",
          description: "The address of the ERC20 token contract"
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        }
      },
      required: ["tokenAddress"]
    }
  },
  {
    name: "getERC20Balance",
    description: "Get the ERC20 token balance of a wallet",
    inputSchema: {
      type: "object",
      properties: {
        tokenAddress: {
          type: "string",
          description: "The address of the ERC20 token contract"
        },
        ownerAddress: {
          type: "string",
          description: "The Ethereum address whose balance to check"
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        }
      },
      required: ["tokenAddress", "ownerAddress"]
    }
  },
  {
    name: "getERC20Allowance",
    description: "Get the amount of tokens approved for a spender to use from an owner's account",
    inputSchema: {
      type: "object",
      properties: {
        tokenAddress: {
          type: "string",
          description: "The address of the ERC20 token contract"
        },
        ownerAddress: {
          type: "string",
          description: "The Ethereum address that owns the tokens"
        },
        spenderAddress: {
          type: "string",
          description: "The Ethereum address that is approved to spend tokens"
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        }
      },
      required: ["tokenAddress", "ownerAddress", "spenderAddress"]
    }
  },
  {
    name: "transferERC20",
    description: "Transfer ERC20 tokens from the connected wallet to another address",
    inputSchema: {
      type: "object",
      properties: {
        tokenAddress: {
          type: "string",
          description: "The address of the ERC20 token contract"
        },
        recipientAddress: {
          type: "string",
          description: "The Ethereum address to receive the tokens"
        },
        amount: {
          type: "string",
          description: "The amount of tokens to transfer (can be decimal, e.g. '1.5')"
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        },
        gasLimit: {
          type: "string",
          description: "Optional. The gas limit for the transaction"
        },
        gasPrice: {
          type: "string",
          description: "Optional. The gas price for the transaction in gwei"
        }
      },
      required: ["tokenAddress", "recipientAddress", "amount"]
    }
  },
  {
    name: "approveERC20",
    description: "Approve a spender to use a certain amount of your ERC20 tokens",
    inputSchema: {
      type: "object",
      properties: {
        tokenAddress: {
          type: "string",
          description: "The address of the ERC20 token contract"
        },
        spenderAddress: {
          type: "string",
          description: "The Ethereum address to approve for spending tokens"
        },
        amount: {
          type: "string",
          description: "The amount of tokens to approve (can be decimal, e.g. '1.5')"
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        },
        gasLimit: {
          type: "string",
          description: "Optional. The gas limit for the transaction"
        },
        gasPrice: {
          type: "string",
          description: "Optional. The gas price for the transaction in gwei"
        }
      },
      required: ["tokenAddress", "spenderAddress", "amount"]
    }
  },
  {
    name: "transferFromERC20",
    description: "Transfer ERC20 tokens from one address to another (requires approval)",
    inputSchema: {
      type: "object",
      properties: {
        tokenAddress: {
          type: "string",
          description: "The address of the ERC20 token contract"
        },
        senderAddress: {
          type: "string",
          description: "The Ethereum address to send tokens from (must have approved the connected wallet)"
        },
        recipientAddress: {
          type: "string",
          description: "The Ethereum address to receive the tokens"
        },
        amount: {
          type: "string",
          description: "The amount of tokens to transfer (can be decimal, e.g. '1.5')"
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        },
        gasLimit: {
          type: "string",
          description: "Optional. The gas limit for the transaction"
        },
        gasPrice: {
          type: "string",
          description: "Optional. The gas price for the transaction in gwei"
        }
      },
      required: ["tokenAddress", "senderAddress", "recipientAddress", "amount"]
    }
  }
];

================
File: src/tools/definitions/erc721.ts
================
/**
 * @file ERC721 Tool Definitions
 * @version 1.0.0
 * 
 * Tool definitions for ERC721 NFT standard operations
 */

export const erc721Tools = [
  {
    name: "getERC721CollectionInfo",
    description: "Get basic information about an NFT collection including name and symbol",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the ERC721 NFT contract"
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        }
      },
      required: ["contractAddress"]
    }
  },
  {
    name: "getERC721Owner",
    description: "Get the current owner of a specific NFT token",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the ERC721 NFT contract"
        },
        tokenId: {
          type: "string",
          description: "The ID of the NFT token"
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        }
      },
      required: ["contractAddress", "tokenId"]
    }
  },
  {
    name: "getERC721Metadata",
    description: "Get and parse the metadata for a specific NFT token, including name, description, image URL, and attributes",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the ERC721 NFT contract"
        },
        tokenId: {
          type: "string",
          description: "The ID of the NFT token"
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        }
      },
      required: ["contractAddress", "tokenId"]
    }
  },
  {
    name: "getERC721TokensOfOwner",
    description: "Get all NFTs owned by an address in a specific collection, with optional metadata",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the ERC721 NFT contract"
        },
        ownerAddress: {
          type: "string",
          description: "The Ethereum address of the NFT owner"
        },
        includeMetadata: {
          type: "boolean",
          description: "Optional. Whether to include full metadata for each NFT. Default is false."
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        }
      },
      required: ["contractAddress", "ownerAddress"]
    }
  },
  {
    name: "transferERC721",
    description: "Transfer an NFT from the connected wallet to another address",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the ERC721 NFT contract"
        },
        toAddress: {
          type: "string",
          description: "The Ethereum address to receive the NFT"
        },
        tokenId: {
          type: "string",
          description: "The ID of the NFT token to transfer"
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        },
        gasLimit: {
          type: "string",
          description: "Optional. The gas limit for the transaction"
        },
        gasPrice: {
          type: "string",
          description: "Optional. The gas price for the transaction in gwei"
        }
      },
      required: ["contractAddress", "toAddress", "tokenId"]
    }
  },
  {
    name: "safeTransferERC721",
    description: "Safely transfer an NFT from the connected wallet to another address, with additional data",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the ERC721 NFT contract"
        },
        toAddress: {
          type: "string",
          description: "The Ethereum address to receive the NFT"
        },
        tokenId: {
          type: "string",
          description: "The ID of the NFT token to transfer"
        },
        data: {
          type: "string",
          description: "Optional. Additional data to send with the transfer, encoded as a hex string. Default is '0x'."
        },
        provider: {
          type: "string",
          description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks."
        },
        chainId: {
          type: "number",
          description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used."
        },
        gasLimit: {
          type: "string",
          description: "Optional. The gas limit for the transaction"
        },
        gasPrice: {
          type: "string",
          description: "Optional. The gas price for the transaction in gwei"
        }
      },
      required: ["contractAddress", "toAddress", "tokenId"]
    }
  }
];

================
File: src/tools/definitions/index.ts
================
import { erc20Tools } from './erc20.js';
import { erc721Tools } from './erc721.js';
import { erc1155Tools } from './erc1155.js';

export { erc20Tools, erc721Tools, erc1155Tools };

================
File: src/tools/handlers/erc1155.ts
================
/**
 * @file ERC1155 Tool Handlers
 * @version 1.0.0
 * 
 * Tool handlers for ERC1155 multi-token standard operations
 */

import { z } from 'zod';
import { TokenOperationOptions } from '../../services/erc/types.js';

// This will be injected during initialization
let ethersService: any;

export function initializeErc1155Handlers(service: any) {
  ethersService = service;
}

// Common schemas for repeated use
const contractAddressSchema = z.string();
const providerSchema = z.string().optional();
const chainIdSchema = z.number().optional();
const tokenIdSchema = z.union([z.string(), z.number()]);
const amountSchema = z.string();

// Options schema for transaction operations
const optionsSchema = z.object({
  gasLimit: z.union([z.string(), z.number()]).optional(),
  gasPrice: z.union([z.string(), z.number()]).optional(),
  maxFeePerGas: z.union([z.string(), z.number()]).optional(),
  maxPriorityFeePerGas: z.union([z.string(), z.number()]).optional(),
  nonce: z.number().optional(),
  value: z.string().optional(),
}).optional();

export const erc1155Handlers = {
  getERC1155Balance: async (args: unknown) => {
    const schema = z.object({
      contractAddress: contractAddressSchema,
      ownerAddress: z.string(),
      tokenId: tokenIdSchema,
      provider: providerSchema,
      chainId: chainIdSchema
    });
    
    try {
      const { contractAddress, ownerAddress, tokenId, provider, chainId } = schema.parse(args);
      const balance = await ethersService.getERC1155Balance(
        contractAddress, 
        ownerAddress, 
        tokenId, 
        provider, 
        chainId
      );
      
      return {
        content: [{ 
          type: "text", 
          text: `${ownerAddress} has a balance of ${balance} of token ID ${tokenId} in contract ${contractAddress}`
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error getting token balance: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  getERC1155BatchBalances: async (args: unknown) => {
    const schema = z.object({
      contractAddress: contractAddressSchema,
      ownerAddresses: z.array(z.string()),
      tokenIds: z.array(tokenIdSchema),
      provider: providerSchema,
      chainId: chainIdSchema
    });
    
    try {
      const { contractAddress, ownerAddresses, tokenIds, provider, chainId } = schema.parse(args);
      
      // Validate arrays have the same length
      if (ownerAddresses.length !== tokenIds.length) {
        return {
          isError: true,
          content: [{ 
            type: "text", 
            text: "Error: ownerAddresses and tokenIds arrays must have the same length"
          }]
        };
      }
      
      const balances = await ethersService.getERC1155BatchBalances(
        contractAddress, 
        ownerAddresses, 
        tokenIds, 
        provider, 
        chainId
      );
      
      // Build a formatted response
      let responseText = `Batch balances for contract ${contractAddress}:`;
      
      for (let i = 0; i < ownerAddresses.length; i++) {
        responseText += `\n${ownerAddresses[i]} has ${balances[i]} of token ID ${tokenIds[i]}`;
      }
      
      return {
        content: [{ 
          type: "text", 
          text: responseText
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error getting batch balances: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  getERC1155Metadata: async (args: unknown) => {
    const schema = z.object({
      contractAddress: contractAddressSchema,
      tokenId: tokenIdSchema,
      provider: providerSchema,
      chainId: chainIdSchema
    });
    
    try {
      const { contractAddress, tokenId, provider, chainId } = schema.parse(args);
      const metadata = await ethersService.getERC1155Metadata(
        contractAddress, 
        tokenId, 
        provider, 
        chainId
      );
      
      // Build a formatted response with all metadata properties
      let metadataText = `Token Metadata for ${contractAddress} (ID: ${tokenId}):`;
      
      if (metadata.name) metadataText += `\nName: ${metadata.name}`;
      if (metadata.description) metadataText += `\nDescription: ${metadata.description}`;
      if (metadata.image) metadataText += `\nImage URL: ${metadata.image}`;
      if (metadata.external_url) metadataText += `\nExternal URL: ${metadata.external_url}`;
      
      // Add attributes if they exist
      if (metadata.attributes && metadata.attributes.length > 0) {
        metadataText += '\n\nAttributes:';
        for (const attr of metadata.attributes) {
          if (attr.trait_type && attr.value !== undefined) {
            metadataText += `\n- ${attr.trait_type}: ${attr.value}`;
          }
        }
      }
      
      return {
        content: [{ 
          type: "text", 
          text: metadataText
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error getting token metadata: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  getERC1155TokensOfOwner: async (args: unknown) => {
    const schema = z.object({
      contractAddress: contractAddressSchema,
      ownerAddress: z.string(),
      tokenIds: z.array(tokenIdSchema).optional(),
      includeMetadata: z.boolean().optional().default(false),
      provider: providerSchema,
      chainId: chainIdSchema
    });
    
    try {
      const { contractAddress, ownerAddress, tokenIds, includeMetadata, provider, chainId } = schema.parse(args);
      const tokens = await ethersService.getERC1155TokensOfOwner(
        contractAddress, 
        ownerAddress, 
        tokenIds, 
        includeMetadata, 
        provider, 
        chainId
      );
      
      if (tokens.length === 0) {
        return {
          content: [{ 
            type: "text", 
            text: `${ownerAddress} doesn't own any tokens in contract ${contractAddress}.`
          }]
        };
      }
      
      let responseText = `${ownerAddress} owns ${tokens.length} token type(s) in contract ${contractAddress}:`;
      
      for (const token of tokens) {
        responseText += `\n\nToken ID: ${token.tokenId}`;
        responseText += `\nBalance: ${token.balance}`;
        
        if (token.metadata) {
          if (token.metadata.name) responseText += `\nName: ${token.metadata.name}`;
          if (token.metadata.image) responseText += `\nImage URL: ${token.metadata.image}`;
          
          // Add a few attributes if they exist (limited to avoid very long responses)
          if (token.metadata.attributes && token.metadata.attributes.length > 0) {
            responseText += '\nAttributes:';
            const limit = Math.min(3, token.metadata.attributes.length);
            for (let i = 0; i < limit; i++) {
              const attr = token.metadata.attributes[i];
              if (attr.trait_type && attr.value !== undefined) {
                responseText += `\n- ${attr.trait_type}: ${attr.value}`;
              }
            }
            if (token.metadata.attributes.length > limit) {
              responseText += `\n- ... ${token.metadata.attributes.length - limit} more attributes`;
            }
          }
        }
      }
      
      return {
        content: [{ 
          type: "text", 
          text: responseText
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error getting tokens owned by address: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  safeTransferERC1155: async (args: unknown) => {
    const schema = z.object({
      contractAddress: contractAddressSchema,
      fromAddress: z.string(),
      toAddress: z.string(),
      tokenId: tokenIdSchema,
      amount: amountSchema,
      data: z.string().optional().default('0x'),
      provider: providerSchema,
      chainId: chainIdSchema,
      gasLimit: z.string().optional(),
      gasPrice: z.string().optional(),
    });
    
    try {
      const { contractAddress, fromAddress, toAddress, tokenId, amount, data, provider, chainId, gasLimit, gasPrice } = schema.parse(args);
      
      // Create options object for transaction parameters
      const options: TokenOperationOptions = {};
      if (gasLimit) options.gasLimit = gasLimit;
      if (gasPrice) options.gasPrice = gasPrice;
      
      const tx = await ethersService.safeTransferERC1155(
        contractAddress, 
        fromAddress,
        toAddress, 
        tokenId, 
        amount,
        data,
        provider, 
        chainId,
        options
      );
      
      return {
        content: [{ 
          type: "text", 
          text: `Successfully transferred ${amount} of token ID ${tokenId} from ${fromAddress} to ${toAddress}.\nTransaction Hash: ${tx.hash}`
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error transferring tokens: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  safeBatchTransferERC1155: async (args: unknown) => {
    const schema = z.object({
      contractAddress: contractAddressSchema,
      fromAddress: z.string(),
      toAddress: z.string(),
      tokenIds: z.array(tokenIdSchema),
      amounts: z.array(amountSchema),
      data: z.string().optional().default('0x'),
      provider: providerSchema,
      chainId: chainIdSchema,
      gasLimit: z.string().optional(),
      gasPrice: z.string().optional(),
    });
    
    try {
      const { contractAddress, fromAddress, toAddress, tokenIds, amounts, data, provider, chainId, gasLimit, gasPrice } = schema.parse(args);
      
      // Validate arrays have the same length
      if (tokenIds.length !== amounts.length) {
        return {
          isError: true,
          content: [{ 
            type: "text", 
            text: "Error: tokenIds and amounts arrays must have the same length"
          }]
        };
      }
      
      // Create options object for transaction parameters
      const options: TokenOperationOptions = {};
      if (gasLimit) options.gasLimit = gasLimit;
      if (gasPrice) options.gasPrice = gasPrice;
      
      const tx = await ethersService.safeBatchTransferERC1155(
        contractAddress, 
        fromAddress,
        toAddress, 
        tokenIds, 
        amounts,
        data,
        provider, 
        chainId,
        options
      );
      
      // Format the token transfers for the response
      let transfersText = '';
      for (let i = 0; i < tokenIds.length; i++) {
        transfersText += `\n- ${amounts[i]} of token ID ${tokenIds[i]}`;
      }
      
      return {
        content: [{ 
          type: "text", 
          text: `Successfully batch transferred the following tokens from ${fromAddress} to ${toAddress}:${transfersText}\n\nTransaction Hash: ${tx.hash}`
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error batch transferring tokens: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  }
};

================
File: src/tools/handlers/erc20.ts
================
/**
 * @file ERC20 Tool Handlers
 * @version 1.0.0
 * 
 * Tool handlers for ERC20 token standard operations
 */

import { z } from 'zod';
import { TokenOperationOptions } from '../../services/erc/types.js';

// This will be injected during initialization
let ethersService: any;

export function initializeErc20Handlers(service: any) {
  ethersService = service;
}

// Common schemas for repeated use
const tokenAddressSchema = z.string();
const providerSchema = z.string().optional();
const chainIdSchema = z.number().optional();
const amountSchema = z.string();

// Options schema for transaction operations
const optionsSchema = z.object({
  gasLimit: z.union([z.string(), z.number()]).optional(),
  gasPrice: z.union([z.string(), z.number()]).optional(),
  maxFeePerGas: z.union([z.string(), z.number()]).optional(),
  maxPriorityFeePerGas: z.union([z.string(), z.number()]).optional(),
  nonce: z.number().optional(),
  value: z.string().optional(),
}).optional();

export const erc20Handlers = {
  getERC20TokenInfo: async (args: unknown) => {
    const schema = z.object({
      tokenAddress: tokenAddressSchema,
      provider: providerSchema,
      chainId: chainIdSchema
    });
    
    try {
      const { tokenAddress, provider, chainId } = schema.parse(args);
      const tokenInfo = await ethersService.getERC20TokenInfo(tokenAddress, provider, chainId);
      
      return {
        content: [{ 
          type: "text", 
          text: `Token Information:
Name: ${tokenInfo.name}
Symbol: ${tokenInfo.symbol}
Decimals: ${tokenInfo.decimals}
Total Supply: ${tokenInfo.totalSupply}`
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error getting token information: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  getERC20Balance: async (args: unknown) => {
    const schema = z.object({
      tokenAddress: tokenAddressSchema,
      ownerAddress: z.string(),
      provider: providerSchema,
      chainId: chainIdSchema
    });
    
    try {
      const { tokenAddress, ownerAddress, provider, chainId } = schema.parse(args);
      const balance = await ethersService.getERC20Balance(ownerAddress, tokenAddress, provider, chainId);
      
      // Get token info to format the response
      const tokenInfo = await ethersService.getERC20TokenInfo(tokenAddress, provider, chainId);
      
      return {
        content: [{ 
          type: "text", 
          text: `${ownerAddress} has a balance of ${balance} ${tokenInfo.symbol}`
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error getting token balance: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  getERC20Allowance: async (args: unknown) => {
    const schema = z.object({
      tokenAddress: tokenAddressSchema,
      ownerAddress: z.string(),
      spenderAddress: z.string(),
      provider: providerSchema,
      chainId: chainIdSchema
    });
    
    try {
      const { tokenAddress, ownerAddress, spenderAddress, provider, chainId } = schema.parse(args);
      const allowance = await ethersService.getERC20Allowance(
        tokenAddress, 
        ownerAddress, 
        spenderAddress, 
        provider, 
        chainId
      );
      
      // Get token info to format the response
      const tokenInfo = await ethersService.getERC20TokenInfo(tokenAddress, provider, chainId);
      
      return {
        content: [{ 
          type: "text", 
          text: `${spenderAddress} is approved to spend ${allowance} ${tokenInfo.symbol} from ${ownerAddress}`
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error getting token allowance: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  transferERC20: async (args: unknown) => {
    const schema = z.object({
      tokenAddress: tokenAddressSchema,
      recipientAddress: z.string(),
      amount: amountSchema,
      provider: providerSchema,
      chainId: chainIdSchema,
      gasLimit: z.string().optional(),
      gasPrice: z.string().optional(),
    });
    
    try {
      const { tokenAddress, recipientAddress, amount, provider, chainId, gasLimit, gasPrice } = schema.parse(args);
      
      // Create options object for transaction parameters
      const options: TokenOperationOptions = {};
      if (gasLimit) options.gasLimit = gasLimit;
      if (gasPrice) options.gasPrice = gasPrice;
      
      const tx = await ethersService.transferERC20(
        tokenAddress, 
        recipientAddress, 
        amount, 
        provider, 
        chainId,
        options
      );
      
      // Get token info to format the response
      const tokenInfo = await ethersService.getERC20TokenInfo(tokenAddress, provider, chainId);
      
      return {
        content: [{ 
          type: "text", 
          text: `Successfully transferred ${amount} ${tokenInfo.symbol} to ${recipientAddress}.\nTransaction Hash: ${tx.hash}`
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error transferring tokens: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  approveERC20: async (args: unknown) => {
    const schema = z.object({
      tokenAddress: tokenAddressSchema,
      spenderAddress: z.string(),
      amount: amountSchema,
      provider: providerSchema,
      chainId: chainIdSchema,
      gasLimit: z.string().optional(),
      gasPrice: z.string().optional(),
    });
    
    try {
      const { tokenAddress, spenderAddress, amount, provider, chainId, gasLimit, gasPrice } = schema.parse(args);
      
      // Create options object for transaction parameters
      const options: TokenOperationOptions = {};
      if (gasLimit) options.gasLimit = gasLimit;
      if (gasPrice) options.gasPrice = gasPrice;
      
      const tx = await ethersService.approveERC20(
        tokenAddress, 
        spenderAddress, 
        amount, 
        provider, 
        chainId,
        options
      );
      
      // Get token info to format the response
      const tokenInfo = await ethersService.getERC20TokenInfo(tokenAddress, provider, chainId);
      
      return {
        content: [{ 
          type: "text", 
          text: `Successfully approved ${spenderAddress} to spend ${amount} ${tokenInfo.symbol}.\nTransaction Hash: ${tx.hash}`
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error approving token spending: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  transferFromERC20: async (args: unknown) => {
    const schema = z.object({
      tokenAddress: tokenAddressSchema,
      senderAddress: z.string(),
      recipientAddress: z.string(),
      amount: amountSchema,
      provider: providerSchema,
      chainId: chainIdSchema,
      gasLimit: z.string().optional(),
      gasPrice: z.string().optional(),
    });
    
    try {
      const { tokenAddress, senderAddress, recipientAddress, amount, provider, chainId, gasLimit, gasPrice } = schema.parse(args);
      
      // Create options object for transaction parameters
      const options: TokenOperationOptions = {};
      if (gasLimit) options.gasLimit = gasLimit;
      if (gasPrice) options.gasPrice = gasPrice;
      
      const tx = await ethersService.transferFromERC20(
        tokenAddress, 
        senderAddress, 
        recipientAddress, 
        amount, 
        provider, 
        chainId,
        options
      );
      
      // Get token info to format the response
      const tokenInfo = await ethersService.getERC20TokenInfo(tokenAddress, provider, chainId);
      
      return {
        content: [{ 
          type: "text", 
          text: `Successfully transferred ${amount} ${tokenInfo.symbol} from ${senderAddress} to ${recipientAddress}.\nTransaction Hash: ${tx.hash}`
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error transferring tokens on behalf of another account: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  }
};

================
File: src/tools/handlers/erc721.ts
================
/**
 * @file ERC721 Tool Handlers
 * @version 1.0.0
 * 
 * Tool handlers for ERC721 NFT standard operations
 */

import { z } from 'zod';
import { TokenOperationOptions } from '../../services/erc/types.js';

// This will be injected during initialization
let ethersService: any;

export function initializeErc721Handlers(service: any) {
  ethersService = service;
}

// Common schemas for repeated use
const contractAddressSchema = z.string();
const providerSchema = z.string().optional();
const chainIdSchema = z.number().optional();
const tokenIdSchema = z.union([z.string(), z.number()]);

// Options schema for transaction operations
const optionsSchema = z.object({
  gasLimit: z.union([z.string(), z.number()]).optional(),
  gasPrice: z.union([z.string(), z.number()]).optional(),
  maxFeePerGas: z.union([z.string(), z.number()]).optional(),
  maxPriorityFeePerGas: z.union([z.string(), z.number()]).optional(),
  nonce: z.number().optional(),
  value: z.string().optional(),
}).optional();

export const erc721Handlers = {
  getERC721CollectionInfo: async (args: unknown) => {
    const schema = z.object({
      contractAddress: contractAddressSchema,
      provider: providerSchema,
      chainId: chainIdSchema
    });
    
    try {
      const { contractAddress, provider, chainId } = schema.parse(args);
      const collectionInfo = await ethersService.getERC721CollectionInfo(contractAddress, provider, chainId);
      
      return {
        content: [{ 
          type: "text", 
          text: `NFT Collection Information:
Name: ${collectionInfo.name}
Symbol: ${collectionInfo.symbol}${collectionInfo.totalSupply ? `
Total Supply: ${collectionInfo.totalSupply}` : ''}`
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error getting NFT collection information: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  getERC721Owner: async (args: unknown) => {
    const schema = z.object({
      contractAddress: contractAddressSchema,
      tokenId: tokenIdSchema,
      provider: providerSchema,
      chainId: chainIdSchema
    });
    
    try {
      const { contractAddress, tokenId, provider, chainId } = schema.parse(args);
      const owner = await ethersService.getERC721Owner(contractAddress, tokenId, provider, chainId);
      
      // Get collection info to add context
      const collectionInfo = await ethersService.getERC721CollectionInfo(contractAddress, provider, chainId);
      
      return {
        content: [{ 
          type: "text", 
          text: `The owner of ${collectionInfo.name} #${tokenId} is ${owner}`
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error getting NFT owner: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  getERC721Metadata: async (args: unknown) => {
    const schema = z.object({
      contractAddress: contractAddressSchema,
      tokenId: tokenIdSchema,
      provider: providerSchema,
      chainId: chainIdSchema
    });
    
    try {
      const { contractAddress, tokenId, provider, chainId } = schema.parse(args);
      const metadata = await ethersService.getERC721Metadata(contractAddress, tokenId, provider, chainId);
      
      // Get collection info to add context
      const collectionInfo = await ethersService.getERC721CollectionInfo(contractAddress, provider, chainId);
      
      // Build a formatted response with all metadata properties
      let metadataText = `NFT Metadata for ${collectionInfo.name} #${tokenId}:`;
      
      if (metadata.name) metadataText += `\nName: ${metadata.name}`;
      if (metadata.description) metadataText += `\nDescription: ${metadata.description}`;
      if (metadata.image) metadataText += `\nImage URL: ${metadata.image}`;
      if (metadata.external_url) metadataText += `\nExternal URL: ${metadata.external_url}`;
      
      // Add attributes if they exist
      if (metadata.attributes && metadata.attributes.length > 0) {
        metadataText += '\n\nAttributes:';
        for (const attr of metadata.attributes) {
          if (attr.trait_type && attr.value !== undefined) {
            metadataText += `\n- ${attr.trait_type}: ${attr.value}`;
          }
        }
      }
      
      return {
        content: [{ 
          type: "text", 
          text: metadataText
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error getting NFT metadata: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  getERC721TokensOfOwner: async (args: unknown) => {
    const schema = z.object({
      contractAddress: contractAddressSchema,
      ownerAddress: z.string(),
      includeMetadata: z.boolean().optional().default(false),
      provider: providerSchema,
      chainId: chainIdSchema
    });
    
    try {
      const { contractAddress, ownerAddress, includeMetadata, provider, chainId } = schema.parse(args);
      const tokens = await ethersService.getERC721TokensOfOwner(
        contractAddress, 
        ownerAddress, 
        includeMetadata, 
        provider, 
        chainId
      );
      
      // Get collection info to add context
      const collectionInfo = await ethersService.getERC721CollectionInfo(contractAddress, provider, chainId);
      
      if (tokens.length === 0) {
        return {
          content: [{ 
            type: "text", 
            text: `${ownerAddress} doesn't own any tokens in the ${collectionInfo.name} collection.`
          }]
        };
      }
      
      let responseText = `${ownerAddress} owns ${tokens.length} token(s) in the ${collectionInfo.name} collection:`;
      
      for (const token of tokens) {
        responseText += `\n\nToken ID: ${token.tokenId}`;
        
        if (token.metadata) {
          if (token.metadata.name) responseText += `\nName: ${token.metadata.name}`;
          if (token.metadata.image) responseText += `\nImage URL: ${token.metadata.image}`;
          
          // Add a few attributes if they exist (limited to avoid very long responses)
          if (token.metadata.attributes && token.metadata.attributes.length > 0) {
            responseText += '\nAttributes:';
            const limit = Math.min(5, token.metadata.attributes.length);
            for (let i = 0; i < limit; i++) {
              const attr = token.metadata.attributes[i];
              if (attr.trait_type && attr.value !== undefined) {
                responseText += `\n- ${attr.trait_type}: ${attr.value}`;
              }
            }
            if (token.metadata.attributes.length > limit) {
              responseText += `\n- ... ${token.metadata.attributes.length - limit} more attributes`;
            }
          }
        }
      }
      
      return {
        content: [{ 
          type: "text", 
          text: responseText
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error getting NFTs owned by address: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  transferERC721: async (args: unknown) => {
    const schema = z.object({
      contractAddress: contractAddressSchema,
      toAddress: z.string(),
      tokenId: tokenIdSchema,
      provider: providerSchema,
      chainId: chainIdSchema,
      gasLimit: z.string().optional(),
      gasPrice: z.string().optional(),
    });
    
    try {
      const { contractAddress, toAddress, tokenId, provider, chainId, gasLimit, gasPrice } = schema.parse(args);
      
      // Create options object for transaction parameters
      const options: TokenOperationOptions = {};
      if (gasLimit) options.gasLimit = gasLimit;
      if (gasPrice) options.gasPrice = gasPrice;
      
      const tx = await ethersService.transferERC721(
        contractAddress, 
        toAddress, 
        tokenId, 
        provider, 
        chainId,
        options
      );
      
      // Get collection info to add context
      const collectionInfo = await ethersService.getERC721CollectionInfo(contractAddress, provider, chainId);
      
      return {
        content: [{ 
          type: "text", 
          text: `Successfully transferred ${collectionInfo.name} #${tokenId} to ${toAddress}.\nTransaction Hash: ${tx.hash}`
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error transferring NFT: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  },
  
  safeTransferERC721: async (args: unknown) => {
    const schema = z.object({
      contractAddress: contractAddressSchema,
      toAddress: z.string(),
      tokenId: tokenIdSchema,
      data: z.string().optional().default('0x'),
      provider: providerSchema,
      chainId: chainIdSchema,
      gasLimit: z.string().optional(),
      gasPrice: z.string().optional(),
    });
    
    try {
      const { contractAddress, toAddress, tokenId, data, provider, chainId, gasLimit, gasPrice } = schema.parse(args);
      
      // Create options object for transaction parameters
      const options: TokenOperationOptions = {};
      if (gasLimit) options.gasLimit = gasLimit;
      if (gasPrice) options.gasPrice = gasPrice;
      
      const tx = await ethersService.safeTransferERC721(
        contractAddress, 
        toAddress, 
        tokenId, 
        data,
        provider, 
        chainId,
        options
      );
      
      // Get collection info to add context
      const collectionInfo = await ethersService.getERC721CollectionInfo(contractAddress, provider, chainId);
      
      return {
        content: [{ 
          type: "text", 
          text: `Successfully safe-transferred ${collectionInfo.name} #${tokenId} to ${toAddress}.\nTransaction Hash: ${tx.hash}`
        }]
      };
    } catch (error) {
      return {
        isError: true,
        content: [{ 
          type: "text", 
          text: `Error safe-transferring NFT: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  }
};

================
File: src/tools/handlers/index.ts
================
import { erc20Handlers } from './erc20.js';
import { erc721Handlers } from './erc721.js';
import { erc1155Handlers } from './erc1155.js';

export { erc20Handlers, erc721Handlers, erc1155Handlers };

================
File: src/tools/index.ts
================
import { erc20Tools, erc721Tools, erc1155Tools } from './definitions/index.js';
import { erc20Handlers, erc721Handlers, erc1155Handlers } from './handlers/index.js';

export const allTools = [
  ...erc20Tools,
  ...erc721Tools,
  ...erc1155Tools
];

export const allHandlers = {
  ...erc20Handlers,
  ...erc721Handlers,
  ...erc1155Handlers
};

================
File: src/utils/cache.ts
================
/**
 * @file Cache System
 * @version 1.0.0
 * @status STABLE - DO NOT MODIFY WITHOUT TESTS
 * @lastModified 2024-06-07
 * 
 * Simple in-memory caching system with TTL support
 * 
 * IMPORTANT:
 * - Keep memory usage reasonable
 * - Provide clear invalidation mechanisms
 * 
 * Functionality:
 * - Time-based expiration
 * - Chainable API
 * - Cache invalidation
 */

interface CacheEntry<T> {
  value: T;
  expiry: number;
}

interface CacheOptions {
  ttl: number; // Time to live in milliseconds
}

export class Cache<T = any> {
  private cache: Map<string, CacheEntry<T>> = new Map();
  private defaultOptions: CacheOptions = { ttl: 30000 }; // Default 30 seconds TTL

  constructor(options?: Partial<CacheOptions>) {
    if (options) {
      this.defaultOptions = { ...this.defaultOptions, ...options };
    }
  }

  /**
   * Get a value from the cache
   * @param key The cache key
   * @returns The cached value or undefined if not found or expired
   */
  get(key: string): T | undefined {
    const entry = this.cache.get(key);
    
    if (!entry) {
      return undefined;
    }
    
    // Check if entry has expired
    if (Date.now() > entry.expiry) {
      this.cache.delete(key);
      return undefined;
    }
    
    return entry.value;
  }

  /**
   * Set a value in the cache
   * @param key The cache key
   * @param value The value to cache
   * @param options Optional cache options
   * @returns this instance for chaining
   */
  set(key: string, value: T, options?: Partial<CacheOptions>): this {
    const opts = { ...this.defaultOptions, ...options };
    const expiry = Date.now() + opts.ttl;
    
    this.cache.set(key, { value, expiry });
    return this;
  }

  /**
   * Check if a key exists and is not expired
   * @param key The cache key
   * @returns True if the key exists and is not expired
   */
  has(key: string): boolean {
    const entry = this.cache.get(key);
    
    if (!entry) {
      return false;
    }
    
    if (Date.now() > entry.expiry) {
      this.cache.delete(key);
      return false;
    }
    
    return true;
  }

  /**
   * Delete a key from the cache
   * @param key The cache key
   * @returns True if the key was deleted
   */
  delete(key: string): boolean {
    return this.cache.delete(key);
  }

  /**
   * Clear all entries from the cache
   */
  clear(): void {
    this.cache.clear();
  }

  /**
   * Get a value from the cache, or compute and cache it if not found
   * @param key The cache key
   * @param factory Function to compute the value if not cached
   * @param options Optional cache options
   * @returns The cached or computed value
   */
  async getOrCompute(
    key: string, 
    factory: () => Promise<T>,
    options?: Partial<CacheOptions>
  ): Promise<T> {
    const cached = this.get(key);
    
    if (cached !== undefined) {
      return cached;
    }
    
    const value = await factory();
    this.set(key, value, options);
    return value;
  }

  /**
   * Remove all expired entries from the cache
   * @returns Number of entries removed
   */
  cleanup(): number {
    const now = Date.now();
    let count = 0;
    
    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expiry) {
        this.cache.delete(key);
        count++;
      }
    }
    
    return count;
  }
}

// Create cache instances for different types of data
export const blockCache = new Cache<any>({ ttl: 10000 }); // 10 seconds
export const transactionCache = new Cache<any>({ ttl: 60000 }); // 1 minute
export const balanceCache = new Cache<string>({ ttl: 30000 }); // 30 seconds
export const contractCache = new Cache<any>({ ttl: 300000 }); // 5 minutes
export const ensCache = new Cache<string>({ ttl: 3600000 }); // 1 hour

// Helper to generate cache keys with network information
export function createCacheKey(prefix: string, ...parts: (string | number | undefined)[]): string {
  const filteredParts = parts.filter(part => part !== undefined);
  return `${prefix}:${filteredParts.join(':')}`;
}

// Cleanup expired cache entries periodically
setInterval(() => {
  blockCache.cleanup();
  transactionCache.cleanup();
  balanceCache.cleanup();
  contractCache.cleanup();
  ensCache.cleanup();
}, 60000); // Run cleanup every minute

================
File: src/utils/errors.ts
================
/**
 * @file Error Handling Utilities
 * @version 1.0.0
 * @status STABLE - DO NOT MODIFY WITHOUT TESTS
 * @lastModified 2024-06-07
 * 
 * Standardized error handling system for MCP Ethers Wallet
 * 
 * IMPORTANT:
 * - Add tests for any new error types
 * - Maintain consistent error codes
 * 
 * Functionality:
 * - Custom error classes
 * - Error serialization
 * - Error codes
 */

// Base error class for all application errors
export class EthersServerError extends Error {
  public readonly code: string;
  public readonly details?: Record<string, any>;
  public readonly statusCode: number;

  constructor(
    message: string, 
    code: string = 'UNKNOWN_ERROR', 
    details?: Record<string, any>,
    statusCode: number = 500
  ) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.details = details;
    this.statusCode = statusCode;
    
    // Maintains proper stack trace for where error was thrown
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }

  // Serialize the error for API responses
  public serialize(): Record<string, any> {
    return {
      error: {
        message: this.message,
        code: this.code,
        details: this.details || {},
      }
    };
  }
}

// Network-related errors
export class NetworkError extends EthersServerError {
  constructor(message: string, details?: Record<string, any>) {
    super(message, 'NETWORK_ERROR', details, 503);
  }
}

// Provider-related errors
export class ProviderError extends EthersServerError {
  constructor(message: string, details?: Record<string, any>) {
    super(message, 'PROVIDER_ERROR', details, 500);
  }
}

// Contract-related errors
export class ContractError extends EthersServerError {
  constructor(message: string, details?: Record<string, any>) {
    super(message, 'CONTRACT_ERROR', details, 400);
  }
}

// Transaction-related errors
export class TransactionError extends EthersServerError {
  constructor(message: string, details?: Record<string, any>) {
    super(message, 'TRANSACTION_ERROR', details, 400);
  }
}

// Wallet-related errors
export class WalletError extends EthersServerError {
  constructor(message: string, details?: Record<string, any>) {
    super(message, 'WALLET_ERROR', details, 400);
  }
}

// Configuration errors
export class ConfigurationError extends EthersServerError {
  constructor(message: string, details?: Record<string, any>) {
    super(message, 'CONFIGURATION_ERROR', details, 500);
  }
}

// Handle and format unknown errors
export function handleUnknownError(error: unknown): EthersServerError {
  if (error instanceof EthersServerError) {
    return error;
  }
  
  let message = 'An unknown error occurred';
  let details: Record<string, any> = {};
  
  if (error instanceof Error) {
    message = error.message;
    details = { stack: error.stack };
  } else if (typeof error === 'string') {
    message = error;
  } else if (error !== null && typeof error === 'object') {
    details = { ...error };
  }
  
  return new EthersServerError(message, 'UNKNOWN_ERROR', details);
}

================
File: src/utils/logger.ts
================
/**
 * @file Logging System
 * @version 1.0.0
 * @status STABLE - DO NOT MODIFY WITHOUT TESTS
 * @lastModified 2024-06-07
 * 
 * A simple structured logging system
 * 
 * IMPORTANT:
 * - Keep consistent log formats
 * - Follow log level guidelines
 * 
 * Functionality:
 * - Multiple log levels
 * - Structured logging
 * - Log formatting
 */

import { config } from '../config/config.js';

// Log levels with numeric values for comparison
export enum LogLevel {
  ERROR = 0,
  WARN = 1,
  INFO = 2,
  DEBUG = 3,
}

// Convert string log level to enum value
function getLogLevelValue(level: string): LogLevel {
  switch (level.toLowerCase()) {
    case 'error': return LogLevel.ERROR;
    case 'warn': return LogLevel.WARN;
    case 'info': return LogLevel.INFO;
    case 'debug': return LogLevel.DEBUG;
    default: return LogLevel.INFO;
  }
}

// Current log level from configuration
const CURRENT_LOG_LEVEL = getLogLevelValue(config.LOG_LEVEL);

// Format a log message with timestamp and metadata
function formatLogMessage(level: string, message: string, metadata?: Record<string, any>): string {
  const timestamp = new Date().toISOString();
  const metadataStr = metadata ? ` ${JSON.stringify(metadata)}` : '';
  return `[${timestamp}] [${level.toUpperCase()}] ${message}${metadataStr}`;
}

// Check if a log level should be printed
function shouldLog(level: LogLevel): boolean {
  return level <= CURRENT_LOG_LEVEL;
}

// Logger object with methods for each log level
export const logger = {
  error(message: string, metadata?: Record<string, any>): void {
    if (shouldLog(LogLevel.ERROR)) {
      console.error(formatLogMessage('error', message, metadata));
    }
  },
  
  warn(message: string, metadata?: Record<string, any>): void {
    if (shouldLog(LogLevel.WARN)) {
      console.warn(formatLogMessage('warn', message, metadata));
    }
  },
  
  info(message: string, metadata?: Record<string, any>): void {
    if (shouldLog(LogLevel.INFO)) {
      console.info(formatLogMessage('info', message, metadata));
    }
  },
  
  debug(message: string, metadata?: Record<string, any>): void {
    if (shouldLog(LogLevel.DEBUG)) {
      console.debug(formatLogMessage('debug', message, metadata));
    }
  },
  
  // Log an error object with appropriate formatting
  logError(error: unknown, context: string): void {
    if (!shouldLog(LogLevel.ERROR)) return;
    
    if (error instanceof Error) {
      this.error(`${context}: ${error.message}`, {
        name: error.name,
        stack: error.stack,
      });
    } else if (typeof error === 'string') {
      this.error(`${context}: ${error}`);
    } else {
      this.error(`${context}: Unknown error`, { error });
    }
  }
};

================
File: src/utils/metrics.ts
================
/**
 * @file Metrics Collection System
 * @version 1.0.0
 * @status STABLE - DO NOT MODIFY WITHOUT TESTS
 * @lastModified 2024-06-07
 * 
 * Simple metrics collection for monitoring performance
 * 
 * IMPORTANT:
 * - Keep metrics collection lightweight
 * - Use consistent naming conventions
 * 
 * Functionality:
 * - Request counting
 * - Timing measurements
 * - Error tracking
 */

interface MetricValue {
  count: number;
  sum: number;
  min: number;
  max: number;
  last: number;
}

interface ErrorMetric {
  count: number;
  last: Error | string;
  lastTime: number;
}

export class Metrics {
  private static instance: Metrics;
  
  private counters: Map<string, number> = new Map();
  private timers: Map<string, MetricValue> = new Map();
  private errors: Map<string, ErrorMetric> = new Map();
  private startTimes: Map<string, number> = new Map();
  
  private constructor() {}
  
  public static getInstance(): Metrics {
    if (!Metrics.instance) {
      Metrics.instance = new Metrics();
    }
    return Metrics.instance;
  }
  
  /**
   * Increment a counter metric
   * @param name Metric name
   * @param amount Amount to increment (default: 1)
   */
  public incrementCounter(name: string, amount = 1): void {
    const current = this.counters.get(name) || 0;
    this.counters.set(name, current + amount);
  }
  
  /**
   * Get the current value of a counter
   * @param name Metric name
   * @returns Current counter value
   */
  public getCounter(name: string): number {
    return this.counters.get(name) || 0;
  }
  
  /**
   * Start timing an operation
   * @param name Metric name
   */
  public startTimer(name: string): void {
    this.startTimes.set(name, Date.now());
  }
  
  /**
   * End timing an operation and record the duration
   * @param name Metric name
   * @returns Duration in milliseconds
   */
  public endTimer(name: string): number {
    const startTime = this.startTimes.get(name);
    if (startTime === undefined) {
      return 0;
    }
    
    const duration = Date.now() - startTime;
    this.recordTime(name, duration);
    this.startTimes.delete(name);
    return duration;
  }
  
  /**
   * Record a time measurement directly
   * @param name Metric name
   * @param duration Duration in milliseconds
   */
  public recordTime(name: string, duration: number): void {
    const current = this.timers.get(name) || { count: 0, sum: 0, min: Number.MAX_VALUE, max: 0, last: 0 };
    
    current.count += 1;
    current.sum += duration;
    current.min = Math.min(current.min, duration);
    current.max = Math.max(current.max, duration);
    current.last = duration;
    
    this.timers.set(name, current);
  }
  
  /**
   * Get timing statistics for a metric
   * @param name Metric name
   * @returns Timing statistics
   */
  public getTimer(name: string): { avg: number; min: number; max: number; count: number; last: number } | null {
    const timer = this.timers.get(name);
    if (!timer) {
      return null;
    }
    
    return {
      avg: timer.count > 0 ? timer.sum / timer.count : 0,
      min: timer.min,
      max: timer.max,
      count: timer.count,
      last: timer.last
    };
  }
  
  /**
   * Record an error
   * @param category Error category
   * @param error Error object or message
   */
  public recordError(category: string, error: Error | string): void {
    const current = this.errors.get(category) || { count: 0, last: '', lastTime: 0 };
    
    current.count += 1;
    current.last = error;
    current.lastTime = Date.now();
    
    this.errors.set(category, current);
  }
  
  /**
   * Get error statistics for a category
   * @param category Error category
   * @returns Error statistics
   */
  public getErrorStats(category: string): { count: number; last: Error | string; lastTime: number } | null {
    return this.errors.get(category) || null;
  }
  
  /**
   * Reset all metrics
   */
  public reset(): void {
    this.counters.clear();
    this.timers.clear();
    this.errors.clear();
    this.startTimes.clear();
  }
  
  /**
   * Get a snapshot of all metrics
   * @returns Metrics snapshot
   */
  public getSnapshot(): Record<string, any> {
    return {
      counters: Object.fromEntries(this.counters),
      timers: Object.fromEntries(this.timers),
      errors: Object.fromEntries(this.errors),
    };
  }
}

// Export singleton instance
export const metrics = Metrics.getInstance();

// Helper function to time an async function call
export async function timeAsync<T>(
  name: string, 
  fn: () => Promise<T>
): Promise<T> {
  metrics.startTimer(name);
  try {
    return await fn();
  } finally {
    metrics.endTimer(name);
  }
}

// Helper function to track a call to a specific API
export function trackApiCall(method: string): void {
  metrics.incrementCounter(`api.${method}`);
}

================
File: src/utils/rateLimiter.ts
================
/**
 * @file Rate Limiter
 * @version 1.0.0
 * @status STABLE - DO NOT MODIFY WITHOUT TESTS
 * @lastModified 2024-06-07
 * 
 * Simple in-memory rate limiter to prevent API abuse
 * 
 * IMPORTANT:
 * - Keep memory usage reasonable
 * - Use sliding window algorithm for accurate rate limiting
 * 
 * Functionality:
 * - Request rate limiting
 * - Different limits for different operations
 * - Sliding window algorithm
 */

interface RateLimitOptions {
  windowMs: number;     // Time window in milliseconds
  maxRequests: number;  // Maximum requests per window
}

interface RateLimitBucket {
  timestamps: number[];  // Array of request timestamps
  blockedUntil?: number; // Timestamp until which requests are blocked
}

export class RateLimiter {
  private limits: Map<string, RateLimitOptions> = new Map();
  private buckets: Map<string, RateLimitBucket> = new Map();
  
  /**
   * Create a new rate limiter
   */
  constructor() {
    // Set default limits for different operations
    this.setLimit('default', { windowMs: 60000, maxRequests: 120 });  // 120 requests per minute
    this.setLimit('contract', { windowMs: 60000, maxRequests: 60 });  // 60 contract calls per minute
    this.setLimit('transaction', { windowMs: 60000, maxRequests: 20 }); // 20 transactions per minute
    
    // Clean up old entries periodically
    setInterval(() => this.cleanup(), 60000); // Every minute
  }
  
  /**
   * Set a rate limit for a specific operation
   * @param operation Operation name
   * @param options Rate limit options
   */
  public setLimit(operation: string, options: RateLimitOptions): void {
    this.limits.set(operation, options);
  }
  
  /**
   * Check if an operation for a specific identity is rate limited
   * @param operation Operation name
   * @param identity Identity string (e.g., IP, user ID)
   * @returns True if the operation is allowed, false if rate limited
   */
  public isAllowed(operation: string, identity: string): boolean {
    const key = `${operation}:${identity}`;
    const limit = this.limits.get(operation) || this.limits.get('default')!;
    
    // Create bucket if it doesn't exist
    if (!this.buckets.has(key)) {
      this.buckets.set(key, { timestamps: [] });
    }
    
    const bucket = this.buckets.get(key)!;
    
    // Check if currently blocked
    if (bucket.blockedUntil && Date.now() < bucket.blockedUntil) {
      return false;
    }
    
    // Remove timestamps outside the current window
    const now = Date.now();
    const windowStart = now - limit.windowMs;
    bucket.timestamps = bucket.timestamps.filter(time => time >= windowStart);
    
    // Check if under the limit
    if (bucket.timestamps.length < limit.maxRequests) {
      bucket.timestamps.push(now);
      return true;
    }
    
    // Rate limited
    return false;
  }
  
  /**
   * Check if an operation is allowed and record it
   * @param operation Operation name
   * @param identity Identity string
   * @returns True if allowed, false if rate limited
   */
  public consume(operation: string, identity: string): boolean {
    if (this.isAllowed(operation, identity)) {
      return true;
    }
    
    // If not allowed, update the blocked until time
    const key = `${operation}:${identity}`;
    const bucket = this.buckets.get(key)!;
    const limit = this.limits.get(operation) || this.limits.get('default')!;
    
    // Block for the duration of the window
    bucket.blockedUntil = Date.now() + limit.windowMs;
    
    return false;
  }
  
  /**
   * Get remaining requests for an operation and identity
   * @param operation Operation name
   * @param identity Identity string
   * @returns Number of remaining requests in the current window
   */
  public getRemainingRequests(operation: string, identity: string): number {
    const key = `${operation}:${identity}`;
    const limit = this.limits.get(operation) || this.limits.get('default')!;
    
    if (!this.buckets.has(key)) {
      return limit.maxRequests;
    }
    
    const bucket = this.buckets.get(key)!;
    
    // Check if currently blocked
    if (bucket.blockedUntil && Date.now() < bucket.blockedUntil) {
      return 0;
    }
    
    // Remove timestamps outside the current window
    const now = Date.now();
    const windowStart = now - limit.windowMs;
    bucket.timestamps = bucket.timestamps.filter(time => time >= windowStart);
    
    return Math.max(0, limit.maxRequests - bucket.timestamps.length);
  }
  
  /**
   * Reset rate limit for an operation and identity
   * @param operation Operation name
   * @param identity Identity string
   */
  public reset(operation: string, identity: string): void {
    const key = `${operation}:${identity}`;
    this.buckets.delete(key);
  }
  
  /**
   * Clean up old entries to prevent memory leaks
   */
  private cleanup(): void {
    const now = Date.now();
    
    for (const [key, bucket] of this.buckets.entries()) {
      const [operation] = key.split(':');
      const limit = this.limits.get(operation) || this.limits.get('default')!;
      
      // If bucket is empty or all timestamps are old, remove it
      const windowStart = now - limit.windowMs;
      bucket.timestamps = bucket.timestamps.filter(time => time >= windowStart);
      
      if (
        bucket.timestamps.length === 0 && 
        (!bucket.blockedUntil || bucket.blockedUntil < now)
      ) {
        this.buckets.delete(key);
      }
    }
  }
}

// Export singleton instance
export const rateLimiter = new RateLimiter();

================
File: src/index.ts
================
#!/usr/bin/env node
import { startServer } from './server.js';
import { config } from 'dotenv';

// Load environment variables
config();

// Parse command line arguments
const args = process.argv.slice(2);
const argMap = new Map();

args.forEach(arg => {
  if (arg.startsWith('--')) {
    const [key, value] = arg.substring(2).split('=');
    if (value !== undefined) {
      argMap.set(key, value);
    } else {
      argMap.set(key, true);
    }
  }
});

// Set environment variables from command line arguments
if (argMap.has('network')) {
  process.env.DEFAULT_NETWORK = argMap.get('network');
}

if (argMap.has('help')) {
  console.log(`
MCP Ethers Wallet Server

Usage:
  npm start -- [options]

Options:
  --network=<network>  Specify the default network (e.g., mainnet, goerli)
  --help               Show this help message
  `);
  process.exit(0);
}

// Start the server
startServer().catch((error: Error) => {
    console.error('Failed to start server:', error);
    process.exit(1);
});

================
File: src/server.ts
================
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { EthersService } from "./services/ethersService.js";
import { DefaultProvider } from "./config/networks.js";
import { z } from "zod";
import { config } from "dotenv";
import { ethers } from "ethers";

// Import the new tool definitions and handlers
import { allTools, allHandlers } from "./tools/index.js";
import { initializeErc20Handlers } from "./tools/handlers/erc20.js";
import { initializeErc721Handlers } from "./tools/handlers/erc721.js";
import { initializeErc1155Handlers } from "./tools/handlers/erc1155.js";

config(); // Load environment variables

// Define schemas for contract calls
const contractCallSchema = z.object({
  contractAddress: z.string(),
  abi: z.union([z.string(), z.array(z.string())]),
  method: z.string(),
  methodArgs: z.array(z.any()).optional(),
  provider: z.string().optional(),
  chainId: z.number().optional(),
});

const contractCallViewSchema = z.object({
  address: z.string(),
  abi: z.union([z.string(), z.array(z.string())]),
  method: z.string(),
  args: z.array(z.any()).optional(),
  provider: z.string().optional(),
  chainId: z.number().optional(),
});

const server = new Server(
  {
    name: "ethers-wallet-server",
    version: "1.0.0",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// Initialize the ethers service with configurable default network
const defaultNetworkInput = process.env.DEFAULT_NETWORK || "mainnet";
// Convert common network names to the official names used in DefaultProvider
const networkAliasMap: Record<string, DefaultProvider> = {
  mainnet: "Ethereum",
  ethereum: "Ethereum",
  polygon: "Polygon PoS",
  arbitrum: "Arbitrum",
  optimism: "Optimism",
  avalanche: "Avalanche C-Chain",
  base: "Base",
};
const defaultNetwork =
  networkAliasMap[defaultNetworkInput.toLowerCase()] ||
  (defaultNetworkInput as DefaultProvider);

// Create provider with the correct network name
const provider = new ethers.AlchemyProvider(
  defaultNetwork === "Ethereum"
    ? "mainnet"
    : defaultNetwork.toLowerCase().replace(" ", "-"),
  process.env.ALCHEMY_API_KEY
);
const ethersService = new EthersService(provider);

// Initialize handlers with ethersService
initializeErc20Handlers(ethersService);
initializeErc721Handlers(ethersService);
initializeErc1155Handlers(ethersService);

// Define existing tools
const existingTools = [
  {
    name: "getSupportedNetworks",
    description:
      "Get a list of all supported networks and their configurations. Shows which network is the default (used when no provider is specified). Call this first to discover available networks before using other network-related functions.",
    inputSchema: {
      type: "object",
      properties: {},
    },
  },
  {
    name: "generateWallet",
    description:
      "Generate a new Ethereum wallet with a random private key. Returns the wallet address and private key. IMPORTANT: Store the private key securely as it provides full control over the wallet.",
    inputSchema: {
      type: "object",
      properties: {
        saveToEnv: {
          type: "boolean",
          description:
            "Optional. If true, the private key will be saved to the server's environment variables for future use. Default is false.",
        },
      },
    },
  },
  {
    name: "loadWallet",
    description:
      "Load an existing wallet from a private key. The wallet will be used for all transactions in the current session. IMPORTANT: Transmitting private keys is a security risk. Use with caution.",
    inputSchema: {
      type: "object",
      properties: {
        privateKey: {
          type: "string",
          description:
            "The private key of the wallet to load. Should start with '0x'.",
        },
        saveToEnv: {
          type: "boolean",
          description:
            "Optional. If true, the private key will be saved to the server's environment variables for this session. Default is true.",
        },
      },
      required: ["privateKey"],
    },
  },
  {
    name: "ethSign",
    description:
      "Signs data using the Ethereum eth_sign method (legacy). IMPORTANT: This is less secure than signMessage as it can sign transaction-like data. Use with caution.",
    inputSchema: {
      type: "object",
      properties: {
        data: {
          type: "string",
          description:
            "The data to sign. Will be converted to hex if not already in hex format.",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
      },
      required: ["data"],
    },
  },
  {
    name: "checkWalletExists",
    description:
      "Check if there is a wallet configured on the server. Returns basic wallet info like address but never exposes private keys.",
    inputSchema: {
      type: "object",
      properties: {
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks. If not provided, uses the default network.",
        },
      },
    },
  },
  {
    name: "getWalletBalance",
    description: "Get the ETH balance of a wallet",
    inputSchema: {
      type: "object",
      properties: {
        address: {
          type: "string",
          description: "The Ethereum address to query",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
        chainId: {
          type: "number",
          description:
            "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
        },
      },
      required: ["address"],
    },
  },
  {
    name: "getWalletTransactionCount",
    description: "Get the number of transactions ever sent by an address",
    inputSchema: {
      type: "object",
      properties: {
        address: {
          type: "string",
          description: "The Ethereum address to query",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
        chainId: {
          type: "number",
          description:
            "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
        },
      },
      required: ["address"],
    },
  },
  {
    name: "getBlockNumber",
    description: "Get the current block number",
    inputSchema: {
      type: "object",
      properties: {
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
        chainId: {
          type: "number",
          description:
            "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
        },
      },
    },
  },
  {
    name: "getBlockDetails",
    description: "Get details about a block",
    inputSchema: {
      type: "object",
      properties: {
        blockTag: {
          type: ["string", "number"],
          description: "The block number or the string 'latest'",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
        chainId: {
          type: "number",
          description:
            "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
        },
      },
      required: ["blockTag"],
    },
  },
  {
    name: "getTransactionDetails",
    description: "Get details about a transaction",
    inputSchema: {
      type: "object",
      properties: {
        txHash: {
          type: "string",
          description: "The transaction hash to lookup",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
        chainId: {
          type: "number",
          description:
            "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
        },
      },
      required: ["txHash"],
    },
  },
  {
    name: "getGasPrice",
    description: "Get the current gas price",
    inputSchema: {
      type: "object",
      properties: {
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
        chainId: {
          type: "number",
          description:
            "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
        },
      },
    },
  },
  {
    name: "getFeeData",
    description: "Get the current network fee data",
    inputSchema: {
      type: "object",
      properties: {
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
        chainId: {
          type: "number",
          description:
            "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
        },
      },
    },
  },
  {
    name: "getContractCode",
    description: "Get a contract's bytecode",
    inputSchema: {
      type: "object",
      properties: {
        address: {
          type: "string",
          description: "The contract's address",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
        chainId: {
          type: "number",
          description:
            "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
        },
      },
      required: ["address"],
    },
  },
  {
    name: "lookupAddress",
    description: "Get the ENS name for an address",
    inputSchema: {
      type: "object",
      properties: {
        address: {
          type: "string",
          description: "The Ethereum address to resolve",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
        chainId: {
          type: "number",
          description:
            "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
        },
      },
      required: ["address"],
    },
  },
  {
    name: "resolveName",
    description: "Get the address for an ENS name",
    inputSchema: {
      type: "object",
      properties: {
        name: {
          type: "string",
          description: "The ENS name to resolve",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
        chainId: {
          type: "number",
          description:
            "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
        },
      },
      required: ["name"],
    },
  },
  {
    name: "formatEther",
    description: "Convert a wei value to a decimal string in ether",
    inputSchema: {
      type: "object",
      properties: {
        wei: {
          type: "string",
          description: "The wei value to format",
        },
      },
      required: ["wei"],
    },
  },
  {
    name: "parseEther",
    description: "Convert an ether value to wei",
    inputSchema: {
      type: "object",
      properties: {
        ether: {
          type: "string",
          description: "The ether value to parse",
        },
      },
      required: ["ether"],
    },
  },
  {
    name: "formatUnits",
    description: "Convert a value to a decimal string with specified units",
    inputSchema: {
      type: "object",
      properties: {
        value: {
          type: "string",
          description: "The value to format",
        },
        unit: {
          type: ["string", "number"],
          description: "The number of decimals or unit name (e.g., 'gwei', 18)",
        },
      },
      required: ["value", "unit"],
    },
  },
  {
    name: "parseUnits",
    description: "Convert a decimal string to its smallest unit representation",
    inputSchema: {
      type: "object",
      properties: {
        value: {
          type: "string",
          description: "The decimal string to parse",
        },
        unit: {
          type: ["string", "number"],
          description: "The number of decimals or unit name (e.g., 'gwei', 18)",
        },
      },
      required: ["value", "unit"],
    },
  },
  {
    name: "sendTransaction",
    description: "Send ETH from the server's wallet to a recipient",
    inputSchema: {
      type: "object",
      properties: {
        to: {
          type: "string",
          description: "The recipient address",
        },
        value: {
          type: "string",
          description: "The amount of ETH to send",
        },
        data: {
          type: "string",
          description: "Optional. Data to include in the transaction",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
      },
      required: ["to", "value"],
    },
  },
  {
    name: "signMessage",
    description: "Sign a message using the server's wallet",
    inputSchema: {
      type: "object",
      properties: {
        message: {
          type: "string",
          description: "The message to sign",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
      },
      required: ["message"],
    },
  },
  {
    name: "contractCall",
    description:
      "Call a view/pure method on a smart contract (read-only operations)",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the contract to call",
        },
        abi: {
          type: "string",
          description: "The ABI of the contract as a JSON string",
        },
        method: {
          type: "string",
          description: "The name of the method to call",
        },
        args: {
          type: "array",
          description: "The arguments to pass to the method",
          items: { type: "any" },
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
        chainId: {
          type: "number",
          description:
            "Optional. The chain ID to use for the call. If provided, will verify it matches the provider's network.",
        },
      },
      required: ["contractAddress", "abi", "method"],
    },
  },
  {
    name: "contractCallView",
    description:
      "Call a view/pure method on a smart contract (read-only operations)",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the contract to call",
        },
        abi: {
          type: "string",
          description: "The ABI of the contract as a JSON string",
        },
        method: {
          type: "string",
          description:
            "The name of the method to call (must be a view/pure function)",
        },
        args: {
          type: "array",
          description: "The arguments to pass to the method",
          items: { type: "any" },
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
        chainId: {
          type: "number",
          description:
            "Optional. The chain ID to use for the call. If provided, will verify it matches the provider's network.",
        },
      },
      required: ["contractAddress", "abi", "method"],
    },
  },
  {
    name: "contractCallWithEstimate",
    description:
      "Call a method on a smart contract with automatic gas estimation",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the smart contract",
        },
        abi: {
          type: "string",
          description: "The ABI of the contract as a JSON string",
        },
        method: {
          type: "string",
          description: "The method name to invoke",
        },
        methodArgs: {
          type: "array",
          description: "An array of arguments to pass to the method",
          items: {
            type: ["string", "number", "boolean", "object"],
          },
        },
        value: {
          type: "string",
          description: "Optional. The amount of ETH to send with the call",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
      },
      required: ["contractAddress", "abi", "method"],
    },
  },
  {
    name: "contractSendTransaction",
    description:
      "Call a method on a smart contract and send a transaction with custom parameters",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the smart contract",
        },
        abi: {
          type: "string",
          description: "The ABI of the contract as a JSON string",
        },
        method: {
          type: "string",
          description: "The method name to invoke",
        },
        methodArgs: {
          type: "array",
          description: "An array of arguments to pass to the method",
          items: {
            type: ["string", "number", "boolean", "object"],
          },
        },
        value: {
          type: "string",
          description: "Optional. The amount of ETH to send with the call",
        },
        gasLimit: {
          type: "string",
          description: "Optional. The gas limit for the transaction",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
      },
      required: ["contractAddress", "abi", "method"],
    },
  },
  {
    name: "contractSendTransactionWithEstimate",
    description:
      "Call a method on a smart contract and send a transaction with automatic gas estimation",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the smart contract",
        },
        abi: {
          type: "string",
          description: "The ABI of the contract as a JSON string",
        },
        method: {
          type: "string",
          description: "The method name to invoke",
        },
        methodArgs: {
          type: "array",
          description: "An array of arguments to pass to the method",
          items: {
            type: ["string", "number", "boolean", "object"],
          },
        },
        value: {
          type: "string",
          description: "Optional. The amount of ETH to send with the call",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
      },
      required: ["contractAddress", "abi", "method"],
    },
  },
  {
    name: "contractCallWithOverrides",
    description: "Call a method on a smart contract with advanced options",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the smart contract",
        },
        abi: {
          type: "string",
          description: "The ABI of the contract as a JSON string",
        },
        method: {
          type: "string",
          description: "The method name to invoke",
        },
        methodArgs: {
          type: "array",
          description: "An array of arguments to pass to the method",
          items: {
            type: ["string", "number", "boolean", "object"],
          },
        },
        value: {
          type: "string",
          description: "Optional. The amount of ETH to send with the call",
        },
        gasLimit: {
          type: "string",
          description: "Optional. A manual gas limit for the transaction",
        },
        gasPrice: {
          type: "string",
          description: "Optional. A manual gas price for legacy transactions",
        },
        nonce: {
          type: "number",
          description: "Optional. A manual nonce for the transaction",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
      },
      required: ["contractAddress", "abi", "method"],
    },
  },
  {
    name: "contractSendTransactionWithOverrides",
    description:
      "Call a method on a smart contract and send a transaction with custom parameters",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the smart contract",
        },
        abi: {
          type: "string",
          description: "The ABI of the contract as a JSON string",
        },
        method: {
          type: "string",
          description: "The method name to invoke",
        },
        methodArgs: {
          type: "array",
          description: "An array of arguments to pass to the method",
          items: {
            type: ["string", "number", "boolean", "object"],
          },
        },
        value: {
          type: "string",
          description: "Optional. The amount of ETH to send with the call",
        },
        gasLimit: {
          type: "string",
          description: "Optional. The gas limit for the transaction",
        },
        gasPrice: {
          type: "string",
          description: "Optional. A manual gas price for legacy transactions",
        },
        nonce: {
          type: "number",
          description: "Optional. A manual nonce for the transaction",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
      },
      required: ["contractAddress", "abi", "method"],
    },
  },
  {
    name: "sendRawTransaction",
    description: "Send a raw transaction",
    inputSchema: {
      type: "object",
      properties: {
        signedTransaction: {
          type: "string",
          description: "A fully serialized and signed transaction",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
      },
      required: ["signedTransaction"],
    },
  },
  {
    name: "queryLogs",
    description: "Query historical logs",
    inputSchema: {
      type: "object",
      properties: {
        address: {
          type: "string",
          description: "The contract address emitting the events (optional).",
        },
        topics: {
          type: "array",
          description:
            "A list of topics to filter by. Each item can be a string, null, or an array of strings (optional)",
          items: {
            type: ["string", "null", "array"],
            items: { type: "string" },
          },
        },
        fromBlock: {
          type: ["string", "number"],
          description: "The starting block number (optional).",
        },
        toBlock: {
          type: ["string", "number"],
          description: "The ending block number (optional).",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
      },
    },
  },
  {
    name: "contractEvents",
    description: "Query historical events from a contract",
    inputSchema: {
      type: "object",
      properties: {
        contractAddress: {
          type: "string",
          description: "The address of the contract to query events from",
        },
        abi: {
          type: "string",
          description: "The ABI of the contract as a JSON string",
        },
        eventName: {
          type: "string",
          description: "The name of the event to look for. (Optional).",
        },
        topics: {
          type: "array",
          description:
            "A list of topics to filter by. Each item can be a string, null, or an array of strings (optional)",
          items: {
            type: ["string", "null", "array"],
            items: { type: "string" },
          },
        },
        fromBlock: {
          type: ["string", "number"],
          description: "The starting block number (optional).",
        },
        toBlock: {
          type: ["string", "number"],
          description: "The ending block number (optional).",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
      },
      required: ["contractAddress", "abi"],
    },
  },
  {
    name: "sendTransactionWithOptions",
    description:
      "Send a transaction with advanced options including gas limit, gas price, and nonce",
    inputSchema: {
      type: "object",
      properties: {
        to: {
          type: "string",
          description: "The recipient address",
        },
        value: {
          type: "string",
          description: "The amount of ETH to send",
        },
        data: {
          type: "string",
          description: "Optional. Data to include in the transaction",
        },
        gasLimit: {
          type: "string",
          description: "Optional. The gas limit for the transaction",
        },
        gasPrice: {
          type: "string",
          description: "Optional. The gas price in gwei",
        },
        nonce: {
          type: "number",
          description: "Optional. The nonce to use for the transaction",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
        chainId: {
          type: "number",
          description:
            "Optional. The chain ID to use for the transaction. If provided, will verify it matches the provider's network.",
        },
      },
      required: ["to", "value"],
    },
  },
  {
    name: "getTransactionsByBlock",
    description: "Get details about transactions in a specific block.",
    inputSchema: {
      type: "object",
      properties: {
        blockTag: {
          type: ["string", "number"],
          description: "The block number or the string 'latest'",
        },
        provider: {
          type: "string",
          description:
            "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
        },
        chainId: {
          type: "number",
          description:
            "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
        },
      },
      required: ["blockTag"],
    },
  },
];

// Combine all tools
const tools = [...existingTools, ...allTools];

// Define available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return { tools };
});

// Define existing handlers
const existingHandlers = {
  getWalletBalance: async (args: unknown) => {
    const schema = z.object({
      address: z.string(),
      provider: z.string().optional(),
      chainId: z.number().optional(),
    });
    const { address, provider, chainId } = schema.parse(args);
    const balance = await ethersService.getBalance(address, provider, chainId);
    return {
      content: [
        { type: "text", text: `The balance of ${address} is ${balance} ETH` },
      ],
    };
  },

  getWalletTransactionCount: async (args: unknown) => {
    const schema = z.object({
      address: z.string(),
      provider: z.string().optional(),
      chainId: z.number().optional(),
    });
    const { address, provider, chainId } = schema.parse(args);
    const count = await ethersService.getTransactionCount(
      address,
      provider,
      chainId
    );
    return {
      content: [
        {
          type: "text",
          text: `The transaction count for ${address} is ${count}`,
        },
      ],
    };
  },

  getBlockNumber: async (args: unknown) => {
    const schema = z.object({
      provider: z.string().optional(),
      chainId: z.number().optional(),
    });
    const { provider, chainId } = schema.parse(args);
    const blockNumber = await ethersService.getBlockNumber(provider, chainId);
    return {
      content: [
        { type: "text", text: `The current block number is ${blockNumber}` },
      ],
    };
  },

  getSupportedNetworks: async (args: unknown) => {
    const networks = ethersService.getSupportedNetworks();
    return {
      content: [{ type: "text", text: JSON.stringify(networks, null, 2) }],
    };
  },

  generateWallet: async (args: unknown) => {
    const schema = z.object({
      saveToEnv: z.boolean().optional().default(false),
    });

    try {
      const { saveToEnv } = schema.parse(args);

      // Generate a new random wallet
      const wallet = ethers.Wallet.createRandom();
      const address = wallet.address;
      const privateKey = wallet.privateKey;

      // If saveToEnv is true, save the private key to process.env
      // Note: This only persists for the current session
      if (saveToEnv) {
        process.env.PRIVATE_KEY = privateKey;

        // Update the ethersService with the new wallet
        const signer = new ethers.Wallet(privateKey, ethersService.provider);
        ethersService.setSigner(signer);
      }

      return {
        content: [
          {
            type: "text",
            text: `New wallet generated:\n\nAddress: ${address}\nPrivate Key: ${privateKey}\n\n${
              saveToEnv
                ? "The private key has been saved to the server's environment for this session. It will be used for transactions until the server restarts."
                : "IMPORTANT: Save this private key securely. It has NOT been saved on the server."
            }\n\nTo use this wallet permanently, add this private key to your .env file as PRIVATE_KEY=${privateKey}`,
          },
        ],
      };
    } catch (error) {
      return {
        isError: true,
        content: [
          {
            type: "text",
            text: `Error generating wallet: ${
              error instanceof Error ? error.message : String(error)
            }`,
          },
        ],
      };
    }
  },

  loadWallet: async (args: unknown) => {
    const schema = z.object({
      privateKey: z
        .string()
        .refine((key) => key.startsWith("0x") && key.length === 66, {
          message:
            "Invalid private key format. Must start with '0x' and be 66 characters long.",
        }),
      saveToEnv: z.boolean().optional().default(true),
    });

    try {
      const { privateKey, saveToEnv } = schema.parse(args);

      // Create a wallet from the private key
      const wallet = new ethers.Wallet(privateKey, ethersService.provider);
      const address = wallet.address;

      // Set the wallet as the signer for ethersService
      ethersService.setSigner(wallet);

      // Optionally save to environment variables (in-memory only)
      if (saveToEnv) {
        process.env.PRIVATE_KEY = privateKey;
      }

      return {
        content: [
          {
            type: "text",
            text: `Wallet loaded successfully!\n\nAddress: ${address}\n\nThis wallet will be used for all transactions in the current session${
              saveToEnv
                ? " and has been saved to the server's environment variables for this session"
                : ""
            }.\n\nIMPORTANT: The wallet will only persist until the server is restarted.`,
          },
        ],
      };
    } catch (error) {
      // Sanitize error message to ensure it doesn't contain the private key
      let errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes("0x")) {
        errorMessage = errorMessage.replace(
          /0x[a-fA-F0-9]{64}/g,
          "[PRIVATE_KEY_REDACTED]"
        );
      }

      return {
        isError: true,
        content: [
          {
            type: "text",
            text: `Error loading wallet: ${errorMessage}`,
          },
        ],
      };
    }
  },

  checkWalletExists: async (args: unknown) => {
    const schema = z.object({
      provider: z.string().optional(),
    });
    const { provider } = schema.parse(args);

    try {
      const walletInfo = await ethersService.getWalletInfo(provider);
      if (!walletInfo) {
        return {
          content: [
            {
              type: "text",
              text: "No wallet is currently configured on the server.",
            },
          ],
        };
      }

      return {
        content: [
          {
            type: "text",
            text: `Wallet is configured with address: ${walletInfo.address}`,
          },
        ],
      };
    } catch (error) {
      return {
        isError: true,
        content: [
          {
            type: "text",
            text: `Error checking wallet: ${
              error instanceof Error ? error.message : String(error)
            }`,
          },
        ],
      };
    }
  },

  getFeeData: async (args: unknown) => {
    const schema = z.object({
      provider: z.string().optional(),
      chainId: z.number().optional(),
    });

    try {
      const { provider, chainId } = schema.parse(args);
      const feeData = await ethersService.getFeeData(provider, chainId);

      // Format the fee data in a more readable way
      const formattedFeeData = {
        gasPrice: feeData.gasPrice
          ? ethersService.formatUnits(feeData.gasPrice, "gwei") + " gwei"
          : null,
        maxFeePerGas: feeData.maxFeePerGas
          ? ethersService.formatUnits(feeData.maxFeePerGas, "gwei") + " gwei"
          : null,
        maxPriorityFeePerGas: feeData.maxPriorityFeePerGas
          ? ethersService.formatUnits(feeData.maxPriorityFeePerGas, "gwei") +
            " gwei"
          : null,
      };

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(formattedFeeData, null, 2),
          },
        ],
      };
    } catch (error) {
      // Proper error handling according to MCP protocol
      return {
        isError: true,
        content: [
          {
            type: "text",
            text: `Error getting fee data: ${
              error instanceof Error ? error.message : String(error)
            }`,
          },
        ],
      };
    }
  },

  getGasPrice: async (args: unknown) => {
    const schema = z.object({
      provider: z.string().optional(),
      chainId: z.number().optional(),
    });

    try {
      const { provider, chainId } = schema.parse(args);
      const gasPrice = await ethersService.getGasPrice(provider, chainId);

      // Format the gas price in gwei for readability
      const gasPriceGwei = ethersService.formatUnits(gasPrice, "gwei");

      return {
        content: [
          {
            type: "text",
            text: `Current gas price: ${gasPriceGwei} gwei`,
          },
        ],
      };
    } catch (error) {
      // Proper error handling according to MCP protocol
      return {
        isError: true,
        content: [
          {
            type: "text",
            text: `Error getting gas price: ${
              error instanceof Error ? error.message : String(error)
            }`,
          },
        ],
      };
    }
  },

  signMessage: async (args: unknown) => {
    const schema = z.object({
      message: z.string(),
      provider: z.string().optional(),
    });

    try {
      const { message, provider } = schema.parse(args);

      // Check if a wallet is configured
      const walletInfo = await ethersService.getWalletInfo(provider);
      if (!walletInfo) {
        throw new Error(
          "No wallet is configured. Please set up a wallet using loadWallet or generateWallet first."
        );
      }

      // Sign the message
      const signature = await ethersService.signMessage(message, provider);

      return {
        content: [
          {
            type: "text",
            text: `Message signed successfully!\n\nMessage: "${message}"\nSigner: ${walletInfo.address}\nSignature: ${signature}`,
          },
        ],
      };
    } catch (error) {
      return {
        isError: true,
        content: [
          {
            type: "text",
            text: `Error signing message: ${
              error instanceof Error ? error.message : String(error)
            }`,
          },
        ],
      };
    }
  },

  ethSign: async (args: unknown) => {
    const schema = z.object({
      data: z.string(),
      provider: z.string().optional(),
    });

    try {
      const { data, provider } = schema.parse(args);

      // Check if a wallet is configured
      const walletInfo = await ethersService.getWalletInfo(provider);
      if (!walletInfo) {
        throw new Error(
          "No wallet is configured. Please set up a wallet using loadWallet or generateWallet first."
        );
      }

      // Sign the data using eth_sign
      const signature = await ethersService.ethSign(data, provider);

      return {
        content: [
          {
            type: "text",
            text: `Data signed successfully using eth_sign!\n\nData: ${data}\nSigner: ${walletInfo.address}\nSignature: ${signature}\n\nWARNING: eth_sign is a legacy signing method and less secure than personal_sign. Use with caution.`,
          },
        ],
      };
    } catch (error) {
      return {
        isError: true,
        content: [
          {
            type: "text",
            text: `Error signing data with eth_sign: ${
              error instanceof Error ? error.message : String(error)
            }`,
          },
        ],
      };
    }
  },
};

// Combine all handlers
const toolHandlers = {
  ...existingHandlers,
  ...allHandlers,
};

// Handle tool calls
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    const handler = toolHandlers[name as keyof typeof toolHandlers];
    if (!handler) {
      throw new Error(`Tool not found: ${name}`);
    }
    return await handler(args);
  } catch (error: any) {
    return {
      isError: true,
      content: [
        {
          type: "text",
          text: `Error processing the request: ${error.message}`,
        },
      ],
    };
  }
});

export async function startServer() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error(
    `MCP server running on stdio (default network: ${defaultNetwork})`
  );
}

================
File: .env.example
================
INFURA_API_KEY=your_infura_api_key_here

================
File: .gitignore
================
node_modules/
build/
.env
.env.test

================
File: claude-server.json
================
{
    "name": "ethers-wallet-server",
    "description": "A server that provides Ethereum wallet and blockchain interaction capabilities",
    "command": "node build/index.js",
    "tools": [
        {
            "name": "getWalletBalance",
            "description": "Get the ETH balance of a wallet",
            "parameters": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The Ethereum address to query"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["address"]
            }
        },
        {
            "name": "getERC20Balance",
            "description": "Get the ERC20 token balance of a wallet",
            "parameters": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The Ethereum address to query"
                    },
                    "tokenAddress": {
                        "type": "string",
                        "description": "The address of the ERC20 token contract"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["address", "tokenAddress"]
            }
        },
        {
            "name": "getWalletTransactionCount",
            "description": "Get the number of transactions ever sent by an address",
            "parameters": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The Ethereum address to query"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["address"]
            }
        },
        {
            "name": "getBlockNumber",
            "description": "Get the current block number",
            "parameters": {
                "type": "object",
                "properties": {
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                }
            }
        },
        {
            "name": "getBlockDetails",
            "description": "Get details about a block",
            "parameters": {
                "type": "object",
                "properties": {
                    "blockTag": {
                        "type": ["string", "number"],
                        "description": "The block number or the string 'latest'"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["blockTag"]
            }
        },
        {
            "name": "getTransactionDetails",
            "description": "Get details about a transaction",
            "parameters": {
                "type": "object",
                "properties": {
                    "txHash": {
                        "type": "string",
                        "description": "The transaction hash to lookup"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["txHash"]
            }
        },
        {
            "name": "getGasPrice",
            "description": "Get the current gas price",
            "parameters": {
                "type": "object",
                "properties": {
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                }
            }
        },
        {
            "name": "getFeeData",
            "description": "Get the current network fee data",
            "parameters": {
                "type": "object",
                "properties": {
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                }
            }
        },
        {
            "name": "getContractCode",
            "description": "Get a contract's bytecode",
            "parameters": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The contract's address"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["address"]
            }
        },
        {
            "name": "lookupAddress",
            "description": "Get the ENS name for an address",
            "parameters": {
                "type": "object",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The Ethereum address to resolve"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["address"]
            }
        },
        {
            "name": "resolveName",
            "description": "Get the address for an ENS name",
            "parameters": {
                "type": "object",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The ENS name to resolve"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["name"]
            }
        },
        {
            "name": "formatEther",
            "description": "Convert a wei value to a decimal string in ether",
            "parameters": {
                "type": "object",
                "properties": {
                    "wei": {
                        "type": "string",
                        "description": "The wei value to format"
                    }
                },
                "required": ["wei"]
            }
        },
        {
            "name": "parseEther",
            "description": "Convert an ether value to wei",
            "parameters": {
                "type": "object",
                "properties": {
                    "ether": {
                        "type": "string",
                        "description": "The ether value to parse"
                    }
                },
                "required": ["ether"]
            }
        },
        {
            "name": "formatUnits",
            "description": "Convert a value to a decimal string with specified units",
            "parameters": {
                "type": "object",
                "properties": {
                    "value": {
                        "type": "string",
                        "description": "The value to format"
                    },
                    "unit": {
                        "type": ["string", "number"],
                        "description": "The number of decimals or unit name (e.g., 'gwei', 18)"
                    }
                },
                "required": ["value", "unit"]
            }
        },
        {
            "name": "parseUnits",
            "description": "Convert a decimal string to its smallest unit representation",
            "parameters": {
                "type": "object",
                "properties": {
                    "value": {
                        "type": "string",
                        "description": "The decimal string to parse"
                    },
                    "unit": {
                        "type": ["string", "number"],
                        "description": "The number of decimals or unit name (e.g., 'gwei', 18)"
                    }
                },
                "required": ["value", "unit"]
            }
        },
        {
            "name": "sendTransaction",
            "description": "Send ETH from the server's wallet to a recipient",
            "parameters": {
                "type": "object",
                "properties": {
                    "to": {
                        "type": "string",
                        "description": "The recipient address"
                    },
                    "value": {
                        "type": "string",
                        "description": "The amount of ETH to send"
                    },
                    "data": {
                        "type": "string",
                        "description": "Optional. Data to include in the transaction"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["to", "value"]
            }
        },
        {
            "name": "signMessage",
            "description": "Sign a message using the server's wallet",
            "parameters": {
                "type": "object",
                "properties": {
                    "message": {
                        "type": "string",
                        "description": "The message to sign"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["message"]
            }
        },
        {
            "name": "contractCall",
            "description": "Call a method on a smart contract",
            "parameters": {
                "type": "object",
                "properties": {
                    "contractAddress": {
                        "type": "string",
                        "description": "The address of the smart contract"
                    },
                    "abi": {
                        "type": "string",
                        "description": "The ABI of the contract as a JSON string"
                    },
                    "method": {
                        "type": "string",
                        "description": "The method name to invoke"
                    },
                    "methodArgs": {
                        "type": "array",
                        "description": "An array of arguments to pass to the method",
                        "items": {
                            "type": ["string", "number", "boolean", "object"]
                        }
                    },
                    "value": {
                        "type": "string",
                        "description": "Optional. The amount of ETH to send with the call"
                    },
                    "provider": {
                        "type": "string",
                        "description": "Optional. Either a supported network name (mainnet, sepolia, goerli, arbitrum, optimism, base, polygon) or a custom RPC URL"
                    }
                },
                "required": ["contractAddress", "abi", "method"]
            }
        }
    ]
}

================
File: hardhat.config.cjs
================
require("@nomicfoundation/hardhat-toolbox");
require("@nomicfoundation/hardhat-ethers");

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  solidity: "0.8.24",
  networks: {
    hardhat: {
      accounts: {
        accountsBalance: "100000000000000000000000000000000000000" // 100 trillion ETH
      },
      mining: {
        auto: true,
        interval: 0
      }
    }
  }
};

================
File: jest.config.cjs
================
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest/presets/default-esm',
  testEnvironment: 'node',
  testMatch: ['**/*.test.ts'],
  transform: {
    '^.+\\.tsx?$': ['ts-jest', {
      useESM: true,
    }]
  },
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1'
  },
  setupFilesAfterEnv: ['./jest.setup.ts']
};

================
File: jest.config.js
================
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest/presets/default-esm',
  testEnvironment: 'node',
  extensionsToTreatAsEsm: ['.ts'],
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1',
  },
  transform: {
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        useESM: true,
      },
    ],
  },
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  globals: {
    'ts-jest': {
      useESM: true,
    },
  },
};

================
File: jest.setup.js
================


================
File: jest.setup.ts
================
import { cleanupTestEnvironment, resetTestEnvironment, getTestEnvironment } from './src/tests/utils/globalTestSetup.js';
import { config } from 'dotenv';

// Load test environment variables
config({ path: '.env.test' });

// Set default environment variables if not set
process.env.PRIVATE_KEY = process.env.PRIVATE_KEY || '0x0123456789012345678901234567890123456789012345678901234567890123';
process.env.INFURA_API_KEY = process.env.INFURA_API_KEY || '1234567890abcdef1234567890abcdef';
process.env.PROVIDER_URL = process.env.PROVIDER_URL || 'https://eth-sepolia.g.alchemy.com/v2/demo';

// Increase the timeout for all tests
jest.setTimeout(30000);

// Reset environment before all tests
beforeAll(async () => {
  try {
    await resetTestEnvironment();
  } catch (error) {
    console.error('Error during test environment reset:', error);
    throw error;
  }
});

// Mine 10 blocks before each test
beforeEach(async () => {
  try {
    const testEnv = await getTestEnvironment();
    // Mine 10 blocks
    for (let i = 0; i < 10; i++) {
      await testEnv.provider.send('evm_mine', []);
    }
  } catch (error) {
    console.error('Error mining blocks:', error);
    throw error;
  }
});

// Clean up after all tests
afterAll(async () => {
  try {
    await cleanupTestEnvironment();
  } catch (error) {
    console.error('Error during test environment cleanup:', error);
  }
});

// Add BigInt serialization support
declare global {
  interface BigInt {
    toJSON(): string;
  }
}

// Add BigInt serialization support
(BigInt.prototype as any).toJSON = function() {
  return this.toString();
};

// Extend Jest's expect
declare global {
  namespace jest {
    interface Matchers<R> {
      toBeBigInt(expected: bigint): R;
    }
  }
}

expect.extend({
  toBeBigInt(received: bigint, expected: bigint) {
    const pass = received === expected;
    if (pass) {
      return {
        message: () => `expected ${received} not to be ${expected}`,
        pass: true,
      };
    } else {
      return {
        message: () => `expected ${received} to be ${expected}`,
        pass: false,
      };
    }
  },
});

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Dennison Bertram

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: MCP-docs.txt
================
# Example Clients
Source: https://modelcontextprotocol.io/clients

A list of applications that support MCP integrations

This page provides an overview of applications that support the Model Context Protocol (MCP). Each client may support different MCP features, allowing for varying levels of integration with MCP servers.

## Feature support matrix

| Client                               | [Resources] | [Prompts] | [Tools] | [Sampling] | Roots | Notes                                                              |
| ------------------------------------ | ----------- | --------- | ------- | ---------- | ----- | ------------------------------------------------------------------ |
| [Claude Desktop App][Claude]         |            |          |        |           |      | Full support for all MCP features                                  |
| [5ire][5ire]                         |            |          |        |           |      | Supports tools.                                                    |
| [BeeAI Framework][BeeAI Framework]   |            |          |        |           |      | Supports tools in agentic workflows.                               |
| [Cline][Cline]                       |            |          |        |           |      | Supports tools and resources.                                      |
| [Continue][Continue]                 |            |          |        |           |      | Full support for all MCP features                                  |
| [Cursor][Cursor]                     |            |          |        |           |      | Supports tools.                                                    |
| [Emacs Mcp][Mcp.el]                  |            |          |        |           |      | Supports tools in Emacs.                                           |
| [Firebase Genkit][Genkit]            |           |          |        |           |      | Supports resource list and lookup through tools.                   |
| [GenAIScript][GenAIScript]           |            |          |        |           |      | Supports tools.                                                    |
| [Goose][Goose]                       |            |          |        |           |      | Supports tools.                                                    |
| [LibreChat][LibreChat]               |            |          |        |           |      | Supports tools for Agents                                          |
| [mcp-agent][mcp-agent]               |            |          |        |          |      | Supports tools, server connection management, and agent workflows. |
| [Roo Code][Roo Code]                 |            |          |        |           |      | Supports tools and resources.                                      |
| [Sourcegraph Cody][Cody]             |            |          |        |           |      | Supports resources through OpenCTX                                 |
| [Superinterface][Superinterface]     |            |          |        |           |      | Supports tools                                                     |
| [TheiaAI/TheiaIDE][TheiaAI/TheiaIDE] |            |          |        |           |      | Supports tools for Agents in Theia AI and the AI-powered Theia IDE |
| [Windsurf Editor][Windsurf]          |            |          |        |           |      | Supports tools with AI Flow for collaborative development.         |
| [Zed][Zed]                           |            |          |        |           |      | Prompts appear as slash commands                                   |
| \[OpenSumi]\[OpenSumi]               |            |          |        |           |      | Supports tools in OpenSumi                                         |

[Claude]: https://claude.ai/download

[Cursor]: https://cursor.com

[Zed]: https://zed.dev

[Cody]: https://sourcegraph.com/cody

[Genkit]: https://github.com/firebase/genkit

[Continue]: https://github.com/continuedev/continue

[GenAIScript]: https://microsoft.github.io/genaiscript/reference/scripts/mcp-tools/

[Cline]: https://github.com/cline/cline

[LibreChat]: https://github.com/danny-avila/LibreChat

[TheiaAI/TheiaIDE]: https://eclipsesource.com/blogs/2024/12/19/theia-ide-and-theia-ai-support-mcp/

[Superinterface]: https://superinterface.ai

[5ire]: https://github.com/nanbingxyz/5ire

[BeeAI Framework]: https://i-am-bee.github.io/beeai-framework

[mcp-agent]: https://github.com/lastmile-ai/mcp-agent

[Mcp.el]: https://github.com/lizqwerscott/mcp.el

[Roo Code]: https://roocode.com

[Goose]: https://block.github.io/goose/docs/goose-architecture/#interoperability-with-extensions

[Windsurf]: https://codeium.com/windsurf

[Resources]: https://modelcontextprotocol.io/docs/concepts/resources

[Prompts]: https://modelcontextprotocol.io/docs/concepts/prompts

[Tools]: https://modelcontextprotocol.io/docs/concepts/tools

[Sampling]: https://modelcontextprotocol.io/docs/concepts/sampling

## Client details

### Claude Desktop App

The Claude desktop application provides comprehensive support for MCP, enabling deep integration with local tools and data sources.

**Key features:**

* Full support for resources, allowing attachment of local files and data
* Support for prompt templates
* Tool integration for executing commands and scripts
* Local server connections for enhanced privacy and security

>  Note: The Claude.ai web application does not currently support MCP. MCP features are only available in the desktop application.

### 5ire

[5ire](https://github.com/nanbingxyz/5ire) is an open source cross-platform desktop AI assistant that supports tools through MCP servers.

**Key features:**

* Built-in MCP servers can be quickly enabled and disabled.
* Users can add more servers by modifying the configuration file.
* It is open-source and user-friendly, suitable for beginners.
* Future support for MCP will be continuously improved.

### BeeAI Framework

[BeeAI Framework](https://i-am-bee.github.io/beeai-framework) is an open-source framework for building, deploying, and serving powerful agentic workflows at scale. The framework includes the **MCP Tool**, a native feature that simplifies the integration of MCP servers into agentic workflows.

**Key features:**

* Seamlessly incorporate MCP tools into agentic workflows.
* Quickly instantiate framework-native tools from connected MCP client(s).
* Planned future support for agentic MCP capabilities.

**Learn more:**

* [Example of using MCP tools in agentic workflow](https://i-am-bee.github.io/beeai-framework/#/typescript/tools?id=using-the-mcptool-class)

### Cline

[Cline](https://github.com/cline/cline) is an autonomous coding agent in VS Code that edits files, runs commands, uses a browser, and morewith your permission at each step.

**Key features:**

* Create and add tools through natural language (e.g. "add a tool that searches the web")
* Share custom MCP servers Cline creates with others via the `~/Documents/Cline/MCP` directory
* Displays configured MCP servers along with their tools, resources, and any error logs

### Continue

[Continue](https://github.com/continuedev/continue) is an open-source AI code assistant, with built-in support for all MCP features.

**Key features**

* Type "@" to mention MCP resources
* Prompt templates surface as slash commands
* Use both built-in and MCP tools directly in chat
* Supports VS Code and JetBrains IDEs, with any LLM

### Cursor

[Cursor](https://docs.cursor.com/advanced/model-context-protocol) is an AI code editor.

**Key Features**:

* Support for MCP tools in Cursor Composer
* Support for both STDIO and SSE

### Emacs Mcp

[Emacs Mcp](https://github.com/lizqwerscott/mcp.el) is an Emacs client designed to interface with MCP servers, enabling seamless connections and interactions. It provides MCP tool invocation support for AI plugins like [gptel](https://github.com/karthink/gptel) and [llm](https://github.com/ahyatt/llm), adhering to Emacs' standard tool invocation format. This integration enhances the functionality of AI tools within the Emacs ecosystem.

**Key features:**

* Provides MCP tool support for Emacs.

### Firebase Genkit

[Genkit](https://github.com/firebase/genkit) is Firebase's SDK for building and integrating GenAI features into applications. The [genkitx-mcp](https://github.com/firebase/genkit/tree/main/js/plugins/mcp) plugin enables consuming MCP servers as a client or creating MCP servers from Genkit tools and prompts.

**Key features:**

* Client support for tools and prompts (resources partially supported)
* Rich discovery with support in Genkit's Dev UI playground
* Seamless interoperability with Genkit's existing tools and prompts
* Works across a wide variety of GenAI models from top providers

### GenAIScript

Programmatically assemble prompts for LLMs using [GenAIScript](https://microsoft.github.io/genaiscript/) (in JavaScript). Orchestrate LLMs, tools, and data in JavaScript.

**Key features:**

* JavaScript toolbox to work with prompts
* Abstraction to make it easy and productive
* Seamless Visual Studio Code integration

### Goose

[Goose](https://github.com/block/goose) is an open source AI agent that supercharges your software development by automating coding tasks.

**Key features:**

* Expose MCP functionality to Goose through tools.
* MCPs can be installed directly via the [extensions directory](https://block.github.io/goose/v1/extensions/), CLI, or UI.
* Goose allows you to extend its functionality by [building your own MCP servers](https://block.github.io/goose/docs/tutorials/custom-extensions).
* Includes built-in tools for development, web scraping, automation, memory, and integrations with JetBrains and Google Drive.

### LibreChat

[LibreChat](https://github.com/danny-avila/LibreChat) is an open-source, customizable AI chat UI that supports multiple AI providers, now including MCP integration.

**Key features:**

* Extend current tool ecosystem, including [Code Interpreter](https://www.librechat.ai/docs/features/code_interpreter) and Image generation tools, through MCP servers
* Add tools to customizable [Agents](https://www.librechat.ai/docs/features/agents), using a variety of LLMs from top providers
* Open-source and self-hostable, with secure multi-user support
* Future roadmap includes expanded MCP feature support

### mcp-agent

[mcp-agent] is a simple, composable framework to build agents using Model Context Protocol.

**Key features:**

* Automatic connection management of MCP servers.
* Expose tools from multiple servers to an LLM.
* Implements every pattern defined in [Building Effective Agents](https://www.anthropic.com/research/building-effective-agents).
* Supports workflow pause/resume signals, such as waiting for human feedback.

### Roo Code

[Roo Code](https://roocode.com) enables AI coding assistance via MCP.

**Key features:**

* Support for MCP tools and resources
* Integration with development workflows
* Extensible AI capabilities

### Sourcegraph Cody

[Cody](https://openctx.org/docs/providers/modelcontextprotocol) is Sourcegraph's AI coding assistant, which implements MCP through OpenCTX.

**Key features:**

* Support for MCP resources
* Integration with Sourcegraph's code intelligence
* Uses OpenCTX as an abstraction layer
* Future support planned for additional MCP features

### Superinterface

[Superinterface](https://superinterface.ai) is AI infrastructure and a developer platform to build in-app AI assistants with support for MCP, interactive components, client-side function calling and more.

**Key features:**

* Use tools from MCP servers in assistants embedded via React components or script tags
* SSE transport support
* Use any AI model from any AI provider (OpenAI, Anthropic, Ollama, others)

### TheiaAI/TheiaIDE

[Theia AI](https://eclipsesource.com/blogs/2024/10/07/introducing-theia-ai/) is a framework for building AI-enhanced tools and IDEs. The [AI-powered Theia IDE](https://eclipsesource.com/blogs/2024/10/08/introducting-ai-theia-ide/) is an open and flexible development environment built on Theia AI.

**Key features:**

* **Tool Integration**: Theia AI enables AI agents, including those in the Theia IDE, to utilize MCP servers for seamless tool interaction.
* **Customizable Prompts**: The Theia IDE allows users to define and adapt prompts, dynamically integrating MCP servers for tailored workflows.
* **Custom agents**: The Theia IDE supports creating custom agents that leverage MCP capabilities, enabling users to design dedicated workflows on the fly.

Theia AI and Theia IDE's MCP integration provide users with flexibility, making them powerful platforms for exploring and adapting MCP.

**Learn more:**

* [Theia IDE and Theia AI MCP Announcement](https://eclipsesource.com/blogs/2024/12/19/theia-ide-and-theia-ai-support-mcp/)
* [Download the AI-powered Theia IDE](https://theia-ide.org/)

### Windsurf Editor

[Windsurf Editor](https://codeium.com/windsurf) is an agentic IDE that combines AI assistance with developer workflows. It features an innovative AI Flow system that enables both collaborative and independent AI interactions while maintaining developer control.

**Key features:**

* Revolutionary AI Flow paradigm for human-AI collaboration
* Intelligent code generation and understanding
* Rich development tools with multi-model support

### Zed

[Zed](https://zed.dev/docs/assistant/model-context-protocol) is a high-performance code editor with built-in MCP support, focusing on prompt templates and tool integration.

**Key features:**

* Prompt templates surface as slash commands in the editor
* Tool integration for enhanced coding workflows
* Tight integration with editor features and workspace context
* Does not support MCP resources

### OpenSumi

[OpenSumi](https://github.com/opensumi/core) is a framework helps you quickly build AI Native IDE products.

**Key features:**

* Supports MCP tools in OpenSumi
* Supports built-in IDE MCP servers and custom MCP servers

## Adding MCP support to your application

If you've added MCP support to your application, we encourage you to submit a pull request to add it to this list. MCP integration can provide your users with powerful contextual AI capabilities and make your application part of the growing MCP ecosystem.

Benefits of adding MCP support:

* Enable users to bring their own context and tools
* Join a growing ecosystem of interoperable AI applications
* Provide users with flexible integration options
* Support local-first AI workflows

To get started with implementing MCP in your application, check out our [Python](https://github.com/modelcontextprotocol/python-sdk) or [TypeScript SDK Documentation](https://github.com/modelcontextprotocol/typescript-sdk)

## Updates and corrections

This list is maintained by the community. If you notice any inaccuracies or would like to update information about MCP support in your application, please submit a pull request or [open an issue in our documentation repository](https://github.com/modelcontextprotocol/docs/issues).


# Contributing
Source: https://modelcontextprotocol.io/development/contributing

How to participate in Model Context Protocol development

We welcome contributions from the community! Please review our [contributing guidelines](https://github.com/modelcontextprotocol/.github/blob/main/CONTRIBUTING.md) for details on how to submit changes.

All contributors must adhere to our [Code of Conduct](https://github.com/modelcontextprotocol/.github/blob/main/CODE_OF_CONDUCT.md).

For questions and discussions, please use [GitHub Discussions](https://github.com/orgs/modelcontextprotocol/discussions).


# Roadmap
Source: https://modelcontextprotocol.io/development/roadmap

Our plans for evolving Model Context Protocol (H1 2025)

The Model Context Protocol is rapidly evolving. This page outlines our current thinking on key priorities and future direction for **the first half of 2025**, though these may change significantly as the project develops.

<Note>The ideas presented here are not commitmentswe may solve these challenges differently than described, or some may not materialize at all. This is also not an *exhaustive* list; we may incorporate work that isn't mentioned here.</Note>

We encourage community participation! Each section links to relevant discussions where you can learn more and contribute your thoughts.

## Remote MCP Support

Our top priority is enabling [remote MCP connections](https://github.com/modelcontextprotocol/specification/discussions/102), allowing clients to securely connect to MCP servers over the internet. Key initiatives include:

*   [**Authentication & Authorization**](https://github.com/modelcontextprotocol/specification/discussions/64): Adding standardized auth capabilities, particularly focused on OAuth 2.0 support.

*   [**Service Discovery**](https://github.com/modelcontextprotocol/specification/discussions/69): Defining how clients can discover and connect to remote MCP servers.

*   [**Stateless Operations**](https://github.com/modelcontextprotocol/specification/discussions/102): Thinking about whether MCP could encompass serverless environments too, where they will need to be mostly stateless.

## Reference Implementations

To help developers build with MCP, we want to offer documentation for:

*   **Client Examples**: Comprehensive reference client implementation(s), demonstrating all protocol features
*   **Protocol Drafting**: Streamlined process for proposing and incorporating new protocol features

## Distribution & Discovery

Looking ahead, we're exploring ways to make MCP servers more accessible. Some areas we may investigate include:

*   **Package Management**: Standardized packaging format for MCP servers
*   **Installation Tools**: Simplified server installation across MCP clients
*   **Sandboxing**: Improved security through server isolation
*   **Server Registry**: A common directory for discovering available MCP servers

## Agent Support

We're expanding MCP's capabilities for [complex agentic workflows](https://github.com/modelcontextprotocol/specification/discussions/111), particularly focusing on:

*   [**Hierarchical Agent Systems**](https://github.com/modelcontextprotocol/specification/discussions/94): Improved support for trees of agents through namespacing and topology awareness.

*   [**Interactive Workflows**](https://github.com/modelcontextprotocol/specification/issues/97): Better handling of user permissions and information requests across agent hierarchies, and ways to send output to users instead of models.

*   [**Streaming Results**](https://github.com/modelcontextprotocol/specification/issues/117): Real-time updates from long-running agent operations.

## Broader Ecosystem

We're also invested in:

*   **Community-Led Standards Development**: Fostering a collaborative ecosystem where all AI providers can help shape MCP as an open standard through equal participation and shared governance, ensuring it meets the needs of diverse AI applications and use cases.
*   [**Additional Modalities**](https://github.com/modelcontextprotocol/specification/discussions/88): Expanding beyond text to support audio, video, and other formats.
*   \[**Standardization**] Considering standardization through a standardization body.

## Get Involved

We welcome community participation in shaping MCP's future. Visit our [GitHub Discussions](https://github.com/orgs/modelcontextprotocol/discussions) to join the conversation and contribute your ideas.


# What's New
Source: https://modelcontextprotocol.io/development/updates

The latest updates and improvements to MCP

<Update label="2025-02-14" description="Java SDK released">
  * We're excited to announce that the Java SDK developed by Spring AI at VMware Tanzu is now
    the official [Java SDK](https://github.com/modelcontextprotocol/java-sdk) for MCP.
    This joins our existing Kotlin SDK in our growing list of supported languages.
    The Spring AI team will maintain the SDK as an integral part of the Model Context Protocol
    organization. We're thrilled to welcome them to the MCP community!
</Update>

<Update label="2025-01-27" description="Python SDK 1.2.1">
  * Version [1.2.1](https://github.com/modelcontextprotocol/python-sdk/releases/tag/v1.2.1) of the MCP Python SDK has been released,
    delivering important stability improvements and bug fixes.
</Update>

<Update label="2025-01-18" description="SDK and Server Improvements">
  * Simplified, express-like API in the [TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)
  * Added 8 new clients to the [clients page](https://modelcontextprotocol.io/clients)
</Update>

<Update label="2025-01-03" description="SDK and Server Improvements">
  * FastMCP API in the [Python SDK](https://github.com/modelcontextprotocol/python-sdk)
  * Dockerized MCP servers in the [servers repo](https://github.com/modelcontextprotocol/servers)
</Update>

<Update label="2024-12-21" description="Kotlin SDK released">
  * Jetbrains released a Kotlin SDK for MCP!
  * For a sample MCP Kotlin server, check out [this repository](https://github.com/modelcontextprotocol/kotlin-sdk/tree/main/samples/kotlin-mcp-server)
</Update>


# Core architecture
Source: https://modelcontextprotocol.io/docs/concepts/architecture

Understand how MCP connects clients, servers, and LLMs

The Model Context Protocol (MCP) is built on a flexible, extensible architecture that enables seamless communication between LLM applications and integrations. This document covers the core architectural components and concepts.

## Overview

MCP follows a client-server architecture where:

* **Hosts** are LLM applications (like Claude Desktop or IDEs) that initiate connections
* **Clients** maintain 1:1 connections with servers, inside the host application
* **Servers** provide context, tools, and prompts to clients

```mermaid
flowchart LR
    subgraph "&nbsp;Host&nbsp;"
        client1[MCP Client]
        client2[MCP Client]
    end
    subgraph "Server Process"
        server1[MCP Server]
    end
    subgraph "Server Process"
        server2[MCP Server]
    end

    client1 <-->|Transport Layer| server1
    client2 <-->|Transport Layer| server2
```

## Core components

### Protocol layer

The protocol layer handles message framing, request/response linking, and high-level communication patterns.

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    class Protocol<Request, Notification, Result> {
        // Handle incoming requests
        setRequestHandler<T>(schema: T, handler: (request: T, extra: RequestHandlerExtra) => Promise<Result>): void

        // Handle incoming notifications
        setNotificationHandler<T>(schema: T, handler: (notification: T) => Promise<void>): void

        // Send requests and await responses
        request<T>(request: Request, schema: T, options?: RequestOptions): Promise<T>

        // Send one-way notifications
        notification(notification: Notification): Promise<void>
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python
    class Session(BaseSession[RequestT, NotificationT, ResultT]):
        async def send_request(
            self,
            request: RequestT,
            result_type: type[Result]
        ) -> Result:
            """
            Send request and wait for response. Raises McpError if response contains error.
            """
            # Request handling implementation

        async def send_notification(
            self,
            notification: NotificationT
        ) -> None:
            """Send one-way notification that doesn't expect response."""
            # Notification handling implementation

        async def _received_request(
            self,
            responder: RequestResponder[ReceiveRequestT, ResultT]
        ) -> None:
            """Handle incoming request from other side."""
            # Request handling implementation

        async def _received_notification(
            self,
            notification: ReceiveNotificationT
        ) -> None:
            """Handle incoming notification from other side."""
            # Notification handling implementation
    ```
  </Tab>
</Tabs>

Key classes include:

* `Protocol`
* `Client`
* `Server`

### Transport layer

The transport layer handles the actual communication between clients and servers. MCP supports multiple transport mechanisms:

1. **Stdio transport**
   * Uses standard input/output for communication
   * Ideal for local processes

2. **HTTP with SSE transport**
   * Uses Server-Sent Events for server-to-client messages
   * HTTP POST for client-to-server messages

All transports use [JSON-RPC](https://www.jsonrpc.org/) 2.0 to exchange messages. See the [specification](https://spec.modelcontextprotocol.io) for detailed information about the Model Context Protocol message format.

### Message types

MCP has these main types of messages:

1. **Requests** expect a response from the other side:
   ```typescript
   interface Request {
     method: string;
     params?: { ... };
   }
   ```

2. **Results** are successful responses to requests:
   ```typescript
   interface Result {
     [key: string]: unknown;
   }
   ```

3. **Errors** indicate that a request failed:
   ```typescript
   interface Error {
     code: number;
     message: string;
     data?: unknown;
   }
   ```

4. **Notifications** are one-way messages that don't expect a response:
   ```typescript
   interface Notification {
     method: string;
     params?: { ... };
   }
   ```

## Connection lifecycle

### 1. Initialization

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Client->>Server: initialize request
    Server->>Client: initialize response
    Client->>Server: initialized notification

    Note over Client,Server: Connection ready for use
```

1. Client sends `initialize` request with protocol version and capabilities
2. Server responds with its protocol version and capabilities
3. Client sends `initialized` notification as acknowledgment
4. Normal message exchange begins

### 2. Message exchange

After initialization, the following patterns are supported:

* **Request-Response**: Client or server sends requests, the other responds
* **Notifications**: Either party sends one-way messages

### 3. Termination

Either party can terminate the connection:

* Clean shutdown via `close()`
* Transport disconnection
* Error conditions

## Error handling

MCP defines these standard error codes:

```typescript
enum ErrorCode {
  // Standard JSON-RPC error codes
  ParseError = -32700,
  InvalidRequest = -32600,
  MethodNotFound = -32601,
  InvalidParams = -32602,
  InternalError = -32603
}
```

SDKs and applications can define their own error codes above -32000.

Errors are propagated through:

* Error responses to requests
* Error events on transports
* Protocol-level error handlers

## Implementation example

Here's a basic example of implementing an MCP server:

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    import { Server } from "@modelcontextprotocol/sdk/server/index.js";
    import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

    const server = new Server({
      name: "example-server",
      version: "1.0.0"
    }, {
      capabilities: {
        resources: {}
      }
    });

    // Handle requests
    server.setRequestHandler(ListResourcesRequestSchema, async () => {
      return {
        resources: [
          {
            uri: "example://resource",
            name: "Example Resource"
          }
        ]
      };
    });

    // Connect transport
    const transport = new StdioServerTransport();
    await server.connect(transport);
    ```
  </Tab>

  <Tab title="Python">
    ```python
    import asyncio
    import mcp.types as types
    from mcp.server import Server
    from mcp.server.stdio import stdio_server

    app = Server("example-server")

    @app.list_resources()
    async def list_resources() -> list[types.Resource]:
        return [
            types.Resource(
                uri="example://resource",
                name="Example Resource"
            )
        ]

    async def main():
        async with stdio_server() as streams:
            await app.run(
                streams[0],
                streams[1],
                app.create_initialization_options()
            )

    if __name__ == "__main__":
        asyncio.run(main)
    ```
  </Tab>
</Tabs>

## Best practices

### Transport selection

1. **Local communication**
   * Use stdio transport for local processes
   * Efficient for same-machine communication
   * Simple process management

2. **Remote communication**
   * Use SSE for scenarios requiring HTTP compatibility
   * Consider security implications including authentication and authorization

### Message handling

1. **Request processing**
   * Validate inputs thoroughly
   * Use type-safe schemas
   * Handle errors gracefully
   * Implement timeouts

2. **Progress reporting**
   * Use progress tokens for long operations
   * Report progress incrementally
   * Include total progress when known

3. **Error management**
   * Use appropriate error codes
   * Include helpful error messages
   * Clean up resources on errors

## Security considerations

1. **Transport security**
   * Use TLS for remote connections
   * Validate connection origins
   * Implement authentication when needed

2. **Message validation**
   * Validate all incoming messages
   * Sanitize inputs
   * Check message size limits
   * Verify JSON-RPC format

3. **Resource protection**
   * Implement access controls
   * Validate resource paths
   * Monitor resource usage
   * Rate limit requests

4. **Error handling**
   * Don't leak sensitive information
   * Log security-relevant errors
   * Implement proper cleanup
   * Handle DoS scenarios

## Debugging and monitoring

1. **Logging**
   * Log protocol events
   * Track message flow
   * Monitor performance
   * Record errors

2. **Diagnostics**
   * Implement health checks
   * Monitor connection state
   * Track resource usage
   * Profile performance

3. **Testing**
   * Test different transports
   * Verify error handling
   * Check edge cases
   * Load test servers


# Prompts
Source: https://modelcontextprotocol.io/docs/concepts/prompts

Create reusable prompt templates and workflows

Prompts enable servers to define reusable prompt templates and workflows that clients can easily surface to users and LLMs. They provide a powerful way to standardize and share common LLM interactions.

<Note>
  Prompts are designed to be **user-controlled**, meaning they are exposed from servers to clients with the intention of the user being able to explicitly select them for use.
</Note>

## Overview

Prompts in MCP are predefined templates that can:

*   Accept dynamic arguments
*   Include context from resources
*   Chain multiple interactions
*   Guide specific workflows
*   Surface as UI elements (like slash commands)

## Prompt structure

Each prompt is defined with:

```typescript
{
  name: string;              // Unique identifier for the prompt
  description?: string;      // Human-readable description
  arguments?: [              // Optional list of arguments
    {
      name: string;          // Argument identifier
      description?: string;  // Argument description
      required?: boolean;    // Whether argument is required
    }
  ]
}
```

## Discovering prompts

Clients can discover available prompts through the `prompts/list` endpoint:

```typescript
// Request
{
  method: "prompts/list"
}

// Response
{
  prompts: [
    {
      name: "analyze-code",
      description: "Analyze code for potential improvements",
      arguments: [
        {
          name: "language",
          description: "Programming language",
          required: true
        }
      ]
    }
  ]
}
```

## Using prompts

To use a prompt, clients make a `prompts/get` request:

````typescript
// Request
{
  method: "prompts/get",
  params: {
    name: "analyze-code",
    arguments: {
      language: "python"
    }
  }
}

// Response
{
  description: "Analyze Python code for potential improvements",
  messages: [
    {
      role: "user",
      content: {
        type: "text",
        text: "Please analyze the following Python code for potential improvements:\n\n```python\ndef calculate_sum(numbers):\n    total = 0\n    for num in numbers:\n        total = total + num\n    return total\n\nresult = calculate_sum([1, 2, 3, 4, 5])\nprint(result)\n```"
      }
    }
  ]
}
````

## Dynamic prompts

Prompts can be dynamic and include:

### Embedded resource context

```json
{
  "name": "analyze-project",
  "description": "Analyze project logs and code",
  "arguments": [
    {
      "name": "timeframe",
      "description": "Time period to analyze logs",
      "required": true
    },
    {
      "name": "fileUri",
      "description": "URI of code file to review",
      "required": true
    }
  ]
}
```

When handling the `prompts/get` request:

```json
{
  "messages": [
    {
      "role": "user",
      "content": {
        "type": "text",
        "text": "Analyze these system logs and the code file for any issues:"
      }
    },
    {
      "role": "user",
      "content": {
        "type": "resource",
        "resource": {
          "uri": "logs://recent?timeframe=1h",
          "text": "[2024-03-14 15:32:11] ERROR: Connection timeout in network.py:127\n[2024-03-14 15:32:15] WARN: Retrying connection (attempt 2/3)\n[2024-03-14 15:32:20] ERROR: Max retries exceeded",
          "mimeType": "text/plain"
        }
      }
    },
    {
      "role": "user",
      "content": {
        "type": "resource",
        "resource": {
          "uri": "file:///path/to/code.py",
          "text": "def connect_to_service(timeout=30):\n    retries = 3\n    for attempt in range(retries):\n        try:\n            return establish_connection(timeout)\n        except TimeoutError:\n            if attempt == retries - 1:\n                raise\n            time.sleep(5)\n\ndef establish_connection(timeout):\n    # Connection implementation\n    pass",
          "mimeType": "text/x-python"
        }
      }
    }
  ]
}
```

### Multi-step workflows

```typescript
const debugWorkflow = {
  name: "debug-error",
  async getMessages(error: string) {
    return [
      {
        role: "user",
        content: {
          type: "text",
          text: `Here's an error I'm seeing: ${error}`
        }
      },
      {
        role: "assistant",
        content: {
          type: "text",
          text: "I'll help analyze this error. What have you tried so far?"
        }
      },
      {
        role: "user",
        content: {
          type: "text",
          text: "I've tried restarting the service, but the error persists."
        }
      }
    ];
  }
};
```

## Example implementation

Here's a complete example of implementing prompts in an MCP server:

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    import { Server } from "@modelcontextprotocol/sdk/server";
    import {
      ListPromptsRequestSchema,
      GetPromptRequestSchema
    } from "@modelcontextprotocol/sdk/types";

    const PROMPTS = {
      "git-commit": {
        name: "git-commit",
        description: "Generate a Git commit message",
        arguments: [
          {
            name: "changes",
            description: "Git diff or description of changes",
            required: true
          }
        ]
      },
      "explain-code": {
        name: "explain-code",
        description: "Explain how code works",
        arguments: [
          {
            name: "code",
            description: "Code to explain",
            required: true
          },
          {
            name: "language",
            description: "Programming language",
            required: false
          }
        ]
      }
    };

    const server = new Server({
      name: "example-prompts-server",
      version: "1.0.0"
    }, {
      capabilities: {
        prompts: {}
      }
    });

    // List available prompts
    server.setRequestHandler(ListPromptsRequestSchema, async () => {
      return {
        prompts: Object.values(PROMPTS)
      };
    });

    // Get specific prompt
    server.setRequestHandler(GetPromptRequestSchema, async (request) => {
      const prompt = PROMPTS[request.params.name];
      if (!prompt) {
        throw new Error(`Prompt not found: ${request.params.name}`);
      }

      if (request.params.name === "git-commit") {
        return {
          messages: [
            {
              role: "user",
              content: {
                type: "text",
                text: `Generate a concise but descriptive commit message for these changes:\n\n${request.params.arguments?.changes}`
              }
            }
          ]
        };
      }

      if (request.params.name === "explain-code") {
        const language = request.params.arguments?.language || "Unknown";
        return {
          messages: [
            {
              role: "user",
              content: {
                type: "text",
                text: `Explain how this ${language} code works:\n\n${request.params.arguments?.code}`
              }
            }
          ]
        };
      }

      throw new Error("Prompt implementation not found");
    });
    ```
  </Tab>

  <Tab title="Python">
    ```python
    from mcp.server import Server
    import mcp.types as types

    # Define available prompts
    PROMPTS = {
        "git-commit": types.Prompt(
            name="git-commit",
            description="Generate a Git commit message",
            arguments=[
                types.PromptArgument(
                    name="changes",
                    description="Git diff or description of changes",
                    required=True
                )
            ],
        ),
        "explain-code": types.Prompt(
            name="explain-code",
            description="Explain how code works",
            arguments=[
                types.PromptArgument(
                    name="code",
                    description="Code to explain",
                    required=True
                ),
                types.PromptArgument(
                    name="language",
                    description="Programming language",
                    required=False
                )
            ],
        )
    }

    # Initialize server
    app = Server("example-prompts-server")

    @app.list_prompts()
    async def list_prompts() -> list[types.Prompt]:
        return list(PROMPTS.values())

    @app.get_prompt()
    async def get_prompt(
        name: str, arguments: dict[str, str] | None = None
    ) -> types.GetPromptResult:
        if name not in PROMPTS:
            raise ValueError(f"Prompt not found: {name}")

        if name == "git-commit":
            changes = arguments.get("changes") if arguments else ""
            return types.GetPromptResult(
                messages=[
                    types.PromptMessage(
                        role="user",
                        content=types.TextContent(
                            type="text",
                            text=f"Generate a concise but descriptive commit message "
                            f"for these changes:\n\n{changes}"
                        )
                    )
                ]
            )

        if name == "explain-code":
            code = arguments.get("code") if arguments else ""
            language = arguments.get("language", "Unknown") if arguments else "Unknown"
            return types.GetPromptResult(
                messages=[
                    types.PromptMessage(
                        role="user",
                        content=types.TextContent(
                            type="text",
                            text=f"Explain how this {language} code works:\n\n{code}"
                        )
                    )
                ]
            )

        raise ValueError("Prompt implementation not found")
    ```
  </Tab>
</Tabs>

## Best practices

When implementing prompts:

1.  Use clear, descriptive prompt names
2.  Provide detailed descriptions for prompts and arguments
3.  Validate all required arguments
4.  Handle missing arguments gracefully
5.  Consider versioning for prompt templates
6.  Cache dynamic content when appropriate
7.  Implement error handling
8.  Document expected argument formats
9.  Consider prompt composability
10. Test prompts with various inputs

## UI integration

Prompts can be surfaced in client UIs as:

*   Slash commands
*   Quick actions
*   Context menu items
*   Command palette entries
*   Guided workflows
*   Interactive forms

## Updates and changes

Servers can notify clients about prompt changes:

1.  Server capability: `prompts.listChanged`
2.  Notification: `notifications/prompts/list_changed`
3.  Client re-fetches prompt list

## Security considerations

When implementing prompts:

*   Validate all arguments
*   Sanitize user input
*   Consider rate limiting
*   Implement access controls
*   Audit prompt usage
*   Handle sensitive data appropriately
*   Validate generated content
*   Implement timeouts
*   Consider prompt injection risks
*   Document security requirements


# Resources
Source: https://modelcontextprotocol.io/docs/concepts/resources

Expose data and content from your servers to LLMs

Resources are a core primitive in the Model Context Protocol (MCP) that allow servers to expose data and content that can be read by clients and used as context for LLM interactions.

<Note>
  Resources are designed to be **application-controlled**, meaning that the client application can decide how and when they should be used.
  Different MCP clients may handle resources differently. For example:

  *   Claude Desktop currently requires users to explicitly select resources before they can be used
  *   Other clients might automatically select resources based on heuristics
  *   Some implementations may even allow the AI model itself to determine which resources to use

  Server authors should be prepared to handle any of these interaction patterns when implementing resource support. In order to expose data to models automatically, server authors should use a **model-controlled** primitive such as [Tools](./tools).
</Note>

## Overview

Resources represent any kind of data that an MCP server wants to make available to clients. This can include:

*   File contents
*   Database records
*   API responses
*   Live system data
*   Screenshots and images
*   Log files
*   And more

Each resource is identified by a unique URI and can contain either text or binary data.

## Resource URIs

Resources are identified using URIs that follow this format:

```
[protocol]://[host]/[path]
```

For example:

*   `file:///home/user/documents/report.pdf`
*   `postgres://database/customers/schema`
*   `screen://localhost/display1`

The protocol and path structure is defined by the MCP server implementation. Servers can define their own custom URI schemes.

## Resource types

Resources can contain two types of content:

### Text resources

Text resources contain UTF-8 encoded text data. These are suitable for:

*   Source code
*   Configuration files
*   Log files
*   JSON/XML data
*   Plain text

### Binary resources

Binary resources contain raw binary data encoded in base64. These are suitable for:

*   Images
*   PDFs
*   Audio files
*   Video files
*   Other non-text formats

## Resource discovery

Clients can discover available resources through two main methods:

### Direct resources

Servers expose a list of concrete resources via the `resources/list` endpoint. Each resource includes:

```typescript
{
  uri: string;           // Unique identifier for the resource
  name: string;          // Human-readable name
  description?: string;  // Optional description
  mimeType?: string;     // Optional MIME type
}
```

### Resource templates

For dynamic resources, servers can expose [URI templates](https://datatracker.ietf.org/doc/html/rfc6570) that clients can use to construct valid resource URIs:

```typescript
{
  uriTemplate: string;   // URI template following RFC 6570
  name: string;          // Human-readable name for this type
  description?: string;  // Optional description
  mimeType?: string;     // Optional MIME type for all matching resources
}
```

## Reading resources

To read a resource, clients make a `resources/read` request with the resource URI.

The server responds with a list of resource contents:

```typescript
{
  contents: [
    {
      uri: string;        // The URI of the resource
      mimeType?: string;  // Optional MIME type

      // One of:
      text?: string;      // For text resources
      blob?: string;      // For binary resources (base64 encoded)
    }
  ]
}
```

<Tip>
  Servers may return multiple resources in response to one `resources/read` request. This could be used, for example, to return a list of files inside a directory when the directory is read.
</Tip>

## Resource updates

MCP supports real-time updates for resources through two mechanisms:

### List changes

Servers can notify clients when their list of available resources changes via the `notifications/resources/list_changed` notification.

### Content changes

Clients can subscribe to updates for specific resources:

1.  Client sends `resources/subscribe` with resource URI
2.  Server sends `notifications/resources/updated` when the resource changes
3.  Client can fetch latest content with `resources/read`
4.  Client can unsubscribe with `resources/unsubscribe`

## Example implementation

Here's a simple example of implementing resource support in an MCP server:

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    const server = new Server({
      name: "example-server",
      version: "1.0.0"
    }, {
      capabilities: {
        resources: {}
      }
    });

    // List available resources
    server.setRequestHandler(ListResourcesRequestSchema, async () => {
      return {
        resources: [
          {
            uri: "file:///logs/app.log",
            name: "Application Logs",
            mimeType: "text/plain"
          }
        ]
      };
    });

    // Read resource contents
    server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
      const uri = request.params.uri;

      if (uri === "file:///logs/app.log") {
        const logContents = await readLogFile();
        return {
          contents: [
            {
              uri,
              mimeType: "text/plain",
              text: logContents
            }
          ]
        };
      }

      throw new Error("Resource not found");
    });
    ```
  </Tab>

  <Tab title="Python">
    ```python
    app = Server("example-server")

    @app.list_resources()
    async def list_resources() -> list[types.Resource]:
        return [
            types.Resource(
                uri="file:///logs/app.log",
                name="Application Logs",
                mimeType="text/plain"
            )
        ]

    @app.read_resource()
    async def read_resource(uri: AnyUrl) -> str:
        if str(uri) == "file:///logs/app.log":
            log_contents = await read_log_file()
            return log_contents

        raise ValueError("Resource not found")

    # Start server
    async with stdio_server() as streams:
        await app.run(
            streams[0],
            streams[1],
            app.create_initialization_options()
        )
    ```
  </Tab>
</Tabs>

## Best practices

When implementing resource support:

1.  Use clear, descriptive resource names and URIs
2.  Include helpful descriptions to guide LLM understanding
3.  Set appropriate MIME types when known
4.  Implement resource templates for dynamic content
5.  Use subscriptions for frequently changing resources
6.  Handle errors gracefully with clear error messages
7.  Consider pagination for large resource lists
8.  Cache resource contents when appropriate
9.  Validate URIs before processing
10. Document your custom URI schemes

## Security considerations

When exposing resources:

*   Validate all resource URIs
*   Implement appropriate access controls
*   Sanitize file paths to prevent directory traversal
*   Be cautious with binary data handling
*   Consider rate limiting for resource reads
*   Audit resource access
*   Encrypt sensitive data in transit
*   Validate MIME types
*   Implement timeouts for long-running reads
*   Handle resource cleanup appropriately


# Roots
Source: https://modelcontextprotocol.io/docs/concepts/roots

Understanding roots in MCP

Roots are a concept in MCP that define the boundaries where servers can operate. They provide a way for clients to inform servers about relevant resources and their locations.

## What are Roots?

A root is a URI that a client suggests a server should focus on. When a client connects to a server, it declares which roots the server should work with. While primarily used for filesystem paths, roots can be any valid URI including HTTP URLs.

For example, roots could be:

```
file:///home/user/projects/myapp
https://api.example.com/v1
```

## Why Use Roots?

Roots serve several important purposes:

1.  **Guidance**: They inform servers about relevant resources and locations
2.  **Clarity**: Roots make it clear which resources are part of your workspace
3.  **Organization**: Multiple roots let you work with different resources simultaneously

## How Roots Work

When a client supports roots, it:

1.  Declares the `roots` capability during connection
2.  Provides a list of suggested roots to the server
3.  Notifies the server when roots change (if supported)

While roots are informational and not strictly enforcing, servers should:

1.  Respect the provided roots
2.  Use root URIs to locate and access resources
3.  Prioritize operations within root boundaries

## Common Use Cases

Roots are commonly used to define:

*   Project directories
*   Repository locations
*   API endpoints
*   Configuration locations
*   Resource boundaries

## Best Practices

When working with roots:

1.  Only suggest necessary resources
2.  Use clear, descriptive names for roots
3.  Monitor root accessibility
4.  Handle root changes gracefully

## Example

Here's how a typical MCP client might expose roots:

```json
{
  "roots": [
    {
      "uri": "file:///home/user/projects/frontend",
      "name": "Frontend Repository"
    },
    {
      "uri": "https://api.example.com/v1",
      "name": "API Endpoint"
    }
  ]
}
```

This configuration suggests the server focus on both a local repository and an API endpoint while keeping them logically separated.


# Sampling
Source: https://modelcontextprotocol.io/docs/concepts/sampling

Let your servers request completions from LLMs

Sampling is a powerful MCP feature that allows servers to request LLM completions through the client, enabling sophisticated agentic behaviors while maintaining security and privacy.

<Info>
  This feature of MCP is not yet supported in the Claude Desktop client.
</Info>

## How sampling works

The sampling flow follows these steps:

1.  Server sends a `sampling/createMessage` request to the client
2.  Client reviews the request and can modify it
3.  Client samples from an LLM
4.  Client reviews the completion
5.  Client returns the result to the server

This human-in-the-loop design ensures users maintain control over what the LLM sees and generates.

## Message format

Sampling requests use a standardized message format:

```typescript
{
  messages: [
    {
      role: "user" | "assistant",
      content: {
        type: "text" | "image",

        // For text:
        text?: string,

        // For images:
        data?: string,             // base64 encoded
        mimeType?: string
      }
    }
  ],
  modelPreferences?: {
    hints?: [{
      name?: string                // Suggested model name/family
    }],
    costPriority?: number,         // 0-1, importance of minimizing cost
    speedPriority?: number,        // 0-1, importance of low latency
    intelligencePriority?: number  // 0-1, importance of capabilities
  },
  systemPrompt?: string,
  includeContext?: "none" | "thisServer" | "allServers",
  temperature?: number,
  maxTokens: number,
  stopSequences?: string[],
  metadata?: Record<string, unknown>
}
```

## Request parameters

### Messages

The `messages` array contains the conversation history to send to the LLM. Each message has:

*   `role`: Either "user" or "assistant"
*   `content`: The message content, which can be:
    *   Text content with a `text` field
    *   Image content with `data` (base64) and `mimeType` fields

### Model preferences

The `modelPreferences` object allows servers to specify their model selection preferences:

*   `hints`: Array of model name suggestions that clients can use to select an appropriate model:
    *   `name`: String that can match full or partial model names (e.g. "claude-3", "sonnet")
    *   Clients may map hints to equivalent models from different providers
    *   Multiple hints are evaluated in preference order

*   Priority values (0-1 normalized):
    *   `costPriority`: Importance of minimizing costs
    *   `speedPriority`: Importance of low latency response
    *   `intelligencePriority`: Importance of advanced model capabilities

Clients make the final model selection based on these preferences and their available models.

### System prompt

An optional `systemPrompt` field allows servers to request a specific system prompt. The client may modify or ignore this.

### Context inclusion

The `includeContext` parameter specifies what MCP context to include:

*   `"none"`: No additional context
*   `"thisServer"`: Include context from the requesting server
*   `"allServers"`: Include context from all connected MCP servers

The client controls what context is actually included.

### Sampling parameters

Fine-tune the LLM sampling with:

*   `temperature`: Controls randomness (0.0 to 1.0)
*   `maxTokens`: Maximum tokens to generate
*   `stopSequences`: Array of sequences that stop generation
*   `metadata`: Additional provider-specific parameters

## Response format

The client returns a completion result:

```typescript
{
  model: string,  // Name of the model used
  stopReason?: "endTurn" | "stopSequence" | "maxTokens" | string,
  role: "user" | "assistant",
  content: {
    type: "text" | "image",
    text?: string,
    data?: string,
    mimeType?: string
  }
}
```

## Example request

Here's an example of requesting sampling from a client:

```json
{
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "What files are in the current directory?"
        }
      }
    ],
    "systemPrompt": "You are a helpful file system assistant.",
    "includeContext": "thisServer",
    "maxTokens": 100
  }
}
```

## Best practices

When implementing sampling:

1.  Always provide clear, well-structured prompts
2.  Handle both text and image content appropriately
3.  Set reasonable token limits
4.  Include relevant context through `includeContext`
5.  Validate responses before using them
6.  Handle errors gracefully
7.  Consider rate limiting sampling requests
8.  Document expected sampling behavior
9.  Test with various model parameters
10. Monitor sampling costs

## Human in the loop controls

Sampling is designed with human oversight in mind:

### For prompts

*   Clients should show users the proposed prompt
*   Users should be able to modify or reject prompts
*   System prompts can be filtered or modified
*   Context inclusion is controlled by the client

### For completions

*   Clients should show users the completion
*   Users should be able to modify or reject completions
*   Clients can filter or modify completions
*   Users control which model is used

## Security considerations

When implementing sampling:

*   Validate all message content
*   Sanitize sensitive information
*   Implement appropriate rate limits
*   Monitor sampling usage
*   Encrypt data in transit
*   Handle user data privacy
*   Audit sampling requests
*   Control cost exposure
*   Implement timeouts
*   Handle model errors gracefully

## Common patterns

### Agentic workflows

Sampling enables agentic patterns like:

*   Reading and analyzing resources
*   Making decisions based on context
*   Generating structured data
*   Handling multi-step tasks
*   Providing interactive assistance

### Context management

Best practices for context:

*   Request minimal necessary context
*   Structure context clearly
*   Handle context size limits
*   Update context as needed
*   Clean up stale context

### Error handling

Robust error handling should:

*   Catch sampling failures
*   Handle timeout errors
*   Manage rate limits
*   Validate responses
*   Provide fallback behaviors
*   Log errors appropriately

## Limitations

Be aware of these limitations:

*   Sampling depends on client capabilities
*   Users control sampling behavior
*   Context size has limits
*   Rate limits may apply
*   Costs should be considered
*   Model availability varies
*   Response times vary
*   Not all content types supported


# Tools
Source: https://modelcontextprotocol.io/docs/concepts/tools

Enable LLMs to perform actions through your server

Tools are a powerful primitive in the Model Context Protocol (MCP) that enable servers to expose executable functionality to clients. Through tools, LLMs can interact with external systems, perform computations, and take actions in the real world.

<Note>
  Tools are designed to be **model-controlled**, meaning that tools are exposed from servers to clients with the intention of the AI model being able to automatically invoke them (with a human in the loop to grant approval).
</Note>

## Overview

Tools in MCP allow servers to expose executable functions that can be invoked by clients and used by LLMs to perform actions. Key aspects of tools include:

*   **Discovery**: Clients can list available tools through the `tools/list` endpoint
*   **Invocation**: Tools are called using the `tools/call` endpoint, where servers perform the requested operation and return results
*   **Flexibility**: Tools can range from simple calculations to complex API interactions

Like [resources](/docs/concepts/resources), tools are identified by unique names and can include descriptions to guide their usage. However, unlike resources, tools represent dynamic operations that can modify state or interact with external systems.

## Tool definition structure

Each tool is defined with the following structure:

```typescript
{
  name: string;          // Unique identifier for the tool
  description?: string;  // Human-readable description
  inputSchema: {         // JSON Schema for the tool's parameters
    type: "object",
    properties: { ... }  // Tool-specific parameters
  }
}
```

## Implementing tools

Here's an example of implementing a basic tool in an MCP server:

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    const server = new Server({
      name: "example-server",
      version: "1.0.0"
    }, {
      capabilities: {
        tools: {}
      }
    });

    // Define available tools
    server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [{
          name: "calculate_sum",
          description: "Add two numbers together",
          inputSchema: {
            type: "object",
            properties: {
              a: { type: "number" },
              b: { type: "number" }
            },
            required: ["a", "b"]
          }
        }]
      };
    });

    // Handle tool execution
    server.setRequestHandler(CallToolRequestSchema, async (request) => {
      if (request.params.name === "calculate_sum") {
        const { a, b } = request.params.arguments;
        return {
          content: [
            {
              type: "text",
              text: String(a + b)
            }
          ]
        };
      }
      throw new Error("Tool not found");
    });
    ```
  </Tab>

  <Tab title="Python">
    ```python
    app = Server("example-server")

    @app.list_tools()
    async def list_tools() -> list[types.Tool]:
        return [
            types.Tool(
                name="calculate_sum",
                description="Add two numbers together",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "a": {"type": "number"},
                        "b": {"type": "number"}
                    },
                    "required": ["a", "b"]
                }
            )
        ]

    @app.call_tool()
    async def call_tool(
        name: str,
        arguments: dict
    ) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
        if name == "calculate_sum":
            a = arguments["a"]
            b = arguments["b"]
            result = a + b
            return [types.TextContent(type="text", text=str(result))]
        raise ValueError(f"Tool not found: {name}")
    ```
  </Tab>
</Tabs>

## Example tool patterns

Here are some examples of types of tools that a server could provide:

### System operations

Tools that interact with the local system:

```typescript
{
  name: "execute_command",
  description: "Run a shell command",
  inputSchema: {
    type: "object",
    properties: {
      command: { type: "string" },
      args: { type: "array", items: { type: "string" } }
    }
  }
}
```

### API integrations

Tools that wrap external APIs:

```typescript
{
  name: "github_create_issue",
  description: "Create a GitHub issue",
  inputSchema: {
    type: "object",
    properties: {
      title: { type: "string" },
      body: { type: "string" },
      labels: { type: "array", items: { type: "string" } }
    }
  }
}
```

### Data processing

Tools that transform or analyze data:

```typescript
{
  name: "analyze_csv",
  description: "Analyze a CSV file",
  inputSchema: {
    type: "object",
    properties: {
      filepath: { type: "string" },
      operations: {
        type: "array",
        items: {
          enum: ["sum", "average", "count"]
        }
      }
    }
  }
}
```

## Best practices

When implementing tools:

1.  Provide clear, descriptive names and descriptions
2.  Use detailed JSON Schema definitions for parameters
3.  Include examples in tool descriptions to demonstrate how the model should use them
4.  Implement proper error handling and validation
5.  Use progress reporting for long operations
6.  Keep tool operations focused and atomic
7.  Document expected return value structures
8.  Implement proper timeouts
9.  Consider rate limiting for resource-intensive operations
10. Log tool usage for debugging and monitoring

## Security considerations

When exposing tools:

### Input validation

*   Validate all parameters against the schema
*   Sanitize file paths and system commands
*   Validate URLs and external identifiers
*   Check parameter sizes and ranges
*   Prevent command injection

### Access control

*   Implement authentication where needed
*   Use appropriate authorization checks
*   Audit tool usage
*   Rate limit requests
*   Monitor for abuse

### Error handling

*   Don't expose internal errors to clients
*   Log security-relevant errors
*   Handle timeouts appropriately
*   Clean up resources after errors
*   Validate return values

## Tool discovery and updates

MCP supports dynamic tool discovery:

1.  Clients can list available tools at any time
2.  Servers can notify clients when tools change using `notifications/tools/list_changed`
3.  Tools can be added or removed during runtime
4.  Tool definitions can be updated (though this should be done carefully)

## Error handling

Tool errors should be reported within the result object, not as MCP protocol-level errors. This allows the LLM to see and potentially handle the error. When a tool encounters an error:

1.  Set `isError` to `true` in the result
2.  Include error details in the `content` array

Here's an example of proper error handling for tools:

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    try {
      // Tool operation
      const result = performOperation();
      return {
        content: [
          {
            type: "text",
            text: `Operation successful: ${result}`
          }
        ]
      };
    } catch (error) {
      return {
        isError: true,
        content: [
          {
            type: "text",
            text: `Error: ${error.message}`
          }
        ]
      };
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python
    try:
        # Tool operation
        result = perform_operation()
        return types.CallToolResult(
            content=[
                types.TextContent(
                    type="text",
                    text=f"Operation successful: {result}"
                )
            ]
        )
    except Exception as error:
        return types.CallToolResult(
            isError=True,
            content=[
                types.TextContent(
                    type="text",
                    text=f"Error: {str(error)}"
                )
            ]
        )
    ```
  </Tab>
</Tabs>

This approach allows the LLM to see that an error occurred and potentially take corrective action or request human intervention.

## Testing tools

A comprehensive testing strategy for MCP tools should cover:

*   **Functional testing**: Verify tools execute correctly with valid inputs and handle invalid inputs appropriately
*   **Integration testing**: Test tool interaction with external systems using both real and mocked dependencies
*   **Security testing**: Validate authentication, authorization, input sanitization, and rate limiting
*   **Performance testing**: Check behavior under load, timeout handling, and resource cleanup
*   **Error handling**: Ensure tools properly report errors through the MCP protocol and clean up resources


# Transports
Source: https://modelcontextprotocol.io/docs/concepts/transports

Learn about MCP's communication mechanisms

Transports in the Model Context Protocol (MCP) provide the foundation for communication between clients and servers. A transport handles the underlying mechanics of how messages are sent and received.

## Message Format

MCP uses [JSON-RPC](https://www.jsonrpc.org/) 2.0 as its wire format. The transport layer is responsible for converting MCP protocol messages into JSON-RPC format for transmission and converting received JSON-RPC messages back into MCP protocol messages.

There are three types of JSON-RPC messages used:

### Requests

```typescript
{
  jsonrpc: "2.0",
  id: number | string,
  method: string,
  params?: object
}
```

### Responses

```typescript
{
  jsonrpc: "2.0",
  id: number | string,
  result?: object,
  error?: {
    code: number,
    message: string,
    data?: unknown
  }
}
```

### Notifications

```typescript
{
  jsonrpc: "2.0",
  method: string,
  params?: object
}
```

## Built-in Transport Types

MCP includes two standard transport implementations:

### Standard Input/Output (stdio)

The stdio transport enables communication through standard input and output streams. This is particularly useful for local integrations and command-line tools.

Use stdio when:

*   Building command-line tools
*   Implementing local integrations
*   Needing simple process communication
*   Working with shell scripts

<Tabs>
  <Tab title="TypeScript (Server)">
    ```typescript
    const server = new Server({
      name: "example-server",
      version: "1.0.0"
    }, {
      capabilities: {}
    });

    const transport = new StdioServerTransport();
    await server.connect(transport);
    ```
  </Tab>

  <Tab title="TypeScript (Client)">
    ```typescript
    const client = new Client({
      name: "example-client",
      version: "1.0.0"
    }, {
      capabilities: {}
    });

    const transport = new StdioClientTransport({
      command: "./server",
      args: ["--option", "value"]
    });
    await client.connect(transport);
    ```
  </Tab>

  <Tab title="Python (Server)">
    ```python
    app = Server("example-server")

    async with stdio_server() as streams:
        await app.run(
            streams[0],
            streams[1],
            app.create_initialization_options()
        )
    ```
  </Tab>

  <Tab title="Python (Client)">
    ```python
    params = StdioServerParameters(
        command="./server",
        args=["--option", "value"]
    )

    async with stdio_client(params) as streams:
        async with ClientSession(streams[0], streams[1]) as session:
            await session.initialize()
    ```
  </Tab>
</Tabs>

### Server-Sent Events (SSE)

SSE transport enables server-to-client streaming with HTTP POST requests for client-to-server communication.

Use SSE when:

*   Only server-to-client streaming is needed
*   Working with restricted networks
*   Implementing simple updates

<Tabs>
  <Tab title="TypeScript (Server)">
    ```typescript
    import express from "express";

    const app = express();

    const server = new Server({
      name: "example-server",
      version: "1.0.0"
    }, {
      capabilities: {}
    });

    let transport: SSEServerTransport | null = null;

    app.get("/sse", (req, res) => {
      transport = new SSEServerTransport("/messages", res);
      server.connect(transport);
    });

    app.post("/messages", (req, res) => {
      if (transport) {
        transport.handlePostMessage(req, res);
      }
    });

    app.listen(3000);
    ```
  </Tab>

  <Tab title="TypeScript (Client)">
    ```typescript
    const client = new Client({
      name: "example-client",
      version: "1.0.0"
    }, {
      capabilities: {}
    });

    const transport = new SSEClientTransport(
      new URL("http://localhost:3000/sse")
    );
    await client.connect(transport);
    ```
  </Tab>

  <Tab title="Python (Server)">
    ```python
    from mcp.server.sse import SseServerTransport
    from starlette.applications import Starlette
    from starlette.routing import Route

    app = Server("example-server")
    sse = SseServerTransport("/messages")

    async def handle_sse(scope, receive, send):
        async with sse.connect_sse(scope, receive, send) as streams:
            await app.run(streams[0], streams[1], app.create_initialization_options())

    async def handle_messages(scope, receive, send):
        await sse.handle_post_message(scope, receive, send)

    starlette_app = Starlette(
        routes=[
            Route("/sse", endpoint=handle_sse),
            Route("/messages", endpoint=handle_messages, methods=["POST"]),
        ]
    )
    ```
  </Tab>

  <Tab title="Python (Client)">
    ```python
    async with sse_client("http://localhost:8000/sse") as streams:
        async with ClientSession(streams[0], streams[1]) as session:
            await session.initialize()
    ```
  </Tab>
</Tabs>

## Custom Transports

MCP makes it easy to implement custom transports for specific needs. Any transport implementation just needs to conform to the Transport interface:

You can implement custom transports for:

*   Custom network protocols
*   Specialized communication channels
*   Integration with existing systems
*   Performance optimization

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    interface Transport {
      // Start processing messages
      start(): Promise<void>;

      // Send a JSON-RPC message
      send(message: JSONRPCMessage): Promise<void>;

      // Close the connection
      close(): Promise<void>;

      // Callbacks
      onclose?: () => void;
      onerror?: (error: Error) => void;
      onmessage?: (message: JSONRPCMessage) => void;
    }
    ```
  </Tab>

  <Tab title="Python">
    Note that while MCP Servers are often implemented with asyncio, we recommend
    implementing low-level interfaces like transports with `anyio` for wider compatibility.

    ```python
    @contextmanager
    async def create_transport(
        read_stream: MemoryObjectReceiveStream[JSONRPCMessage | Exception],
        write_stream: MemoryObjectSendStream[JSONRPCMessage]
    ):
        """
        Transport interface for MCP.

        Args:
            read_stream: Stream to read incoming messages from
            write_stream: Stream to write outgoing messages to
        """
        async with anyio.create_task_group() as tg:
            try:
                # Start processing messages
                tg.start_soon(lambda: process_messages(read_stream))

                # Send messages
                async with write_stream:
                    yield write_stream

            except Exception as exc:
                # Handle errors
                raise exc
            finally:
                # Clean up
                tg.cancel_scope.cancel()
                await write_stream.aclose()
                await read_stream.aclose()
    ```
  </Tab>
</Tabs>

## Error Handling

Transport implementations should handle various error scenarios:

1.  Connection errors
2.  Message parsing errors
3.  Protocol errors
4.  Network timeouts
5.  Resource cleanup

Example error handling:

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    class ExampleTransport implements Transport {
      async start() {
        try {
          // Connection logic
        } catch (error) {
          this.onerror?.(new Error(`Failed to connect: ${error}`));
          throw error;
        }
      }

      async send(message: JSONRPCMessage) {
        try {
          // Sending logic
        } catch (error) {
          this.onerror?.(new Error(`Failed to send message: ${error}`));
          throw error;
        }
      }
    }
    ```
  </Tab>

  <Tab title="Python">
    Note that while MCP Servers are often implemented with asyncio, we recommend
    implementing low-level interfaces like transports with `anyio` for wider compatibility.

    ```python
    @contextmanager
    async def example_transport(scope: Scope, receive: Receive, send: Send):
        try:
            # Create streams for bidirectional communication
            read_stream_writer, read_stream = anyio.create_memory_object_stream(0)
            write_stream, write_stream_reader = anyio.create_memory_object_stream(0)

            async def message_handler():
                try:
                    async with read_stream_writer:
                        # Message handling logic
                        pass
                except Exception as exc:
                    logger.error(f"Failed to handle message: {exc}")
                    raise exc

            async with anyio.create_task_group() as tg:
                tg.start_soon(message_handler)
                try:
                    # Yield streams for communication
                    yield read_stream, write_stream
                except Exception as exc:
                    logger.error(f"Transport error: {exc}")
                    raise exc
                finally:
                    tg.cancel_scope.cancel()
                    await write_stream.aclose()
                    await read_stream.aclose()
        except Exception as exc:
            logger.error(f"Failed to initialize transport: {exc}")
            raise exc
    ```
  </Tab>
</Tabs>

## Best Practices

When implementing or using MCP transport:

1.  Handle connection lifecycle properly
2.  Implement proper error handling
3.  Clean up resources on connection close
4.  Use appropriate timeouts
5.  Validate messages before sending
6.  Log transport events for debugging
7.  Implement reconnection logic when appropriate
8.  Handle backpressure in message queues
9.  Monitor connection health
10. Implement proper security measures

## Security Considerations

When implementing transport:

### Authentication and Authorization

*   Implement proper authentication mechanisms
*   Validate client credentials
*   Use secure token handling
*   Implement authorization checks

### Data Security

*   Use TLS for network transport
*   Encrypt sensitive data
*   Validate message integrity
*   Implement message size limits
*   Sanitize input data

### Network Security

*   Implement rate limiting
*   Use appropriate timeouts
*   Handle denial of service scenarios
*   Monitor for unusual patterns
*   Implement proper firewall rules

## Debugging Transport

Tips for debugging transport issues:

1.  Enable debug logging
2.  Monitor message flow
3.  Check connection states
4.  Validate message formats
5.  Test error scenarios
6.  Use network analysis tools
7.  Implement health checks
8.  Monitor resource usage
9.  Test edge cases
10. Use proper error tracking


# Debugging
Source: https://modelcontextprotocol.io/docs/tools/debugging

A comprehensive guide to debugging Model Context Protocol (MCP) integrations

Effective debugging is essential when developing MCP servers or integrating them with applications. This guide covers the debugging tools and approaches available in the MCP ecosystem.

<Info>
  This guide is for macOS. Guides for other platforms are coming soon.
</Info>

## Debugging tools overview

MCP provides several tools for debugging at different levels:

1.  **MCP Inspector**
    *   Interactive debugging interface
    *   Direct server testing
    *   See the [Inspector guide](/docs/tools/inspector) for details

2.  **Claude Desktop Developer Tools**
    *   Integration testing
    *   Log collection
    *   Chrome DevTools integration

3.  **Server Logging**
    *   Custom logging implementations
    *   Error tracking
    *   Performance monitoring

## Debugging in Claude Desktop

### Checking server status

The Claude.app interface provides basic server status information:

1.  Click the <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/claude-desktop-mcp-plug-icon.svg" style={{display: 'inline', margin: 0, height: '1.3em'}} /> icon to view:
    *   Connected servers
    *   Available prompts and resources

2.  Click the <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/claude-desktop-mcp-hammer-icon.svg" style={{display: 'inline', margin: 0, height: '1.3em'}} /> icon to view:
    *   Tools made available to the model

### Viewing logs

Review detailed MCP logs from Claude Desktop:

```bash
# Follow logs in real-time
tail -n 20 -F ~/Library/Logs/Claude/mcp*.log
```

The logs capture:

*   Server connection events
*   Configuration issues
*   Runtime errors
*   Message exchanges

### Using Chrome DevTools

Access Chrome's developer tools inside Claude Desktop to investigate client-side errors:

1.  Create a `developer_settings.json` file with `allowDevTools` set to true:

```bash
echo '{"allowDevTools": true}' > ~/Library/Application\ Support/Claude/developer_settings.json
```

2.  Open DevTools: `Command-Option-Shift-i`

Note: You'll see two DevTools windows:

*   Main content window
*   App title bar window

Use the Console panel to inspect client-side errors.

Use the Network panel to inspect:

*   Message payloads
*   Connection timing

## Common issues

### Working directory

When using MCP servers with Claude Desktop:

*   The working directory for servers launched via `claude_desktop_config.json` may be undefined (like `/` on macOS) since Claude Desktop could be started from anywhere
*   Always use absolute paths in your configuration and `.env` files to ensure reliable operation
*   For testing servers directly via command line, the working directory will be where you run the command

For example in `claude_desktop_config.json`, use:

```json
{
  "command": "npx",
  "args": ["-y", "@modelcontextprotocol/server-filesystem", "/Users/username/data"]
}
```

Instead of relative paths like `./data`

### Environment variables

MCP servers inherit only a subset of environment variables automatically, like `USER`, `HOME`, and `PATH`.

To override the default variables or provide your own, you can specify an `env` key in `claude_desktop_config.json`:

```json
{
  "myserver": {
    "command": "mcp-server-myapp",
    "env": {
      "MYAPP_API_KEY": "some_key",
    }
  }
}
```

### Server initialization

Common initialization problems:

1.  **Path Issues**
    *   Incorrect server executable path
    *   Missing required files
    *   Permission problems
    *   Try using an absolute path for `command`

2.  **Configuration Errors**
    *   Invalid JSON syntax
    *   Missing required fields
    *   Type mismatches

3.  **Environment Problems**
    *   Missing environment variables
    *   Incorrect variable values
    *   Permission restrictions

### Connection problems

When servers fail to connect:

1.  Check Claude Desktop logs
2.  Verify server process is running
3.  Test standalone with [Inspector](/docs/tools/inspector)
4.  Verify protocol compatibility

## Implementing logging

### Server-side logging

When building a server that uses the local stdio [transport](/docs/concepts/transports), all messages logged to stderr (standard error) will be captured by the host application (e.g., Claude Desktop) automatically.

<Warning>
  Local MCP servers should not log messages to stdout (standard out), as this will interfere with protocol operation.
</Warning>

For all [transports](/docs/concepts/transports), you can also provide logging to the client by sending a log message notification:

<Tabs>
  <Tab title="Python">
    ```python
    server.request_context.session.send_log_message(
      level="info",
      data="Server started successfully",
    )
    ```
  </Tab>

  <Tab title="TypeScript">
    ```typescript
    server.sendLoggingMessage({
      level: "info",
      data: "Server started successfully",
    });
    ```
  </Tab>
</Tabs>

Important events to log:

*   Initialization steps
*   Resource access
*   Tool execution
*   Error conditions
*   Performance metrics

### Client-side logging

In client applications:

1.  Enable debug logging
2.  Monitor network traffic
3.  Track message exchanges
4.  Record error states

## Debugging workflow

### Development cycle

1.  Initial Development
    *   Use [Inspector](/docs/tools/inspector) for basic testing
    *   Implement core functionality
    *   Add logging points

2.  Integration Testing
    *   Test in Claude Desktop
    *   Monitor logs
    *   Check error handling

### Testing changes

To test changes efficiently:

*   **Configuration changes**: Restart Claude Desktop
*   **Server code changes**: Use Command-R to reload
*   **Quick iteration**: Use [Inspector](/docs/tools/inspector) during development

## Best practices

### Logging strategy

1.  **Structured Logging**
    *   Use consistent formats
    *   Include context
    *   Add timestamps
    *   Track request IDs

2.  **Error Handling**
    *   Log stack traces
    *   Include error context
    *   Track error patterns
    *   Monitor recovery

3.  **Performance Tracking**
    *   Log operation timing
    *   Monitor resource usage
    *   Track message sizes
    *   Measure latency

### Security considerations

When debugging:

1.  **Sensitive Data**
    *   Sanitize logs
    *   Protect credentials
    *   Mask personal information

2.  **Access Control**
    *   Verify permissions
    *   Check authentication
    *   Monitor access patterns

## Getting help

When encountering issues:

1.  **First Steps**
    *   Check server logs
    *   Test with [Inspector](/docs/tools/inspector)
    *   Review configuration
    *   Verify environment

2.  **Support Channels**
    *   GitHub issues
    *   GitHub discussions

3.  **Providing Information**
    *   Log excerpts
    *   Configuration files
    *   Steps to reproduce
    *   Environment details

## Next steps

<CardGroup cols={2}>
  <Card title="MCP Inspector" icon="magnifying-glass" href="/docs/tools/inspector">
    Learn to use the MCP Inspector
  </Card>
</CardGroup>


# Inspector
Source: https://modelcontextprotocol.io/docs/tools/inspector

In-depth guide to using the MCP Inspector for testing and debugging Model Context Protocol servers

The [MCP Inspector](https://github.com/modelcontextprotocol/inspector) is an interactive developer tool for testing and debugging MCP servers. While the [Debugging Guide](/docs/tools/debugging) covers the Inspector as part of the overall debugging toolkit, this document provides a detailed exploration of the Inspector's features and capabilities.

## Getting started

### Installation and basic usage

The Inspector runs directly through `npx` without requiring installation:

```bash
npx @modelcontextprotocol/inspector <command>
```

```bash
npx @modelcontextprotocol/inspector <command> <arg1> <arg2>
```

#### Inspecting servers from NPM or PyPi

A common way to start server packages from [NPM](https://npmjs.com) or [PyPi](https://pypi.com).

<Tabs>
  <Tab title="NPM package">
    ```bash
    npx -y @modelcontextprotocol/inspector npx <package-name> <args>
    # For example
    npx -y @modelcontextprotocol/inspector npx server-postgres postgres://127.0.0.1/testdb
    ```
  </Tab>

  <Tab title="PyPi package">
    ```bash
    npx @modelcontextprotocol/inspector uvx <package-name> <args>
    # For example
    npx @modelcontextprotocol/inspector uvx mcp-server-git --repository ~/code/mcp/servers.git
    ```
  </Tab>
</Tabs>

#### Inspecting locally developed servers

To inspect servers locally developed or downloaded as a repository, the most common
way is:

<Tabs>
  <Tab title="TypeScript">
    ```bash
    npx @modelcontextprotocol/inspector node path/to/server/index.js args...
    ```
  </Tab>

  <Tab title="Python">
    ```bash
    npx @modelcontextprotocol/inspector \
      uv \
      --directory path/to/server \
      run \
      package-name \
      args...
    ```
  </Tab>
</Tabs>

Please carefully read any attached README for the most accurate instructions.

## Feature overview

<Frame caption="The MCP Inspector interface">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/mcp-inspector.png" />
</Frame>

The Inspector provides several features for interacting with your MCP server:

### Server connection pane

*   Allows selecting the [transport](/docs/concepts/transports) for connecting to the server
*   For local servers, supports customizing the command-line arguments and environment

### Resources tab

*   Lists all available resources
*   Shows resource metadata (MIME types, descriptions)
*   Allows resource content inspection
*   Supports subscription testing

### Prompts tab

*   Displays available prompt templates
*   Shows prompt arguments and descriptions
*   Enables prompt testing with custom arguments
*   Previews generated messages

### Tools tab

*   Lists available tools
*   Shows tool schemas and descriptions
*   Enables tool testing with custom inputs
*   Displays tool execution results

### Notifications pane

*   Presents all logs recorded from the server
*   Shows notifications received from the server

## Best practices

### Development workflow

1.  Start Development
    *   Launch Inspector with your server
    *   Verify basic connectivity
    *   Check capability negotiation

2.  Iterative testing
    *   Make server changes
    *   Rebuild the server
    *   Reconnect the Inspector
    *   Test affected features
    *   Monitor messages

3.  Test edge cases
    *   Invalid inputs
    *   Missing prompt arguments
    *   Concurrent operations
    *   Verify error handling and error responses

## Next steps

<CardGroup cols={2}>
  <Card title="Inspector Repository" icon="github" href="https://github.com/modelcontextprotocol/inspector">
    Check out the MCP Inspector source code
  </Card>

  <Card title="Debugging Guide" icon="bug" href="/docs/tools/debugging">
    Learn about broader debugging strategies
  </Card>
</CardGroup>


# Example Servers
Source: https://modelcontextprotocol.io/examples

A list of example servers and implementations

This page showcases various Model Context Protocol (MCP) servers that demonstrate the protocol's capabilities and versatility. These servers enable Large Language Models (LLMs) to securely access tools and data sources.

## Reference implementations

These official reference servers demonstrate core MCP features and SDK usage:

### Data and file systems

* **[Filesystem](https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem)** - Secure file operations with configurable access controls
* **[PostgreSQL](https://github.com/modelcontextprotocol/servers/tree/main/src/postgres)** - Read-only database access with schema inspection capabilities
* **[SQLite](https://github.com/modelcontextprotocol/servers/tree/main/src/sqlite)** - Database interaction and business intelligence features
* **[Google Drive](https://github.com/modelcontextprotocol/servers/tree/main/src/gdrive)** - File access and search capabilities for Google Drive

### Development tools

* **[Git](https://github.com/modelcontextprotocol/servers/tree/main/src/git)** - Tools to read, search, and manipulate Git repositories
* **[GitHub](https://github.com/modelcontextprotocol/servers/tree/main/src/github)** - Repository management, file operations, and GitHub API integration
* **[GitLab](https://github.com/modelcontextprotocol/servers/tree/main/src/gitlab)** - GitLab API integration enabling project management
* **[Sentry](https://github.com/modelcontextprotocol/servers/tree/main/src/sentry)** - Retrieving and analyzing issues from Sentry.io

### Web and browser automation

* **[Brave Search](https://github.com/modelcontextprotocol/servers/tree/main/src/brave-search)** - Web and local search using Brave's Search API
* **[Fetch](https://github.com/modelcontextprotocol/servers/tree/main/src/fetch)** - Web content fetching and conversion optimized for LLM usage
* **[Puppeteer](https://github.com/modelcontextprotocol/servers/tree/main/src/puppeteer)** - Browser automation and web scraping capabilities

### Productivity and communication

* **[Slack](https://github.com/modelcontextprotocol/servers/tree/main/src/slack)** - Channel management and messaging capabilities
* **[Google Maps](https://github.com/modelcontextprotocol/servers/tree/main/src/google-maps)** - Location services, directions, and place details
* **[Memory](https://github.com/modelcontextprotocol/servers/tree/main/src/memory)** - Knowledge graph-based persistent memory system

### AI and specialized tools

* **[EverArt](https://github.com/modelcontextprotocol/servers/tree/main/src/everart)** - AI image generation using various models
* **[Sequential Thinking](https://github.com/modelcontextprotocol/servers/tree/main/src/sequentialthinking)** - Dynamic problem-solving through thought sequences
* **[AWS KB Retrieval](https://github.com/modelcontextprotocol/servers/tree/main/src/aws-kb-retrieval-server)** - Retrieval from AWS Knowledge Base using Bedrock Agent Runtime

## Official integrations

These MCP servers are maintained by companies for their platforms:

* **[Axiom](https://github.com/axiomhq/mcp-server-axiom)** - Query and analyze logs, traces, and event data using natural language
* **[Browserbase](https://github.com/browserbase/mcp-server-browserbase)** - Automate browser interactions in the cloud
* **[Cloudflare](https://github.com/cloudflare/mcp-server-cloudflare)** - Deploy and manage resources on the Cloudflare developer platform
* **[E2B](https://github.com/e2b-dev/mcp-server)** - Execute code in secure cloud sandboxes
* **[Neon](https://github.com/neondatabase/mcp-server-neon)** - Interact with the Neon serverless Postgres platform
* **[Obsidian Markdown Notes](https://github.com/calclavia/mcp-obsidian)** - Read and search through Markdown notes in Obsidian vaults
* **[Qdrant](https://github.com/qdrant/mcp-server-qdrant/)** - Implement semantic memory using the Qdrant vector search engine
* **[Raygun](https://github.com/MindscapeHQ/mcp-server-raygun)** - Access crash reporting and monitoring data
* **[Search1API](https://github.com/fatwang2/search1api-mcp)** - Unified API for search, crawling, and sitemaps
* **[Stripe](https://github.com/stripe/agent-toolkit)** - Interact with the Stripe API
* **[Tinybird](https://github.com/tinybirdco/mcp-tinybird)** - Interface with the Tinybird serverless ClickHouse platform

## Community highlights

A growing ecosystem of community-developed servers extends MCP's capabilities:

* **[Docker](https://github.com/ckreiling/mcp-server-docker)** - Manage containers, images, volumes, and networks
* **[Kubernetes](https://github.com/Flux159/mcp-server-kubernetes)** - Manage pods, deployments, and services
* **[Linear](https://github.com/jerhadf/linear-mcp-server)** - Project management and issue tracking
* **[Snowflake](https://github.com/datawiz168/mcp-snowflake-service)** - Interact with Snowflake databases
* **[Spotify](https://github.com/varunneal/spotify-mcp)** - Control Spotify playback and manage playlists
* **[Todoist](https://github.com/abhiz123/todoist-mcp-server)** - Task management integration

> **Note:** Community servers are untested and should be used at your own risk. They are not affiliated with or endorsed by Anthropic.

For a complete list of community servers, visit the [MCP Servers Repository](https://github.com/modelcontextprotocol/servers).

## Getting started

### Using reference servers

TypeScript-based servers can be used directly with `npx`:

```bash
npx -y @modelcontextprotocol/server-memory
```

Python-based servers can be used with `uvx` (recommended) or `pip`:

```bash
# Using uvx
uvx mcp-server-git

# Using pip
pip install mcp-server-git
python -m mcp_server_git
```

### Configuring with Claude

To use an MCP server with Claude, add it to your configuration:

```json
{
  "mcpServers": {
    "memory": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-memory"]
    },
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/path/to/allowed/files"]
    },
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "<YOUR_TOKEN>"
      }
    }
  }
}
```

## Additional resources

* [MCP Servers Repository](https://github.com/modelcontextprotocol/servers) - Complete collection of reference implementations and community servers
* [Awesome MCP Servers](https://github.com/punkpeye/awesome-mcp-servers) - Curated list of MCP servers
* [MCP CLI](https://github.com/wong2/mcp-cli) - Command-line inspector for testing MCP servers
* [MCP Get](https://mcp-get.com) - Tool for installing and managing MCP servers
* [Supergateway](https://github.com/supercorp-ai/supergateway) - Run MCP stdio servers over SSE

Visit our [GitHub Discussions](https://github.com/orgs/modelcontextprotocol/discussions) to engage with the MCP community.


# Introduction
Source: https://modelcontextprotocol.io/introduction

Get started with the Model Context Protocol (MCP)

<Note>Java SDK released! Check out [what else is new.](/development/updates)</Note>

MCP is an open protocol that standardizes how applications provide context to LLMs. Think of MCP like a USB-C port for AI applications. Just as USB-C provides a standardized way to connect your devices to various peripherals and accessories, MCP provides a standardized way to connect AI models to different data sources and tools.

## Why MCP?

MCP helps you build agents and complex workflows on top of LLMs. LLMs frequently need to integrate with data and tools, and MCP provides:

* A growing list of pre-built integrations that your LLM can directly plug into
* The flexibility to switch between LLM providers and vendors
* Best practices for securing your data within your infrastructure

### General architecture

At its core, MCP follows a client-server architecture where a host application can connect to multiple servers:

```mermaid
flowchart LR
    subgraph "Your Computer"
        Host["Host with MCP Client\n(Claude, IDEs, Tools)"]
        S1["MCP Server A"]
        S2["MCP Server B"]
        S3["MCP Server C"]
        Host <-->|"MCP Protocol"| S1
        Host <-->|"MCP Protocol"| S2
        Host <-->|"MCP Protocol"| S3
        S1 <--> D1[("Local\nData Source A")]
        S2 <--> D2[("Local\nData Source B")]
    end
    subgraph "Internet"
        S3 <-->|"Web APIs"| D3[("Remote\nService C")]
    end
```

* **MCP Hosts**: Programs like Claude Desktop, IDEs, or AI tools that want to access data through MCP
* **MCP Clients**: Protocol clients that maintain 1:1 connections with servers
* **MCP Servers**: Lightweight programs that each expose specific capabilities through the standardized Model Context Protocol
* **Local Data Sources**: Your computer's files, databases, and services that MCP servers can securely access
* **Remote Services**: External systems available over the internet (e.g., through APIs) that MCP servers can connect to

## Get started

Choose the path that best fits your needs:

#### Quick Starts

<CardGroup cols={2}>
  <Card title="For Server Developers" icon="bolt" href="/quickstart/server">
    Get started building your own server to use in Claude for Desktop and other clients
  </Card>

  <Card title="For Client Developers" icon="bolt" href="/quickstart/client">
    Get started building your own client that can integrate with all MCP servers
  </Card>

  <Card title="For Claude Desktop Users" icon="bolt" href="/quickstart/user">
    Get started using pre-built servers in Claude for Desktop
  </Card>
</CardGroup>

#### Examples

<CardGroup cols={2}>
  <Card title="Example Servers" icon="grid" href="/examples">
    Check out our gallery of official MCP servers and implementations
  </Card>

  <Card title="Example Clients" icon="cubes" href="/clients">
    View the list of clients that support MCP integrations
  </Card>
</CardGroup>

## Tutorials

<CardGroup cols={2}>
  <Card title="Building MCP with LLMs" icon="comments" href="/tutorials/building-mcp-with-llms">
    Learn how to use LLMs like Claude to speed up your MCP development
  </Card>

  <Card title="Debugging Guide" icon="bug" href="/docs/tools/debugging">
    Learn how to effectively debug MCP servers and integrations
  </Card>

  <Card title="MCP Inspector" icon="magnifying-glass" href="/docs/tools/inspector">
    Test and inspect your MCP servers with our interactive debugging tool
  </Card>
</CardGroup>

## Explore MCP

Dive deeper into MCP's core concepts and capabilities:

<CardGroup cols={2}>
  <Card title="Core architecture" icon="sitemap" href="/docs/concepts/architecture">
    Understand how MCP connects clients, servers, and LLMs
  </Card>

  <Card title="Resources" icon="database" href="/docs/concepts/resources">
    Expose data and content from your servers to LLMs
  </Card>

  <Card title="Prompts" icon="message" href="/docs/concepts/prompts">
    Create reusable prompt templates and workflows
  </Card>

  <Card title="Tools" icon="wrench" href="/docs/concepts/tools">
    Enable LLMs to perform actions through your server
  </Card>

  <Card title="Sampling" icon="robot" href="/docs/concepts/sampling">
    Let your servers request completions from LLMs
  </Card>

  <Card title="Transports" icon="network-wired" href="/docs/concepts/transports">
    Learn about MCP's communication mechanism
  </Card>
</CardGroup>

## Contributing

Want to contribute? Check out our [Contributing Guide](/development/contributing) to learn how you can help improve MCP.

## Support and Feedback

Here's how to get help or provide feedback:

* For bug reports and feature requests related to the MCP specification, SDKs, or documentation (open source), please [create a GitHub issue](https://github.com/modelcontextprotocol)
* For discussions or Q\&A about the MCP specification, use the [specification discussions](https://github.com/modelcontextprotocol/specification/discussions)
* For discussions or Q\&A about other MCP open source components, use the [organization discussions](https://github.com/orgs/modelcontextprotocol/discussions)
* For bug reports, feature requests, and questions related to Claude.app and claude.ai's MCP integration, please email [mcp-support@anthropic.com](mailto:mcp-support@anthropic.com)


# For Client Developers
Source: https://modelcontextprotocol.io/quickstart/client

Get started building your own client that can integrate with all MCP servers.

In this tutorial, you'll learn how to build a LLM-powered chatbot client that connects to MCP servers. It helps to have gone through the [Server quickstart](/quickstart/server) that guides you through the basic of building your first server.

<Tabs>
  <Tab title="Python">
    [You can find the complete code for this tutorial here.](https://github.com/modelcontextprotocol/quickstart-resources/tree/main/mcp-client)

    ## System Requirements

    Before starting, ensure your system meets these requirements:

    * Mac or Windows computer
    * Latest Python version installed
    * Latest version of `uv` installed

    ## Setting Up Your Environment

    First, create a new Python project with `uv`:

    ```bash
    # Create project directory
    uv init mcp-client
    cd mcp-client

    # Create virtual environment
    uv venv

    # Activate virtual environment
    # On Windows:
    .venv\Scripts\activate
    # On Unix or MacOS:
    source .venv/bin/activate

    # Install required packages
    uv add mcp anthropic python-dotenv

    # Remove boilerplate files
    rm hello.py

    # Create our main file
    touch client.py
    ```

    ## Setting Up Your API Key

    You'll need an Anthropic API key from the [Anthropic Console](https://console.anthropic.com/settings/keys).

    Create a `.env` file to store it:

    ```bash
    # Create .env file
    touch .env
    ```

    Add your key to the `.env` file:

    ```bash
    ANTHROPIC_API_KEY=<your key here>
    ```

    Add `.env` to your `.gitignore`:

    ```bash
    echo ".env" >> .gitignore
    ```

    <Warning>
      Make sure you keep your `ANTHROPIC_API_KEY` secure!
    </Warning>

    ## Creating the Client

    ### Basic Client Structure

    First, let's set up our imports and create the basic client class:

    ```python
    import asyncio
    from typing import Optional
    from contextlib import AsyncExitStack

    from mcp import ClientSession, StdioServerParameters
    from mcp.client.stdio import stdio_client

    from anthropic import Anthropic
    from dotenv import load_dotenv

    load_dotenv()  # load environment variables from .env

    class MCPClient:
        def __init__(self):
            # Initialize session and client objects
            self.session: Optional[ClientSession] = None
            self.exit_stack = AsyncExitStack()
            self.anthropic = Anthropic()
        # methods will go here
    ```

    ### Server Connection Management

    Next, we'll implement the method to connect to an MCP server:

    ```python
    async def connect_to_server(self, server_script_path: str):
        """Connect to an MCP server

        Args:
            server_script_path: Path to the server script (.py or .js)
        """
        is_python = server_script_path.endswith('.py')
        is_js = server_script_path.endswith('.js')
        if not (is_python or is_js):
            raise ValueError("Server script must be a .py or .js file")

        command = "python" if is_python else "node"
        server_params = StdioServerParameters(
            command=command,
            args=[server_script_path],
            env=None
        )

        stdio_transport = await self.exit_stack.enter_async_context(stdio_client(server_params))
        self.stdio, self.write = stdio_transport
        self.session = await self.exit_stack.enter_async_context(ClientSession(self.stdio, self.write))

        await self.session.initialize()

        # List available tools
        response = await self.session.list_tools()
        tools = response.tools
        print("\nConnected to server with tools:", [tool.name for tool in tools])
    ```

    ### Query Processing Logic

    Now let's add the core functionality for processing queries and handling tool calls:

    ```python
    async def process_query(self, query: str) -> str:
        """Process a query using Claude and available tools"""
        messages = [
            {
                "role": "user",
                "content": query
            }
        ]

        response = await self.session.list_tools()
        available_tools = [{
            "name": tool.name,
            "description": tool.description,
            "input_schema": tool.inputSchema
        } for tool in response.tools]

        # Initial Claude API call
        response = self.anthropic.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=1000,
            messages=messages,
            tools=available_tools
        )

        # Process response and handle tool calls
        tool_results = []
        final_text = []

        assistant_message_content = []
        for content in response.content:
            if content.type == 'text':
                final_text.append(content.text)
                assistant_message_content.append(content)
            elif content.type == 'tool_use':
                tool_name = content.name
                tool_args = content.input

                # Execute tool call
                result = await self.session.call_tool(tool_name, tool_args)
                tool_results.append({"call": tool_name, "result": result})
                final_text.append(f"[Calling tool {tool_name} with args {tool_args}]")

                assistant_message_content.append(content)
                messages.append({
                    "role": "assistant",
                    "content": assistant_message_content
                })
                messages.append({
                    "role": "user",
                    "content": [
                        {
                            "type": "tool_result",
                            "tool_use_id": content.id,
                            "content": result.content
                        }
                    ]
                })

                # Get next response from Claude
                response = self.anthropic.messages.create(
                    model="claude-3-5-sonnet-20241022",
                    max_tokens=1000,
                    messages=messages,
                    tools=available_tools
                )

                final_text.append(response.content[0].text)

        return "\n".join(final_text)
    ```

    ### Interactive Chat Interface

    Now we'll add the chat loop and cleanup functionality:

    ```python
    async def chat_loop(self):
        """Run an interactive chat loop"""
        print("\nMCP Client Started!")
        print("Type your queries or 'quit' to exit.")

        while True:
            try:
                query = input("\nQuery: ").strip()

                if query.lower() == 'quit':
                    break

                response = await self.process_query(query)
                print("\n" + response)

            except Exception as e:
                print(f"\nError: {str(e)}")

    async def cleanup(self):
        """Clean up resources"""
        await self.exit_stack.aclose()
    ```

    ### Main Entry Point

    Finally, we'll add the main execution logic:

    ```python
    async def main():
        if len(sys.argv) < 2:
            print("Usage: python client.py <path_to_server_script>")
            sys.exit(1)

        client = MCPClient()
        try:
            await client.connect_to_server(sys.argv[1])
            await client.chat_loop()
        finally:
            await client.cleanup()

    if __name__ == "__main__":
        import sys
        asyncio.run(main())
    ```

    You can find the complete `client.py` file [here.](https://gist.github.com/zckly/f3f28ea731e096e53b39b47bf0a2d4b1)

    ## Key Components Explained

    ### 1. Client Initialization

    * The `MCPClient` class initializes with session management and API clients
    * Uses `AsyncExitStack` for proper resource management
    * Configures the Anthropic client for Claude interactions

    ### 2. Server Connection

    * Supports both Python and Node.js servers
    * Validates server script type
    * Sets up proper communication channels
    * Initializes the session and lists available tools

    ### 3. Query Processing

    * Maintains conversation context
    * Handles Claude's responses and tool calls
    * Manages the message flow between Claude and tools
    * Combines results into a coherent response

    ### 4. Interactive Interface

    * Provides a simple command-line interface
    * Handles user input and displays responses
    * Includes basic error handling
    * Allows graceful exit

    ### 5. Resource Management

    * Proper cleanup of resources
    * Error handling for connection issues
    * Graceful shutdown procedures

    ## Common Customization Points

    1. **Tool Handling**
       * Modify `process_query()` to handle specific tool types
       * Add custom error handling for tool calls
       * Implement tool-specific response formatting

    2. **Response Processing**
       * Customize how tool results are formatted
       * Add response filtering or transformation
       * Implement custom logging

    3. **User Interface**
       * Add a GUI or web interface
       * Implement rich console output
       * Add command history or auto-completion

    ## Running the Client

    To run your client with any MCP server:

    ```bash
    uv run client.py path/to/server.py # python server
    uv run client.py path/to/build/index.js # node server
    ```

    <Note>
      If you're continuing the weather tutorial from the server quickstart, your command might look something like this: `python client.py .../weather/src/weather/server.py`
    </Note>

    The client will:

    1. Connect to the specified server
    2. List available tools
    3. Start an interactive chat session where you can:
       * Enter queries
       * See tool executions
       * Get responses from Claude

    Here's an example of what it should look like if connected to the weather server from the server quickstart:

    <Frame>
      <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/client-claude-cli-python.png" />
    </Frame>

    ## How It Works

    When you submit a query:

    1. The client gets the list of available tools from the server
    2. Your query is sent to Claude along with tool descriptions
    3. Claude decides which tools (if any) to use
    4. The client executes any requested tool calls through the server
    5. Results are sent back to Claude
    6. Claude provides a natural language response
    7. The response is displayed to you

    ## Best practices

    1. **Error Handling**
       * Always wrap tool calls in try-catch blocks
       * Provide meaningful error messages
       * Gracefully handle connection issues

    2. **Resource Management**
       * Use `AsyncExitStack` for proper cleanup
       * Close connections when done
       * Handle server disconnections

    3. **Security**
       * Store API keys securely in `.env`
       * Validate server responses
       * Be cautious with tool permissions

    ## Troubleshooting

    ### Server Path Issues

    * Double-check the path to your server script is correct
    * Use the absolute path if the relative path isn't working
    * For Windows users, make sure to use forward slashes (/) or escaped backslashes (\\) in the path
    * Verify the server file has the correct extension (.py for Python or .js for Node.js)

    Example of correct path usage:

    ```bash
    # Relative path
    uv run client.py ./server/weather.py

    # Absolute path
    uv run client.py /Users/username/projects/mcp-server/weather.py

    # Windows path (either format works)
    uv run client.py C:/projects/mcp-server/weather.py
    uv run client.py C:\\projects\\mcp-server\\weather.py
    ```

    ### Response Timing

    * The first response might take up to 30 seconds to return
    * This is normal and happens while:
      * The server initializes
      * Claude processes the query
      * Tools are being executed
    * Subsequent responses are typically faster
    * Don't interrupt the process during this initial waiting period

    ### Common Error Messages

    If you see:

    * `FileNotFoundError`: Check your server path
    * `Connection refused`: Ensure the server is running and the path is correct
    * `Tool execution failed`: Verify the tool's required environment variables are set
    * `Timeout error`: Consider increasing the timeout in your client configuration
  </Tab>

  <Tab title="Java">
    <Note>
      This is a quickstart demo based on Spring AI MCP auto-configuration and boot starters.
      To learn how to create sync and async MCP Clients manually, consult the [Java SDK Client](/sdk/java/mcp-client) documentation
    </Note>

    This example demonstrates how to build an interactive chatbot that combines Spring AI's Model Context Protocol (MCP) with the [Brave Search MCP Server](https://github.com/modelcontextprotocol/servers/tree/main/src/brave-search). The application creates a conversational interface powered by Anthropic's Claude AI model that can perform internet searches through Brave Search, enabling natural language interactions with real-time web data.
    [You can find the complete code for this tutorial here.](https://github.com/spring-projects/spring-ai-examples/tree/main/model-context-protocol/web-search/brave-chatbot)

    ## System Requirements

    Before starting, ensure your system meets these requirements:

    * Java 17 or higher
    * Maven 3.6+
    * npx package manager
    * Anthropic API key (Claude)
    * Brave Search API key

    ## Setting Up Your Environment

    1. Install npx (Node Package eXecute):
       First, make sure to install [npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)
       and then run:
       ```bash
       npm install -g npx
       ```

    2. Clone the repository:
       ```bash
       git clone https://github.com/spring-projects/spring-ai-examples.git
       cd model-context-protocol/brave-chatbot
       ```

    3. Set up your API keys:
       ```bash
       export ANTHROPIC_API_KEY='your-anthropic-api-key-here'
       export BRAVE_API_KEY='your-brave-api-key-here'
       ```

    4. Build the application:
       ```bash
       ./mvnw clean install
       ```

    5. Run the application using Maven:
       ```bash
       ./mvnw spring-boot:run
       ```

    <Warning>
      Make sure you keep your `ANTHROPIC_API_KEY` and `BRAVE_API_KEY` keys secure!
    </Warning>

    ## How it Works

    The application integrates Spring AI with the Brave Search MCP server through several components:

    ### MCP Client Configuration

    1. Required dependencies in pom.xml:

    ```xml
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-mcp-client-spring-boot-starter</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-anthropic-spring-boot-starter</artifactId>
    </dependency>
    ```

    2. Application properties (application.yml):

    ```yml
    spring:
      ai:
        mcp:
          client:
            enabled: true
            name: brave-search-client
            version: 1.0.0
            type: SYNC
            request-timeout: 20s
            stdio:
              root-change-notification: true
              servers-configuration: classpath:/mcp-servers-config.json
        anthropic:
          api-key: ${ANTHROPIC_API_KEY}
    ```

    This activates the `spring-ai-mcp-client-spring-boot-starter` to create one or more `McpClient`s based on the provided server configuration.

    3. MCP Server Configuration (`mcp-servers-config.json`):

    ```json
    {
      "mcpServers": {
        "brave-search": {
          "command": "npx",
          "args": [
            "-y",
            "@modelcontextprotocol/server-brave-search"
          ],
          "env": {
            "BRAVE_API_KEY": "<PUT YOUR BRAVE API KEY>"
          }
        }
      }
    }
    ```

    ### Chat Implementation

    The chatbot is implemented using Spring AI's ChatClient with MCP tool integration:

    ```java
    var chatClient = chatClientBuilder
        .defaultSystem("You are useful assistant, expert in AI and Java.")
        .defaultTools((Object[]) mcpToolAdapter.toolCallbacks())
        .defaultAdvisors(new MessageChatMemoryAdvisor(new InMemoryChatMemory()))
        .build();
    ```

    Key features:

    * Uses Claude AI model for natural language understanding
    * Integrates Brave Search through MCP for real-time web search capabilities
    * Maintains conversation memory using InMemoryChatMemory
    * Runs as an interactive command-line application

    ### Build and run

    ```bash
    ./mvnw clean install
    java -jar ./target/ai-mcp-brave-chatbot-0.0.1-SNAPSHOT.jar
    ```

    or

    ```bash
    ./mvnw spring-boot:run
    ```

    The application will start an interactive chat session where you can ask questions. The chatbot will use Brave Search when it needs to find information from the internet to answer your queries.

    The chatbot can:

    * Answer questions using its built-in knowledge
    * Perform web searches when needed using Brave Search
    * Remember context from previous messages in the conversation
    * Combine information from multiple sources to provide comprehensive answers

    ### Advanced Configuration

    The MCP client supports additional configuration options:

    * Client customization through `McpSyncClientCustomizer` or `McpAsyncClientCustomizer`
    * Multiple clients with multiple transport types: `STDIO` and `SSE` (Server-Sent Events)
    * Integration with Spring AI's tool execution framework
    * Automatic client initialization and lifecycle management

    For WebFlux-based applications, you can use the WebFlux starter instead:

    ```xml
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-mcp-client-webflux-spring-boot-starter</artifactId>
    </dependency>
    ```

    This provides similar functionality but uses a WebFlux-based SSE transport implementation, recommended for production deployments.
  </Tab>
</Tabs>

## Next steps

<CardGroup cols={2}>
  <Card title="Example servers" icon="grid" href="/examples">
    Check out our gallery of official MCP servers and implementations
  </Card>

  <Card title="Clients" icon="cubes" href="/clients">
    View the list of clients that support MCP integrations
  </Card>

  <Card title="Building MCP with LLMs" icon="comments" href="/building-mcp-with-llms">
    Learn how to use LLMs like Claude to speed up your MCP development
  </Card>

  <Card title="Core architecture" icon="sitemap" href="/docs/concepts/architecture">
    Understand how MCP connects clients, servers, and LLMs
  </Card>
</CardGroup>


# For Server Developers
Source: https://modelcontextprotocol.io/quickstart/server

Get started building your own server to use in Claude for Desktop and other clients.

In this tutorial, we'll build a simple MCP weather server and connect it to a host, Claude for Desktop. We'll start with a basic setup, and then progress to more complex use cases.

### What we'll be building

Many LLMs (including Claude) do not currently have the ability to fetch the forecast and severe weather alerts. Let's use MCP to solve that!

We'll build a server that exposes two tools: `get-alerts` and `get-forecast`. Then we'll connect the server to an MCP host (in this case, Claude for Desktop):

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/weather-alerts.png" />
</Frame>

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/current-weather.png" />
</Frame>

<Note>
  Servers can connect to any client. We've chosen Claude for Desktop here for simplicity, but we also have guides on [building your own client](/quickstart/client) as well as a [list of other clients here](/clients).
</Note>

<Accordion title="Why Claude for Desktop and not Claude.ai?">
  Because servers are locally run, MCP currently only supports desktop hosts. Remote hosts are in active development.
</Accordion>

### Core MCP Concepts

MCP servers can provide three main types of capabilities:

1. **Resources**: File-like data that can be read by clients (like API responses or file contents)
2. **Tools**: Functions that can be called by the LLM (with user approval)
3. **Prompts**: Pre-written templates that help users accomplish specific tasks

This tutorial will primarily focus on tools.

<Tabs>
  <Tab title="Python">
    Let's get started with building our weather server! [You can find the complete code for what we'll be building here.](https://github.com/modelcontextprotocol/quickstart-resources/tree/main/weather-server-python)

    ### Prerequisite knowledge

    This quickstart assumes you have familiarity with:

    * Python
    * LLMs like Claude

    ### System requirements

    * Python 3.10 or higher installed.
    * You must use the Python MCP SDK 1.2.0 or higher.

    ### Set up your environment

    First, let's install `uv` and set up our Python project and environment:

    <CodeGroup>
      ```bash MacOS/Linux
      curl -LsSf https://astral.sh/uv/install.sh | sh
      ```

      ```powershell Windows
      powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"
      ```
    </CodeGroup>

    Make sure to restart your terminal afterwards to ensure that the `uv` command gets picked up.

    Now, let's create and set up our project:

    <CodeGroup>
      ```bash MacOS/Linux
      # Create a new directory for our project
      uv init weather
      cd weather

      # Create virtual environment and activate it
      uv venv
      source .venv/bin/activate

      # Install dependencies
      uv add "mcp[cli]" httpx

      # Create our server file
      touch weather.py
      ```

      ```powershell Windows
      # Create a new directory for our project
      uv init weather
      cd weather

      # Create virtual environment and activate it
      uv venv
      .venv\Scripts\activate

      # Install dependencies
      uv add mcp[cli] httpx

      # Create our server file
      new-item weather.py
      ```
    </CodeGroup>

    Now let's dive into building your server.

    ## Building your server

    ### Importing packages and setting up the instance

    Add these to the top of your `weather.py`:

    ```python
    from typing import Any
    import httpx
    from mcp.server.fastmcp import FastMCP

    # Initialize FastMCP server
    mcp = FastMCP("weather")

    # Constants
    NWS_API_BASE = "https://api.weather.gov"
    USER_AGENT = "weather-app/1.0"
    ```

    The FastMCP class uses Python type hints and docstrings to automatically generate tool definitions, making it easy to create and maintain MCP tools.

    ### Helper functions

    Next, let's add our helper functions for querying and formatting the data from the National Weather Service API:

    ```python
    async def make_nws_request(url: str) -> dict[str, Any] | None:
        """Make a request to the NWS API with proper error handling."""
        headers = {
            "User-Agent": USER_AGENT,
            "Accept": "application/geo+json"
        }
        async with httpx.AsyncClient() as client:
            try:
                response = await client.get(url, headers=headers, timeout=30.0)
                response.raise_for_status()
                return response.json()
            except Exception:
                return None

    def format_alert(feature: dict) -> str:
        """Format an alert feature into a readable string."""
        props = feature["properties"]
        return f"""
    Event: {props.get('event', 'Unknown')}
    Area: {props.get('areaDesc', 'Unknown')}
    Severity: {props.get('severity', 'Unknown')}
    Description: {props.get('description', 'No description available')}
    Instructions: {props.get('instruction', 'No specific instructions provided')}
    """
    ```

    ### Implementing tool execution

    The tool execution handler is responsible for actually executing the logic of each tool. Let's add it:

    ```python
    @mcp.tool()
    async def get_alerts(state: str) -> str:
        """Get weather alerts for a US state.

        Args:
            state: Two-letter US state code (e.g. CA, NY)
        """
        url = f"{NWS_API_BASE}/alerts/active/area/{state}"
        data = await make_nws_request(url)

        if not data or "features" not in data:
            return "Unable to fetch alerts or no alerts found."

        if not data["features"]:
            return "No active alerts for this state."

        alerts = [format_alert(feature) for feature in data["features"]]
        return "\n---\n".join(alerts)

    @mcp.tool()
    async def get_forecast(latitude: float, longitude: float) -> str:
        """Get weather forecast for a location.

        Args:
            latitude: Latitude of the location
            longitude: Longitude of the location
        """
        # First get the forecast grid endpoint
        points_url = f"{NWS_API_BASE}/points/{latitude},{longitude}"
        points_data = await make_nws_request(points_url)

        if not points_data:
            return "Unable to fetch forecast data for this location."

        # Get the forecast URL from the points response
        forecast_url = points_data["properties"]["forecast"]
        forecast_data = await make_nws_request(forecast_url)

        if not forecast_data:
            return "Unable to fetch detailed forecast."

        # Format the periods into a readable forecast
        periods = forecast_data["properties"]["periods"]
        forecasts = []
        for period in periods[:5]:  # Only show next 5 periods
            forecast = f"""
    {period['name']}:
    Temperature: {period['temperature']}{period['temperatureUnit']}
    Wind: {period['windSpeed']} {period['windDirection']}
    Forecast: {period['detailedForecast']}
    """
            forecasts.append(forecast)

        return "\n---\n".join(forecasts)
    ```

    ### Running the server

    Finally, let's initialize and run the server:

    ```python
    if __name__ == "__main__":
        # Initialize and run the server
        mcp.run(transport='stdio')
    ```

    Your server is complete! Run `uv run weather.py` to confirm that everything's working.

    Let's now test your server from an existing MCP host, Claude for Desktop.

    ## Testing your server with Claude for Desktop

    <Note>
      Claude for Desktop is not yet available on Linux. Linux users can proceed to the [Building a client](/quickstart/client) tutorial to build an MCP client that connects to the server we just built.
    </Note>

    First, make sure you have Claude for Desktop installed. [You can install the latest version
    here.](https://claude.ai/download) If you already have Claude for Desktop, **make sure it's updated to the latest version.**

    We'll need to configure Claude for Desktop for whichever MCP servers you want to use. To do this, open your Claude for Desktop App configuration at `~/Library/Application Support/Claude/claude_desktop_config.json` in a text editor. Make sure to create the file if it doesn't exist.

    For example, if you have [VS Code](https://code.visualstudio.com/) installed:

    <Tabs>
      <Tab title="MacOS/Linux">
        ```bash
        code ~/Library/Application\ Support/Claude/claude_desktop_config.json
        ```
      </Tab>

      <Tab title="Windows">
        ```powershell
        code $env:AppData\Claude\claude_desktop_config.json
        ```
      </Tab>
    </Tabs>

    You'll then add your servers in the `mcpServers` key. The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.

    In this case, we'll add our single weather server like so:

    <Tabs>
      <Tab title="MacOS/Linux">
        ```json Python
        {
            "mcpServers": {
                "weather": {
                    "command": "uv",
                    "args": [
                        "--directory",
                        "/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather",
                        "run",
                        "weather.py"
                    ]
                }
            }
        }
        ```
      </Tab>

      <Tab title="Windows">
        ```json Python
        {
            "mcpServers": {
                "weather": {
                    "command": "uv",
                    "args": [
                        "--directory",
                        "C:\\ABSOLUTE\\PATH\\TO\\PARENT\\FOLDER\\weather",
                        "run",
                        "weather.py"
                    ]
                }
            }
        }
        ```
      </Tab>
    </Tabs>

    <Warning>
      You may need to put the full path to the `uv` executable in the `command` field. You can get this by running `which uv` on MacOS/Linux or `where uv` on Windows.
    </Warning>

    <Note>
      Make sure you pass in the absolute path to your server.
    </Note>

    This tells Claude for Desktop:

    1. There's an MCP server named "weather"
    2. To launch it by running `uv --directory /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather run weather`

    Save the file, and restart **Claude for Desktop**.
  </Tab>

  <Tab title="Node">
    Let's get started with building our weather server! [You can find the complete code for what we'll be building here.](https://github.com/modelcontextprotocol/quickstart-resources/tree/main/weather-server-typescript)

    ### Prerequisite knowledge

    This quickstart assumes you have familiarity with:

    * TypeScript
    * LLMs like Claude

    ### System requirements

    For TypeScript, make sure you have the latest version of Node installed.

    ### Set up your environment

    First, let's install Node.js and npm if you haven't already. You can download them from [nodejs.org](https://nodejs.org/).
    Verify your Node.js installation:

    ```bash
    node --version
    npm --version
    ```

    For this tutorial, you'll need Node.js version 16 or higher.

    Now, let's create and set up our project:

    <CodeGroup>
      ```bash MacOS/Linux
      # Create a new directory for our project
      mkdir weather
      cd weather

      # Initialize a new npm project
      npm init -y

      # Install dependencies
      npm install @modelcontextprotocol/sdk zod
      npm install -D @types/node typescript

      # Create our files
      mkdir src
      touch src/index.ts
      ```

      ```powershell Windows
      # Create a new directory for our project
      md weather
      cd weather

      # Initialize a new npm project
      npm init -y

      # Install dependencies
      npm install @modelcontextprotocol/sdk zod
      npm install -D @types/node typescript

      # Create our files
      md src
      new-item src\index.ts
      ```
    </CodeGroup>

    Update your package.json to add type: "module" and a build script:

    ```json package.json
    {
      "type": "module",
      "bin": {
        "weather": "./build/index.js"
      },
      "scripts": {
        "build": "tsc && node -e \"require('fs').chmodSync('build/index.js', '755')\"",
      },
      "files": [
        "build"
      ],
    }
    ```

    Create a `tsconfig.json` in the root of your project:

    ```json tsconfig.json
    {
      "compilerOptions": {
        "target": "ES2022",
        "module": "Node16",
        "moduleResolution": "Node16",
        "outDir": "./build",
        "rootDir": "./src",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
      },
      "include": ["src/**/*"],
      "exclude": ["node_modules"]
    }
    ```

    Now let's dive into building your server.

    ## Building your server

    ### Importing packages and setting up the instance

    Add these to the top of your `src/index.ts`:

    ```typescript
    import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
    import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
    import { z } from "zod";

    const NWS_API_BASE = "https://api.weather.gov";
    const USER_AGENT = "weather-app/1.0";

    // Create server instance
    const server = new McpServer({
      name: "weather",
      version: "1.0.0",
    });
    ```

    ### Helper functions

    Next, let's add our helper functions for querying and formatting the data from the National Weather Service API:

    ```typescript
    // Helper function for making NWS API requests
    async function makeNWSRequest<T>(url: string): Promise<T | null> {
      const headers = {
        "User-Agent": USER_AGENT,
        Accept: "application/geo+json",
      };

      try {
        const response = await fetch(url, { headers });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return (await response.json()) as T;
      } catch (error) {
        console.error("Error making NWS request:", error);
        return null;
      }
    }

    interface AlertFeature {
      properties: {
        event?: string;
        areaDesc?: string;
        severity?: string;
        status?: string;
        headline?: string;
      };
    }

    // Format alert data
    function formatAlert(feature: AlertFeature): string {
      const props = feature.properties;
      return [
        `Event: ${props.event || "Unknown"}`,
        `Area: ${props.areaDesc || "Unknown"}`,
        `Severity: ${props.severity || "Unknown"}`,
        `Status: ${props.status || "Unknown"}`,
        `Headline: ${props.headline || "No headline"}`,
        "---",
      ].join("\n");
    }

    interface ForecastPeriod {
      name?: string;
      temperature?: number;
      temperatureUnit?: string;
      windSpeed?: string;
      windDirection?: string;
      shortForecast?: string;
    }

    interface AlertsResponse {
      features: AlertFeature[];
    }

    interface PointsResponse {
      properties: {
        forecast?: string;
      };
    }

    interface ForecastResponse {
      properties: {
        periods: ForecastPeriod[];
      };
    }
    ```

    ### Implementing tool execution

    The tool execution handler is responsible for actually executing the logic of each tool. Let's add it:

    ```typescript
    // Register weather tools
    server.tool(
      "get-alerts",
      "Get weather alerts for a state",
      {
        state: z.string().length(2).describe("Two-letter state code (e.g. CA, NY)"),
      },
      async ({ state }) => {
        const stateCode = state.toUpperCase();
        const alertsUrl = `${NWS_API_BASE}/alerts?area=${stateCode}`;
        const alertsData = await makeNWSRequest<AlertsResponse>(alertsUrl);

        if (!alertsData) {
          return {
            content: [
              {
                type: "text",
                text: "Failed to retrieve alerts data",
              },
            ],
          };
        }

        const features = alertsData.features || [];
        if (features.length === 0) {
          return {
            content: [
              {
                type: "text",
                text: `No active alerts for ${stateCode}`,
              },
            ],
          };
        }

        const formattedAlerts = features.map(formatAlert);
        const alertsText = `Active alerts for ${stateCode}:\n\n${formattedAlerts.join("\n")}`;

        return {
          content: [
            {
              type: "text",
              text: alertsText,
            },
          ],
        };
      },
    );

    server.tool(
      "get-forecast",
      "Get weather forecast for a location",
      {
        latitude: z.number().min(-90).max(90).describe("Latitude of the location"),
        longitude: z.number().min(-180).max(180).describe("Longitude of the location"),
      },
      async ({ latitude, longitude }) => {
        // Get grid point data
        const pointsUrl = `${NWS_API_BASE}/points/${latitude.toFixed(4)},${longitude.toFixed(4)}`;
        const pointsData = await makeNWSRequest<PointsResponse>(pointsUrl);

        if (!pointsData) {
          return {
            content: [
              {
                type: "text",
                text: `Failed to retrieve grid point data for coordinates: ${latitude}, ${longitude}. This location may not be supported by the NWS API (only US locations are supported).`,
              },
            ],
          };
        }

        const forecastUrl = pointsData.properties?.forecast;
        if (!forecastUrl) {
          return {
            content: [
              {
                type: "text",
                text: "Failed to get forecast URL from grid point data",
              },
            ],
          };
        }

        // Get forecast data
        const forecastData = await makeNWSRequest<ForecastResponse>(forecastUrl);
        if (!forecastData) {
          return {
            content: [
              {
                type: "text",
                text: "Failed to retrieve forecast data",
              },
            ],
          };
        }

        const periods = forecastData.properties?.periods || [];
        if (periods.length === 0) {
          return {
            content: [
              {
                type: "text",
                text: "No forecast periods available",
              },
            ],
          };
        }

        // Format forecast periods
        const formattedForecast = periods.map((period: ForecastPeriod) =>
          [
            `${period.name || "Unknown"}:`,
            `Temperature: ${period.temperature || "Unknown"}${period.temperatureUnit || "F"}`,
            `Wind: ${period.windSpeed || "Unknown"} ${period.windDirection || ""}`,
            `${period.shortForecast || "No forecast available"}`,
            "---",
          ].join("\n"),
        );

        const forecastText = `Forecast for ${latitude}, ${longitude}:\n\n${formattedForecast.join("\n")}`;

        return {
          content: [
            {
              type: "text",
              text: forecastText,
            },
          ],
        };
      },
    );
    ```

    ### Running the server

    Finally, implement the main function to run the server:

    ```typescript
    async function main() {
      const transport = new StdioServerTransport();
      await server.connect(transport);
      console.error("Weather MCP Server running on stdio");
    }

    main().catch((error) => {
      console.error("Fatal error in main():", error);
      process.exit(1);
    });
    ```

    Make sure to run `npm run build` to build your server! This is a very important step in getting your server to connect.

    Let's now test your server from an existing MCP host, Claude for Desktop.

    ## Testing your server with Claude for Desktop

    <Note>
      Claude for Desktop is not yet available on Linux. Linux users can proceed to the [Building a client](/quickstart/client) tutorial to build an MCP client that connects to the server we just built.
    </Note>

    First, make sure you have Claude for Desktop installed. [You can install the latest version
    here.](https://claude.ai/download) If you already have Claude for Desktop, **make sure it's updated to the latest version.**

    We'll need to configure Claude for Desktop for whichever MCP servers you want to use. To do this, open your Claude for Desktop App configuration at `~/Library/Application Support/Claude/claude_desktop_config.json` in a text editor. Make sure to create the file if it doesn't exist.

    For example, if you have [VS Code](https://code.visualstudio.com/) installed:

    <Tabs>
      <Tab title="MacOS/Linux">
        ```bash
        code ~/Library/Application\ Support/Claude/claude_desktop_config.json
        ```
      </Tab>

      <Tab title="Windows">
        ```powershell
        code $env:AppData\Claude\claude_desktop_config.json
        ```
      </Tab>
    </Tabs>

    You'll then add your servers in the `mcpServers` key. The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.

    In this case, we'll add our single weather server like so:

    <Tabs>
      <Tab title="MacOS/Linux">
        <CodeGroup>
          ```json Node
          {
              "mcpServers": {
                  "weather": {
                      "command": "node",
                      "args": [
                          "/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js"
                      ]
                  }
              }
          }
          ```
        </CodeGroup>
      </Tab>

      <Tab title="Windows">
        <CodeGroup>
          ```json Node
          {
              "mcpServers": {
                  "weather": {
                      "command": "node",
                      "args": [
                          "C:\\PATH\\TO\\PARENT\\FOLDER\\weather\\build\\index.js"
                      ]
                  }
              }
          }
          ```
        </CodeGroup>
      </Tab>
    </Tabs>

    This tells Claude for Desktop:

    1. There's an MCP server named "weather"
    2. Launch it by running `node /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js`

    Save the file, and restart **Claude for Desktop**.
  </Tab>

  <Tab title="Java">
    <Note>
      This is a quickstart demo based on Spring AI MCP auto-configuraiton and boot starters.
      To learn how to create sync and async MCP Servers, manually, consult the [Java SDK Server](/sdk/java/mcp-server) documentation.
    </Note>

    Let's get started with building our weather server!
    [You can find the complete code for what we'll be building here.](https://github.com/spring-projects/spring-ai-examples/tree/main/model-context-protocol/weather/starter-stdio-server)

    For more information, see the [MCP Server Boot Starter](https://docs.spring.io/spring-ai/reference/api/mcp/mcp-server-boot-starter-docs.html) reference documentation.
    For manual MCP Server implementation, refer to the [MCP Server Java SDK documentation](/sdk/java/mcp-server).

    ### System requirements

    * Java 17 or higher installed.
    * [Spring Boot 3.3.x](https://docs.spring.io/spring-boot/installing.html) or higher

    ### Set up your environment

    Use the [Spring Initizer](https://start.spring.io/) to bootstrat the project.

    You will need to add the following dependencies:

    <Tabs>
      <Tab title="Maven">
        ```xml
        <dependencies>
              <dependency>
                  <groupId>org.springframework.ai</groupId>
                  <artifactId>spring-ai-mcp-server-spring-boot-starter</artifactId>
              </dependency>

              <dependency>
                  <groupId>org.springframework</groupId>
                  <artifactId>spring-web</artifactId>
              </dependency>
        </dependencies>
        ```
      </Tab>

      <Tab title="Gradle">
        ```groovy
        dependencies {
          implementation platform("org.springframework.ai:spring-ai-mcp-server-spring-boot-starter")
          implementation platform("org.springframework:spring-web")   
        }
        ```
      </Tab>
    </Tabs>

    Then configure your application by setting the applicaiton properties:

    <CodeGroup>
      ```bash application.properties
      spring.main.bannerMode=off
      logging.pattern.console=
      ```

      ```yaml application.yml
      logging:
        pattern:
          console:
      spring:
        main:
          banner-mode: off
      ```
    </CodeGroup>

    The [Server Configuration Properties](https://docs.spring.io/spring-ai/reference/api/mcp/mcp-server-boot-starter-docs.html#_configuration_properties) documents all available properties.

    Now let's dive into building your server.

    ## Building your server

    ### Weather Service

    Let's implement a [WeatheService.java](https://github.com/spring-projects/spring-ai-examples/blob/main/model-context-protocol/weather/starter-stdio-server/src/main/java/org/springframework/ai/mcp/sample/server/WeatherService.java) that uses a REST client to query the data from the National Weather Service API:

    ```java
    @Service
    public class WeatherService {

    	private final RestClient restClient;

    	public WeatherService() {
    		this.restClient = RestClient.builder()
    			.baseUrl("https://api.weather.gov")
    			.defaultHeader("Accept", "application/geo+json")
    			.defaultHeader("User-Agent", "WeatherApiClient/1.0 (your@email.com)")
    			.build();
    	}

      @Tool(description = "Get weather forecast for a specific latitude/longitude")
      public String getWeatherForecastByLocation(
          double latitude,   // Latitude coordinate
          double longitude   // Longitude coordinate
      ) {
          // Returns detailed forecast including:
          // - Temperature and unit
          // - Wind speed and direction
          // - Detailed forecast description
      }
    	
      @Tool(description = "Get weather alerts for a US state")
      public String getAlerts(
          @ToolParam(description = "Two-letter US state code (e.g. CA, NY") String state)
      ) {
          // Returns active alerts including:
          // - Event type
          // - Affected area
          // - Severity
          // - Description
          // - Safety instructions
      }

      // ......
    }
    ```

    The `@Service` annotation with auto-register the service in your applicaiton context.
    The Spring AI `@Tool` annotation, making it easy to create and maintain MCP tools.

    The auto-configuration will automatically register these tools with the MCP server.

    ### Create your Boot Applicaiton

    ```java
    @SpringBootApplication
    public class McpServerApplication {

    	public static void main(String[] args) {
    		SpringApplication.run(McpServerApplication.class, args);
    	}

    	@Bean
    	public ToolCallbackProvider weatherTools(WeatherService weatherService) {
    		return  MethodToolCallbackProvider.builder().toolObjects(weatherService).build();
    	}
    }
    ```

    Uses the the `MethodToolCallbackProvider` utils to convert the `@Tools` into actionalble callbackes used by the MCP server.

    ### Running the server

    Finally, let's build the server:

    ```bash
    ./mvnw clean install
    ```

    This will generate a `mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar` file within the `target` folder.

    Let's now test your server from an existing MCP host, Claude for Desktop.

    ## Testing your server with Claude for Desktop

    <Note>
      Claude for Desktop is not yet available on Linux.
    </Note>

    First, make sure you have Claude for Desktop installed.
    [You can install the latest version here.](https://claude.ai/download) If you already have Claude for Desktop, **make sure it's updated to the latest version.**

    We'll need to configure Claude for Desktop for whichever MCP servers you want to use.
    To do this, open your Claude for Desktop App configuration at `~/Library/Application Support/Claude/claude_desktop_config.json` in a text editor.
    Make sure to create the file if it doesn't exist.

    For example, if you have [VS Code](https://code.visualstudio.com/) installed:

    <Tabs>
      <Tab title="MacOS/Linux">
        ```bash
        code ~/Library/Application\ Support/Claude/claude_desktop_config.json
        ```
      </Tab>

      <Tab title="Windows">
        ```powershell
        code $env:AppData\Claude\claude_desktop_config.json
        ```
      </Tab>
    </Tabs>

    You'll then add your servers in the `mcpServers` key.
    The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.

    In this case, we'll add our single weather server like so:

    <Tabs>
      <Tab title="MacOS/Linux">
        ```json java
        {
          "mcpServers": {
            "spring-ai-mcp-weather": {
              "command": "java",
              "args": [
                "-Dspring.ai.mcp.server.stdio=true",
                "-jar",
                "/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar"
              ]
            }
          }
        }
        ```
      </Tab>

      <Tab title="Windows">
        ```json java
        {
          "mcpServers": {
            "spring-ai-mcp-weather": {
              "command": "java",
              "args": [
                "-Dspring.ai.mcp.server.transport=STDIO",
                "-jar",
                "C:\\ABSOLUTE\\PATH\\TO\\PARENT\\FOLDER\\weather\\mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar"
              ]
            }
          }
        }
        ```
      </Tab>
    </Tabs>

    <Note>
      Make sure you pass in the absolute path to your server.
    </Note>

    This tells Claude for Desktop:

    1. There's an MCP server named "my-weather-server"
    2. To launch it by running `java -jar /ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar`

    Save the file, and restart **Claude for Desktop**.

    ## Testing your server with Java client

    ### Create a MCP Client manually

    Use the `McpClient` to connect to the server:

    ```java
    var stdioParams = ServerParameters.builder("java")
      .args("-jar", "/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar")
      .build();

    var stdioTransport = new StdioClientTransport(stdioParams);

    var mcpClient = McpClient.sync(stdioTransport).build();

    mcpClient.initialize();

    ListToolsResult toolsList = mcpClient.listTools();

    CallToolResult weather = mcpClient.callTool(
      new CallToolRequest("getWeatherForecastByLocation",
          Map.of("latitude", "47.6062", "longitude", "-122.3321")));

    CallToolResult alert = mcpClient.callTool(
      new CallToolRequest("getAlerts", Map.of("state", "NY")));

    mcpClient.closeGracefully();
    ```

    ### Use MCP Client Boot Starter

    Create a new boot starter applicaiton using the `spring-ai-mcp-client-spring-boot-starter` dependency:

    ```xml
    <dependency>
        <groupId>org.springframework.ai</groupId>
        <artifactId>spring-ai-mcp-client-spring-boot-starter</artifactId>
    </dependency>
    ```

    and set the `spring.ai.mcp.client.stdio.servers-configuration` property to point to your `claude_desktop_config.json`.
    You can re-use the existing Anthropic Destop configuration:

    ```properties
    spring.ai.mcp.client.stdio.servers-configuration=file:PATH/TO/claude_desktop_config.json
    ```

    When you stasrt your client applicaiton, the auto-configuration will create, automatically MCP clients from the claude\_desktop\_config.json.

    For more information, see the [MCP Client Boot Starters](https://docs.spring.io/spring-ai/reference/api/mcp/mcp-server-boot-client-docs.html) reference documentation.

    ## More Java MCP Server examples

    The [starter-webflux-server](https://github.com/spring-projects/spring-ai-examples/tree/main/model-context-protocol/weather/starter-webflux-server) demonstrates how to create a MCP server using SSE transport.
    It showcases how to define and register MCP Tools, Resources, and Prompts, using the Spring Boot's auto-configuration capabilities.
  </Tab>
</Tabs>

### Test with commands

Let's make sure Claude for Desktop is picking up the two tools we've exposed in our `weather` server. You can do this by looking for the hammer <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/claude-desktop-mcp-hammer-icon.svg" style={{display: 'inline', margin: 0, height: '1.3em'}} /> icon:

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/visual-indicator-mcp-tools.png" />
</Frame>

After clicking on the hammer icon, you should see two tools listed:

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/available-mcp-tools.png" />
</Frame>

If your server isn't being picked up by Claude for Desktop, proceed to the [Troubleshooting](#troubleshooting) section for debugging tips.

If the hammer icon has shown up, you can now test your server by running the following commands in Claude for Desktop:

* What's the weather in Sacramento?
* What are the active weather alerts in Texas?

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/current-weather.png" />
</Frame>

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/weather-alerts.png" />
</Frame>

<Note>
  Since this is the US National Weather service, the queries will only work for US locations.
</Note>

## What's happening under the hood

When you ask a question:

1. The client sends your question to Claude
2. Claude analyzes the available tools and decides which one(s) to use
3. The client executes the chosen tool(s) through the MCP server
4. The results are sent back to Claude
5. Claude formulates a natural language response
6. The response is displayed to you!

## Troubleshooting

<AccordionGroup>
  <Accordion title="Claude for Desktop Integration Issues">
    **Getting logs from Claude for Desktop**

    Claude.app logging related to MCP is written to log files in `~/Library/Logs/Claude`:

    * `mcp.log` will contain general logging about MCP connections and connection failures.
    * Files named `mcp-server-SERVERNAME.log` will contain error (stderr) logging from the named server.

    You can run the following command to list recent logs and follow along with any new ones:

    ```bash
    # Check Claude's logs for errors
    tail -n 20 -f ~/Library/Logs/Claude/mcp*.log
    ```

    **Server not showing up in Claude**

    1. Check your `claude_desktop_config.json` file syntax
    2. Make sure the path to your project is absolute and not relative
    3. Restart Claude for Desktop completely

    **Tool calls failing silently**

    If Claude attempts to use the tools but they fail:

    1. Check Claude's logs for errors
    2. Verify your server builds and runs without errors
    3. Try restarting Claude for Desktop

    **None of this is working. What do I do?**

    Please refer to our [debugging guide](/docs/tools/debugging) for better debugging tools and more detailed guidance.
  </Accordion>

  <Accordion title="Weather API Issues">
    **Error: Failed to retrieve grid point data**

    This usually means either:

    1. The coordinates are outside the US
    2. The NWS API is having issues
    3. You're being rate limited

    Fix:

    * Verify you're using US coordinates
    * Add a small delay between requests
    * Check the NWS API status page

    **Error: No active alerts for \[STATE]**

    This isn't an error - it just means there are no current weather alerts for that state. Try a different state or check during severe weather.
  </Accordion>
</AccordionGroup>

<Note>
  For more advanced troubleshooting, check out our guide on [Debugging MCP](/docs/tools/debugging)
</Note>

## Next steps

<CardGroup cols={2}>
  <Card title="Building a client" icon="outlet" href="/quickstart/client">
    Learn how to build your own MCP client that can connect to your server
  </Card>

  <Card title="Example servers" icon="grid" href="/examples">
    Check out our gallery of official MCP servers and implementations
  </Card>

  <Card title="Debugging Guide" icon="bug" href="/docs/tools/debugging">
    Learn how to effectively debug MCP servers and integrations
  </Card>

  <Card title="Building MCP with LLMs" icon="comments" href="/building-mcp-with-llms">
    Learn how to use LLMs like Claude to speed up your MCP development
  </Card>
</CardGroup>


# For Claude Desktop Users
Source: https://modelcontextprotocol.io/quickstart/user

Get started using pre-built servers in Claude for Desktop.

In this tutorial, you will extend [Claude for Desktop](https://claude.ai/download) so that it can read from your computer's file system, write new files, move files, and even search files.

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/quickstart-filesystem.png" />
</Frame>

Don't worry  it will ask you for your permission before executing these actions!

## 1. Download Claude for Desktop

Start by downloading [Claude for Desktop](https://claude.ai/download), choosing either macOS or Windows. (Linux is not yet supported for Claude for Desktop.)

Follow the installation instructions.

If you already have Claude for Desktop, make sure it's on the latest version by clicking on the Claude menu on your computer and selecting "Check for Updates..."

<Accordion title="Why Claude for Desktop and not Claude.ai?">
  Because servers are locally run, MCP currently only supports desktop hosts. Remote hosts are in active development.
</Accordion>

## 2. Add the Filesystem MCP Server

To add this filesystem functionality, we will be installing a pre-built [Filesystem MCP Server](https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem) to Claude for Desktop. This is one of dozens of [servers](https://github.com/modelcontextprotocol/servers/tree/main) created by Anthropic and the community.

Get started by opening up the Claude menu on your computer and select "Settings..." Please note that these are not the Claude Account Settings found in the app window itself.

This is what it should look like on a Mac:

<Frame style={{ textAlign: 'center' }}>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/quickstart-menu.png" width="400" />
</Frame>

Click on "Developer" in the lefthand bar of the Settings pane, and then click on "Edit Config":

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/quickstart-developer.png" />
</Frame>

This will create a configuration file at:

* macOS: `~/Library/Application Support/Claude/claude_desktop_config.json`
* Windows: `%APPDATA%\Claude\claude_desktop_config.json`

if you don't already have one, and will display the file in your file system.

Open up the configuration file in any text editor. Replace the file contents with this:

<Tabs>
  <Tab title="MacOS/Linux">
    ```json
    {
      "mcpServers": {
        "filesystem": {
          "command": "npx",
          "args": [
            "-y",
            "@modelcontextprotocol/server-filesystem",
            "/Users/username/Desktop",
            "/Users/username/Downloads"
          ]
        }
      }
    }
    ```
  </Tab>

  <Tab title="Windows">
    ```json
    {
      "mcpServers": {
        "filesystem": {
          "command": "npx",
          "args": [
            "-y",
            "@modelcontextprotocol/server-filesystem",
            "C:\\Users\\username\\Desktop",
            "C:\\Users\\username\\Downloads"
          ]
        }
      }
    }
    ```
  </Tab>
</Tabs>

Make sure to replace `username` with your computer's username. The paths should point to valid directories that you want Claude to be able to access and modify. It's set up to work for Desktop and Downloads, but you can add more paths as well.

You will also need [Node.js](https://nodejs.org) on your computer for this to run properly. To verify you have Node installed, open the command line on your computer.

* On macOS, open the Terminal from your Applications folder
* On Windows, press Windows + R, type "cmd", and press Enter

Once in the command line, verify you have Node installed by entering in the following command:

```bash
node --version
```

If you get an error saying "command not found" or "node is not recognized", download Node from [nodejs.org](https://nodejs.org/).

<Tip>
  **How does the configuration file work?**

  This configuration file tells Claude for Desktop which MCP servers to start up every time you start the application. In this case, we have added one server called "filesystem" that will use the Node `npx` command to install and run `@modelcontextprotocol/server-filesystem`. This server, described [here](https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem), will let you access your file system in Claude for Desktop.
</Tip>

<Warning>
  **Command Privileges**

  Claude for Desktop will run the commands in the configuration file with the permissions of your user account, and access to your local files. Only add commands if you understand and trust the source.
</Warning>

## 3. Restart Claude

After updating your configuration file, you need to restart Claude for Desktop.

Upon restarting, you should see a hammer <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/claude-desktop-mcp-hammer-icon.svg" style={{display: 'inline', margin: 0, height: '1.3em'}} /> icon in the bottom right corner of the input box:

<Frame>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/quickstart-hammer.png" />
</Frame>

After clicking on the hammer icon, you should see the tools that come with the Filesystem MCP Server:

<Frame style={{ textAlign: 'center' }}>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/quickstart-tools.png" width="400" />
</Frame>

If your server isn't being picked up by Claude for Desktop, proceed to the [Troubleshooting](#troubleshooting) section for debugging tips.

## 4. Try it out!

You can now talk to Claude and ask it about your filesystem. It should know when to call the relevant tools.

Things you might try asking Claude:

* Can you write a poem and save it to my desktop?
* What are some work-related files in my downloads folder?
* Can you take all the images on my desktop and move them to a new folder called "Images"?

As needed, Claude will call the relevant tools and seek your approval before taking an action:

<Frame style={{ textAlign: 'center' }}>
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/quickstart-approve.png" width="500" />
</Frame>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Server not showing up in Claude / hammer icon missing">
    1. Restart Claude for Desktop completely
    2. Check your `claude_desktop_config.json` file syntax
    3. Make sure the file paths included in `claude_desktop_config.json` are valid and that they are absolute and not relative
    4. Look at [logs](#getting-logs-from-claude-for-desktop) to see why the server is not connecting
    5. In your command line, try manually running the server (replacing `username` as you did in `claude_desktop_config.json`) to see if you get any errors:

    <Tabs>
      <Tab title="MacOS/Linux">
        ```bash
        npx -y @modelcontextprotocol/server-filesystem /Users/username/Desktop /Users/username/Downloads
        ```
      </Tab>

      <Tab title="Windows">
        ```bash
        npx -y @modelcontextprotocol/server-filesystem C:\Users\username\Desktop C:\Users\username\Downloads
        ```
      </Tab>
    </Tabs>
  </Accordion>

  <Accordion title="Getting logs from Claude for Desktop">
    Claude.app logging related to MCP is written to log files in:

    * macOS: `~/Library/Logs/Claude`

    * Windows: `%APPDATA%\Claude\logs`

    * `mcp.log` will contain general logging about MCP connections and connection failures.

    * Files named `mcp-server-SERVERNAME.log` will contain error (stderr) logging from the named server.

    You can run the following command to list recent logs and follow along with any new ones (on Windows, it will only show recent logs):

    <Tabs>
      <Tab title="MacOS/Linux">
        ```bash
        # Check Claude's logs for errors
        tail -n 20 -f ~/Library/Logs/Claude/mcp*.log
        ```
      </Tab>

      <Tab title="Windows">
        ```bash
        type "%APPDATA%\Claude\logs\mcp*.log"
        ```
      </Tab>
    </Tabs>
  </Accordion>

  <Accordion title="Tool calls failing silently">
    If Claude attempts to use the tools but they fail:

    1. Check Claude's logs for errors
    2. Verify your server builds and runs without errors
    3. Try restarting Claude for Desktop
  </Accordion>

  <Accordion title="None of this is working. What do I do?">
    Please refer to our [debugging guide](/docs/tools/debugging) for better debugging tools and more detailed guidance.
  </Accordion>

  <Accordion title="ENOENT error and `${APPDATA}` in paths on Windows">
    If your configured server fails to load, and you see within its logs an error referring to `${APPDATA}` within a path, you may need to add the expanded value of `%APPDATA%` to your `env` key in `claude_desktop_config.json`:

    ```json
    {
      "brave-search": {
        "command": "npx",
        "args": ["-y", "@modelcontextprotocol/server-brave-search"],
        "env": {
          "APPDATA": "C:\\Users\\user\\AppData\\Roaming\\",
          "BRAVE_API_KEY": "..."
        }
      }
    }
    ```

    With this change in place, launch Claude Desktop once again.

    <Warning>
      **NPM should be installed globally**

      The `npx` command may continue to fail if you have not installed NPM globally. If NPM is already installed globally, you will find `%APPDATA%\npm` exists on your system. If not, you can install NPM globally by running the following command:

      ```bash
      npm install -g npm
      ```
    </Warning>
  </Accordion>
</AccordionGroup>

## Next steps

<CardGroup cols={2}>
  <Card title="Explore other servers" icon="grid" href="/examples">
    Check out our gallery of official MCP servers and implementations
  </Card>

  <Card title="Build your own server" icon="code" href="/quickstart/server">
    Now build your own custom server to use in Claude for Desktop and other clients
  </Card>
</CardGroup>


# MCP Client
Source: https://modelcontextprotocol.io/sdk/java/mcp-client

Learn how to use the Model Context Protocol (MCP) client to interact with MCP servers

# Model Context Protocol Client

The MCP Client is a key component in the Model Context Protocol (MCP) architecture, responsible for establishing and managing connections with MCP servers. It implements the client-side of the protocol, handling:

* Protocol version negotiation to ensure compatibility with servers
* Capability negotiation to determine available features
* Message transport and JSON-RPC communication
* Tool discovery and execution
* Resource access and management
* Prompt system interactions
* Optional features like roots management and sampling support

The client provides both synchronous and asynchronous APIs for flexibility in different application contexts.

<Tabs>
  <Tab title="Sync API">
    ```java
    // Create a sync client with custom configuration
    McpSyncClient client = McpClient.sync(transport)
        .requestTimeout(Duration.ofSeconds(10))
        .capabilities(ClientCapabilities.builder()
            .roots(true)      // Enable roots capability
            .sampling()       // Enable sampling capability
            .build())
        .sampling(request -> new CreateMessageResult(response))
        .build();

    // Initialize connection
    client.initialize();

    // List available tools
    ListToolsResult tools = client.listTools();

    // Call a tool
    CallToolResult result = client.callTool(
        new CallToolRequest("calculator", 
            Map.of("operation", "add", "a", 2, "b", 3))
    );

    // List and read resources
    ListResourcesResult resources = client.listResources();
    ReadResourceResult resource = client.readResource(
        new ReadResourceRequest("resource://uri")
    );

    // List and use prompts
    ListPromptsResult prompts = client.listPrompts();
    GetPromptResult prompt = client.getPrompt(
        new GetPromptRequest("greeting", Map.of("name", "Spring"))
    );

    // Add/remove roots
    client.addRoot(new Root("file:///path", "description"));
    client.removeRoot("file:///path");

    // Close client
    client.closeGracefully();
    ```
  </Tab>

  <Tab title="Async API">
    ```java
    // Create an async client with custom configuration
    McpAsyncClient client = McpClient.async(transport)
        .requestTimeout(Duration.ofSeconds(10))
        .capabilities(ClientCapabilities.builder()
            .roots(true)      // Enable roots capability
            .sampling()       // Enable sampling capability
            .build())
        .sampling(request -> Mono.just(new CreateMessageResult(response)))
        .toolsChangeConsumer(tools -> Mono.fromRunnable(() -> {
            logger.info("Tools updated: {}", tools);
        }))
        .resourcesChangeConsumer(resources -> Mono.fromRunnable(() -> {
            logger.info("Resources updated: {}", resources);
        }))
        .promptsChangeConsumer(prompts -> Mono.fromRunnable(() -> {
            logger.info("Prompts updated: {}", prompts);
        }))
        .build();

    // Initialize connection and use features
    client.initialize()
        .flatMap(initResult -> client.listTools())
        .flatMap(tools -> {
            return client.callTool(new CallToolRequest(
                "calculator", 
                Map.of("operation", "add", "a", 2, "b", 3)
            ));
        })
        .flatMap(result -> {
            return client.listResources()
                .flatMap(resources -> 
                    client.readResource(new ReadResourceRequest("resource://uri"))
                );
        })
        .flatMap(resource -> {
            return client.listPrompts()
                .flatMap(prompts ->
                    client.getPrompt(new GetPromptRequest(
                        "greeting", 
                        Map.of("name", "Spring")
                    ))
                );
        })
        .flatMap(prompt -> {
            return client.addRoot(new Root("file:///path", "description"))
                .then(client.removeRoot("file:///path"));            
        })
        .doFinally(signalType -> {
            client.closeGracefully().subscribe();
        })
        .subscribe();
    ```
  </Tab>
</Tabs>

## Client Transport

The transport layer handles the communication between MCP clients and servers, providing different implementations for various use cases. The client transport manages message serialization, connection establishment, and protocol-specific communication patterns.

<Tabs>
  <Tab title="STDIO">
    Creates transport for in-process based communication

    ```java
    ServerParameters params = ServerParameters.builder("npx")
        .args("-y", "@modelcontextprotocol/server-everything", "dir")
        .build();
    McpTransport transport = new StdioClientTransport(params);
    ```
  </Tab>

  <Tab title="SSE (HttpClient)">
    Creates a framework agnostic (pure Java API) SSE client transport. Included in the core mcp module.

    ```java
    McpTransport transport = new HttpClientSseClientTransport("http://your-mcp-server");
    ```
  </Tab>

  <Tab title="SSE (WebFlux)">
    Creates WebFlux-based SSE client transport. Requires the mcp-webflux-sse-transport dependency.

    ```java
    WebClient.Builder webClientBuilder = WebClient.builder()
        .baseUrl("http://your-mcp-server");
    McpTransport transport = new WebFluxSseClientTransport(webClientBuilder);
    ```
  </Tab>
</Tabs>

## Client Capabilities

The client can be configured with various capabilities:

```java
var capabilities = ClientCapabilities.builder()
    .roots(true)      // Enable filesystem roots support with list changes notifications
    .sampling()       // Enable LLM sampling support
    .build();
```

### Roots Support

Roots define the boundaries of where servers can operate within the filesystem:

```java
// Add a root dynamically
client.addRoot(new Root("file:///path", "description"));

// Remove a root
client.removeRoot("file:///path");

// Notify server of roots changes
client.rootsListChangedNotification();
```

The roots capability allows servers to:

* Request the list of accessible filesystem roots
* Receive notifications when the roots list changes
* Understand which directories and files they have access to

### Sampling Support

Sampling enables servers to request LLM interactions ("completions" or "generations") through the client:

```java
// Configure sampling handler
Function<CreateMessageRequest, CreateMessageResult> samplingHandler = request -> {
    // Sampling implementation that interfaces with LLM
    return new CreateMessageResult(response);
};

// Create client with sampling support
var client = McpClient.sync(transport)
    .capabilities(ClientCapabilities.builder()
        .sampling()
        .build())
    .sampling(samplingHandler)
    .build();
```

This capability allows:

* Servers to leverage AI capabilities without requiring API keys
* Clients to maintain control over model access and permissions
* Support for both text and image-based interactions
* Optional inclusion of MCP server context in prompts

## Using MCP Clients

### Tool Execution

Tools are server-side functions that clients can discover and execute. The MCP client provides methods to list available tools and execute them with specific parameters. Each tool has a unique name and accepts a map of parameters.

<Tabs>
  <Tab title="Sync API">
    ```java
    // List available tools and their names
    var tools = client.listTools();
    tools.forEach(tool -> System.out.println(tool.getName()));

    // Execute a tool with parameters
    var result = client.callTool("calculator", Map.of(
        "operation", "add",
        "a", 1,
        "b", 2
    ));
    ```
  </Tab>

  <Tab title="Async API">
    ```java
    // List available tools asynchronously
    client.listTools()
        .doOnNext(tools -> tools.forEach(tool -> 
            System.out.println(tool.getName())))
        .subscribe();

    // Execute a tool asynchronously
    client.callTool("calculator", Map.of(
            "operation", "add",
            "a", 1,
            "b", 2
        ))
        .subscribe();
    ```
  </Tab>
</Tabs>

### Resource Access

Resources represent server-side data sources that clients can access using URI templates. The MCP client provides methods to discover available resources and retrieve their contents through a standardized interface.

<Tabs>
  <Tab title="Sync API">
    ```java
    // List available resources and their names
    var resources = client.listResources();
    resources.forEach(resource -> System.out.println(resource.getName()));

    // Retrieve resource content using a URI template
    var content = client.getResource("file", Map.of(
        "path", "/path/to/file.txt"
    ));
    ```
  </Tab>

  <Tab title="Async API">
    ```java
    // List available resources asynchronously
    client.listResources()
        .doOnNext(resources -> resources.forEach(resource -> 
            System.out.println(resource.getName())))
        .subscribe();

    // Retrieve resource content asynchronously
    client.getResource("file", Map.of(
            "path", "/path/to/file.txt"
        ))
        .subscribe();
    ```
  </Tab>
</Tabs>

### Prompt System

The prompt system enables interaction with server-side prompt templates. These templates can be discovered and executed with custom parameters, allowing for dynamic text generation based on predefined patterns.

<Tabs>
  <Tab title="Sync API">
    ```java
    // List available prompt templates
    var prompts = client.listPrompts();
    prompts.forEach(prompt -> System.out.println(prompt.getName()));

    // Execute a prompt template with parameters
    var response = client.executePrompt("echo", Map.of(
        "text", "Hello, World!"
    ));
    ```
  </Tab>

  <Tab title="Async API">
    ```java
    // List available prompt templates asynchronously
    client.listPrompts()
        .doOnNext(prompts -> prompts.forEach(prompt -> 
            System.out.println(prompt.getName())))
        .subscribe();

    // Execute a prompt template asynchronously
    client.executePrompt("echo", Map.of(
            "text", "Hello, World!"
        ))
        .subscribe();
    ```
  </Tab>
</Tabs>


# Overview
Source: https://modelcontextprotocol.io/sdk/java/mcp-overview

Introduction to the Model Context Protocol (MCP) Java SDK

Java SDK for the [Model Context Protocol](https://modelcontextprotocol.org/docs/concepts/architecture)
enables standardized integration between AI models and tools.

## Features

* MCP Client and MCP Server implementations supporting:
  * Protocol [version compatibility negotiation](https://spec.modelcontextprotocol.io/specification/2024-11-05/basic/lifecycle/#initialization)
  * [Tool](https://spec.modelcontextprotocol.io/specification/2024-11-05/server/tools/) discovery, execution, list change notifications
  * [Resource](https://spec.modelcontextprotocol.io/specification/2024-11-05/server/resources/) management with URI templates
  * [Roots](https://spec.modelcontextprotocol.io/specification/2024-11-05/client/roots/) list management and notifications
  * [Prompt](https://spec.modelcontextprotocol.io/specification/2024-11-05/server/prompts/) handling and management
  * [Sampling](https://spec.modelcontextprotocol.io/specification/2024-11-05/client/sampling/) support for AI model interactions
* Multiple transport implementations:
  * Default transports:
    * Stdio-based transport for process-based communication
    * Java HttpClient-based SSE client transport for HTTP SSE Client-side streaming
    * Servlet-based SSE server transport for HTTP SSE Server streaming
  * Spring-based transports:
    * WebFlux SSE client and server transports for reactive HTTP streaming
    * WebMVC SSE transport for servlet-based HTTP streaming
* Supports Synchronous and Asynchronous programming paradigms

## Architecture

The SDK follows a layered architecture with clear separation of concerns:

![MCP Stack Architecture](https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/java/mcp-stack.svg)

* **Client/Server Layer (McpClient/McpServer)**: Both use McpSession for sync/async operations,
  with McpClient handling client-side protocol operations and McpServer managing server-side protocol operations.
* **Session Layer (McpSession)**: Manages communication patterns and state using DefaultMcpSession implementation.
* **Transport Layer (McpTransport)**: Handles JSON-RPC message serialization/deserialization via:
  * StdioTransport (stdin/stdout) in the core module
  * HTTP SSE transports in dedicated transport modules (Java HttpClient, Spring WebFlux, Spring WebMVC)

The MCP Client is a key component in the Model Context Protocol (MCP) architecture, responsible for establishing and managing connections with MCP servers.
It implements the client-side of the protocol.

![Java MCP Client Architecture](https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/java/java-mcp-client-architecture.jpg)

The MCP Server is a foundational component in the Model Context Protocol (MCP) architecture that provides tools, resources, and capabilities to clients.
It implements the server-side of the protocol.

![Java MCP Server Architecture](https://mintlify.s3.us-west-1.amazonaws.com/mcp/images/java/java-mcp-server-architecture.jpg)

Key Interactions:

* **Client/Server Initialization**: Transport setup, protocol compatibility check, capability negotiation, and implementation details exchange.
* **Message Flow**: JSON-RPC message handling with validation, type-safe response processing, and error handling.
* **Resource Management**: Resource discovery, URI template-based access, subscription system, and content retrieval.

## Dependencies

Add the following Maven dependency to your project:

<Tabs>
  <Tab title="Maven">
    The core MCP functionality:

    ```xml
    <dependency>
        <groupId>io.modelcontextprotocol.sdk</groupId>
        <artifactId>mcp</artifactId>
    </dependency>
    ```

    For HTTP SSE transport implementations, add one of the following dependencies:

    ```xml
    <!-- Spring WebFlux-based SSE client and server transport -->
    <dependency>
        <groupId>io.modelcontextprotocol.sdk</groupId>
        <artifactId>mcp-spring-webflux</artifactId>
    </dependency>

    <!-- Spring WebMVC-based SSE server transport -->
    <dependency>
        <groupId>io.modelcontextprotocol.sdk</groupId>
        <artifactId>mcp-spring-webmvc</artifactId>
    </dependency>
    ```
  </Tab>

  <Tab title="Gradle">
    The core MCP functionality:

    ```groovy
    dependencies {
      implementation platform("io.modelcontextprotocol.sdk:mcp")
      //...
    }
    ```

    For HTTP SSE transport implementations, add one of the following dependencies:

    ```groovy
    // Spring WebFlux-based SSE client and server transport
    dependencies {
      implementation platform("io.modelcontextprotocol.sdk:mcp-spring-webflux")
    }

    // Spring WebMVC-based SSE server transport
    dependencies {
      implementation platform("io.modelcontextprotocol.sdk:mcp-spring-webmvc")
    }
    ```
  </Tab>
</Tabs>

### Bill of Materials (BOM)

The Bill of Materials (BOM) declares the recommended versions of all the dependencies used by a given release.
Using the BOM from your application's build script avoids the need for you to specify and maintain the dependency versions yourself.
Instead, the version of the BOM you're using determines the utilized dependency versions.
It also ensures that you're using supported and tested versions of the dependencies by default, unless you choose to override them.

Add the BOM to your project:

<Tabs>
  <Tab title="Maven">
    ```xml
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>io.modelcontextprotocol.sdk</groupId>
                <artifactId>mcp-bom</artifactId>
                <version>0.7.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    ```
  </Tab>

  <Tab title="Gradle">
    ```groovy
    dependencies {
      implementation platform("io.modelcontextprotocol.sdk:mcp-bom:0.7.0")
      //...
    }
    ```

    Gradle users can also use the Spring AI MCP BOM by leveraging Gradle (5.0+) native support for declaring dependency constraints using a Maven BOM.
    This is implemented by adding a 'platform' dependency handler method to the dependencies section of your Gradle build script.
    As shown in the snippet above this can then be followed by version-less declarations of the Starter Dependencies for the one or more spring-ai modules you wish to use, e.g. spring-ai-openai.
  </Tab>
</Tabs>

Replace the version number with the version of the BOM you want to use.

### Available Dependencies

The following dependencies are available and managed by the BOM:

* Core Dependencies
  * `io.modelcontextprotocol.sdk:mcp` - Core MCP library providing the base functionality and APIs for Model Context Protocol implementation.
* Transport Dependencies
  * `io.modelcontextprotocol.sdk:mcp-spring-webflux` - WebFlux-based Server-Sent Events (SSE) transport implementation for reactive applications.
  * `io.modelcontextprotocol.sdk:mcp-spring-webmvc` - WebMVC-based Server-Sent Events (SSE) transport implementation for servlet-based applications.
* Testing Dependencies
  * `io.modelcontextprotocol.sdk:mcp-test` - Testing utilities and support for MCP-based applications.


# MCP Server
Source: https://modelcontextprotocol.io/sdk/java/mcp-server

Learn how to implement and configure a Model Context Protocol (MCP) server

## Overview

The MCP Server is a foundational component in the Model Context Protocol (MCP) architecture that provides tools, resources, and capabilities to clients. It implements the server-side of the protocol, responsible for:

* Exposing tools that clients can discover and execute
* Managing resources with URI-based access patterns
* Providing prompt templates and handling prompt requests
* Supporting capability negotiation with clients
* Implementing server-side protocol operations
* Managing concurrent client connections
* Providing structured logging and notifications

The server supports both synchronous and asynchronous APIs, allowing for flexible integration in different application contexts.

<Tabs>
  <Tab title="Sync API">
    ```java
    // Create a server with custom configuration
    McpSyncServer syncServer = McpServer.sync(transport)
        .serverInfo("my-server", "1.0.0")
        .capabilities(ServerCapabilities.builder()
            .resources(true)     // Enable resource support
            .tools(true)         // Enable tool support
            .prompts(true)       // Enable prompt support
            .logging()           // Enable logging support
            .build())
        .build();

    // Register tools, resources, and prompts
    syncServer.addTool(syncToolRegistration);
    syncServer.addResource(syncResourceRegistration);
    syncServer.addPrompt(syncPromptRegistration);

    // Send logging notifications
    syncServer.loggingNotification(LoggingMessageNotification.builder()
        .level(LoggingLevel.INFO)
        .logger("custom-logger")
        .data("Server initialized")
        .build());

    // Close the server when done
    syncServer.close();
    ```
  </Tab>

  <Tab title="Async API">
    ```java
    // Create an async server with custom configuration
    McpAsyncServer asyncServer = McpServer.async(transport)
        .serverInfo("my-server", "1.0.0")
        .capabilities(ServerCapabilities.builder()
            .resources(true)     // Enable resource support
            .tools(true)         // Enable tool support
            .prompts(true)       // Enable prompt support
            .logging()           // Enable logging support
            .build())
        .build();

    // Register tools, resources, and prompts
    asyncServer.addTool(asyncToolRegistration)
        .doOnSuccess(v -> logger.info("Tool registered"))
        .subscribe();

    asyncServer.addResource(asyncResourceRegistration)
        .doOnSuccess(v -> logger.info("Resource registered"))
        .subscribe();

    asyncServer.addPrompt(asyncPromptRegistration)
        .doOnSuccess(v -> logger.info("Prompt registered"))
        .subscribe();

    // Send logging notifications
    asyncServer.loggingNotification(LoggingMessageNotification.builder()
        .level(LoggingLevel.INFO)
        .logger("custom-logger")
        .data("Server initialized")
        .build());

    // Close the server when done
    asyncServer.close()
        .doOnSuccess(v -> logger.info("Server closed"))
        .subscribe();
    ```
  </Tab>
</Tabs>

## Server Transport

The transport layer in the MCP SDK is responsible for handling the communication between clients and servers. It provides different implementations to support various communication protocols and patterns. The SDK includes several built-in transport implementations:

<Tabs>
  <Tab title="STDIO">
    <>
      Create in-process based transport:

      ```java
      StdioServerTransport transport = new StdioServerTransport(new ObjectMapper());
      ```

      Provides bidirectional JSON-RPC message handling over standard input/output streams with non-blocking message processing, serialization/deserialization, and graceful shutdown support.

      Key features:

      <ul>
        <li>Bidirectional communication through stdin/stdout</li>
        <li>Process-based integration support</li>
        <li>Simple setup and configuration</li>
        <li>Lightweight implementation</li>
      </ul>
    </>
  </Tab>

  <Tab title="SSE (WebFlux)">
    <>
      <p>Creates WebFlux-based SSE server transport.<br />Requires the <code>mcp-spring-webflux</code> dependency.</p>

      ```java
      @Configuration
      class McpConfig {
          @Bean
          WebFluxSseServerTransport webFluxSseServerTransport(ObjectMapper mapper) {
              return new WebFluxSseServerTransport(mapper, "/mcp/message");
          }

          @Bean
          RouterFunction<?> mcpRouterFunction(WebFluxSseServerTransport transport) {
              return transport.getRouterFunction();
          }
      }
      ```

      <p>Implements the MCP HTTP with SSE transport specification, providing:</p>

      <ul>
        <li>Reactive HTTP streaming with WebFlux</li>
        <li>Concurrent client connections through SSE endpoints</li>
        <li>Message routing and session management</li>
        <li>Graceful shutdown capabilities</li>
      </ul>
    </>
  </Tab>

  <Tab title="SSE (WebMvc)">
    <>
      <p>Creates WebMvc-based SSE server transport.<br />Requires the <code>mcp-spring-webmvc</code> dependency.</p>

      ```java
      @Configuration
      @EnableWebMvc
      class McpConfig {
          @Bean
          WebMvcSseServerTransport webMvcSseServerTransport(ObjectMapper mapper) {
              return new WebMvcSseServerTransport(mapper, "/mcp/message");
          }

          @Bean
          RouterFunction<ServerResponse> mcpRouterFunction(WebMvcSseServerTransport transport) {
              return transport.getRouterFunction();
          }
      }
      ```

      <p>Implements the MCP HTTP with SSE transport specification, providing:</p>

      <ul>
        <li>Server-side event streaming</li>
        <li>Integration with Spring WebMVC</li>
        <li>Support for traditional web applications</li>
        <li>Synchronous operation handling</li>
      </ul>
    </>
  </Tab>

  <Tab title="SSE (Servlet)">
    <>
      <p>
        Creates a Servlet-based SSE server transport. It is included in the core <code>mcp</code> module.<br />
        The <code>HttpServletSseServerTransport</code> can be used with any Servlet container.<br />
        To use it with a Spring Web application, you can register it as a Servlet bean:
      </p>

      ```java
      @Configuration
      @EnableWebMvc
      public class McpServerConfig implements WebMvcConfigurer {

          @Bean
          public HttpServletSseServerTransport servletSseServerTransport() {
              return new HttpServletSseServerTransport(new ObjectMapper(), "/mcp/message");
          }

          @Bean
          public ServletRegistrationBean customServletBean(HttpServletSseServerTransport servlet) {
              return new ServletRegistrationBean(servlet);
          }
      }
      ```

      <p>
        Implements the MCP HTTP with SSE transport specification using the traditional Servlet API, providing:
      </p>

      <ul>
        <li>Asynchronous message handling using Servlet 6.0 async support</li>
        <li>Session management for multiple client connections</li>

        <li>
          Two types of endpoints:

          <ul>
            <li>SSE endpoint (<code>/sse</code>) for server-to-client events</li>
            <li>Message endpoint (configurable) for client-to-server requests</li>
          </ul>
        </li>

        <li>Error handling and response formatting</li>
        <li>Graceful shutdown support</li>
      </ul>
    </>
  </Tab>
</Tabs>

## Server Capabilities

The server can be configured with various capabilities:

```java
var capabilities = ServerCapabilities.builder()
    .resources(false, true)  // Resource support with list changes notifications
    .tools(true)            // Tool support with list changes notifications
    .prompts(true)          // Prompt support with list changes notifications
    .logging()              // Enable logging support (enabled by default with loging level INFO)
    .build();
```

### Logging Support

The server provides structured logging capabilities that allow sending log messages to clients with different severity levels:

```java
// Send a log message to clients
server.loggingNotification(LoggingMessageNotification.builder()
    .level(LoggingLevel.INFO)
    .logger("custom-logger")
    .data("Custom log message")
    .build());
```

Clients can control the minimum logging level they receive through the `mcpClient.setLoggingLevel(level)` request. Messages below the set level will be filtered out.
Supported logging levels (in order of increasing severity): DEBUG (0), INFO (1), NOTICE (2), WARNING (3), ERROR (4), CRITICAL (5), ALERT (6), EMERGENCY (7)

### Tool Registration

<Tabs>
  <Tab title="Sync">
    ```java
    // Sync tool registration
    var syncToolRegistration = new McpServerFeatures.SyncToolRegistration(
        new Tool("calculator", "Basic calculator", Map.of(
            "operation", "string",
            "a", "number",
            "b", "number"
        )),
        arguments -> {
            // Tool implementation
            return new CallToolResult(result, false);
        }
    );
    ```
  </Tab>

  <Tab title="Async">
    ```java
    // Async tool registration
    var asyncToolRegistration = new McpServerFeatures.AsyncToolRegistration(
        new Tool("calculator", "Basic calculator", Map.of(
            "operation", "string",
            "a", "number",
            "b", "number"
        )),
        arguments -> {
            // Tool implementation
            return Mono.just(new CallToolResult(result, false));
        }
    );
    ```
  </Tab>
</Tabs>

### Resource Registration

<Tabs>
  <Tab title="Sync">
    ```java
    // Sync resource registration
    var syncResourceRegistration = new McpServerFeatures.SyncResourceRegistration(
        new Resource("custom://resource", "name", "description", "mime-type", null),
        request -> {
            // Resource read implementation
            return new ReadResourceResult(contents);
        }
    );
    ```
  </Tab>

  <Tab title="Async">
    ```java
    // Async resource registration
    var asyncResourceRegistration = new McpServerFeatures.AsyncResourceRegistration(
        new Resource("custom://resource", "name", "description", "mime-type", null),
        request -> {
            // Resource read implementation
            return Mono.just(new ReadResourceResult(contents));
        }
    );
    ```
  </Tab>
</Tabs>

### Prompt Registration

<Tabs>
  <Tab title="Sync">
    ```java
    // Sync prompt registration
    var syncPromptRegistration = new McpServerFeatures.SyncPromptRegistration(
        new Prompt("greeting", "description", List.of(
            new PromptArgument("name", "description", true)
        )),
        request -> {
            // Prompt implementation
            return new GetPromptResult(description, messages);
        }
    );
    ```
  </Tab>

  <Tab title="Async">
    ```java
    // Async prompt registration
    var asyncPromptRegistration = new McpServerFeatures.AsyncPromptRegistration(
        new Prompt("greeting", "description", List.of(
            new PromptArgument("name", "description", true)
        )),
        request -> {
            // Prompt implementation
            return Mono.just(new GetPromptResult(description, messages));
        }
    );
    ```
  </Tab>
</Tabs>

## Error Handling

The SDK provides comprehensive error handling through the McpError class, covering protocol compatibility, transport communication, JSON-RPC messaging, tool execution, resource management, prompt handling, timeouts, and connection issues. This unified error handling approach ensures consistent and reliable error management across both synchronous and asynchronous operations.


# Building MCP with LLMs
Source: https://modelcontextprotocol.io/tutorials/building-mcp-with-llms

Speed up your MCP development using LLMs such as Claude!

This guide will help you use LLMs to help you build custom Model Context Protocol (MCP) servers and clients. We'll be focusing on Claude for this tutorial, but you can do this with any frontier LLM.

## Preparing the documentation

Before starting, gather the necessary documentation to help Claude understand MCP:

1.  Visit [https://modelcontextprotocol.io/llms-full.txt](https://modelcontextprotocol.io/llms-full.txt) and copy the full documentation text
2.  Navigate to either the [MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk) or [Python SDK repository](https://github.com/modelcontextprotocol/python-sdk)
3.  Copy the README files and other relevant documentation
4.  Paste these documents into your conversation with Claude

## Describing your server

Once you've provided the documentation, clearly describe to Claude what kind of server you want to build. Be specific about:

*   What resources your server will expose
*   What tools it will provide
*   Any prompts it should offer
*   What external systems it needs to interact with

For example:

```
Build an MCP server that:
- Connects to my company's PostgreSQL database
- Exposes table schemas as resources
- Provides tools for running read-only SQL queries
- Includes prompts for common data analysis tasks
```

## Working with Claude

When working with Claude on MCP servers:

1.  Start with the core functionality first, then iterate to add more features
2.  Ask Claude to explain any parts of the code you don't understand
3.  Request modifications or improvements as needed
4.  Have Claude help you test the server and handle edge cases

Claude can help implement all the key MCP features:

*   Resource management and exposure
*   Tool definitions and implementations
*   Prompt templates and handlers
*   Error handling and logging
*   Connection and transport setup

## Best practices

When building MCP servers with Claude:

*   Break down complex servers into smaller pieces
*   Test each component thoroughly before moving on
*   Keep security in mind - validate inputs and limit access appropriately
*   Document your code well for future maintenance
*   Follow MCP protocol specifications carefully

## Next steps

After Claude helps you build your server:

1.  Review the generated code carefully
2.  Test the server with the MCP Inspector tool
3.  Connect it to Claude.app or other MCP clients
4.  Iterate based on real usage and feedback

Remember that Claude can help you modify and improve your server as requirements change over time.

Need more guidance? Just ask Claude specific questions about implementing MCP features or troubleshooting issues that arise.

================
File: MCP-Typescript-readme.txt
================
# MCP TypeScript SDK ![NPM Version](https://img.shields.io/npm/v/%40modelcontextprotocol%2Fsdk)

TypeScript implementation of the [Model Context Protocol](https://modelcontextprotocol.io) (MCP), providing both client and server capabilities for integrating with LLM surfaces.

## Overview

The Model Context Protocol allows applications to provide context for LLMs in a standardized way, separating the concerns of providing context from the actual LLM interaction. This TypeScript SDK implements the full MCP specification, making it easy to:

- Build MCP clients that can connect to any MCP server
- Create MCP servers that expose resources, prompts and tools
- Use standard transports like stdio and SSE
- Handle all MCP protocol messages and lifecycle events

## Installation

```bash
npm install @modelcontextprotocol/sdk
```

## Quick Start

### Creating a Client

```typescript
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";

const transport = new StdioClientTransport({
  command: "path/to/server",
});

const client = new Client({
  name: "example-client",
  version: "1.0.0",
}, {
  capabilities: {}
});

await client.connect(transport);

// List available resources
const resources = await client.request(
  { method: "resources/list" },
  ListResourcesResultSchema
);

// Read a specific resource
const resourceContent = await client.request(
  {
    method: "resources/read",
    params: {
      uri: "file:///example.txt"
    }
  },
  ReadResourceResultSchema
);
```

### Creating a Server

```typescript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

const server = new Server({
  name: "example-server",
  version: "1.0.0",
}, {
  capabilities: {
    resources: {}
  }
});

server.setRequestHandler(ListResourcesRequestSchema, async () => {
  return {
    resources: [
      {
        uri: "file:///example.txt",
        name: "Example Resource",
      },
    ],
  };
});

server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
  if (request.params.uri === "file:///example.txt") {
    return {
      contents: [
        {
          uri: "file:///example.txt",
          mimeType: "text/plain",
          text: "This is the content of the example resource.",
        },
      ],
    };
  } else {
    throw new Error("Resource not found");
  }
});

const transport = new StdioServerTransport();
await server.connect(transport);
```

## Documentation

- [Model Context Protocol documentation](https://modelcontextprotocol.io)
- [MCP Specification](https://spec.modelcontextprotocol.io)
- [Example Servers](https://github.com/modelcontextprotocol/servers)

## Contributing

Issues and pull requests are welcome on GitHub at https://github.com/modelcontextprotocol/typescript-sdk.

## License

This project is licensed under the MIT Licensesee the [LICENSE](LICENSE) file for details.

================
File: package.json
================
{
  "name": "mcp-ethers-wallet",
  "version": "1.1.6",
  "description": "A Model Context Protocol server for interacting with Ethereum wallets using Ethers.js",
  "author": {
    "name": "Dennison Bertram",
    "email": "dennison@tally.xyz"
  },
  "license": "MIT",
  "homepage": "https://github.com/crazyrabbitLTC/mcp-ethers-server",
  "type": "module",
  "main": "build/index.js",
  "types": "build/index.d.ts",
  "bin": {
    "mcp-ethers-wallet": "build/index.js"
  },
  "scripts": {
    "build": "tsc",
    "prepublishOnly": "npm run build",
    "start": "node build/index.js",
    "dev": "ts-node src/index.ts",
    "test": "jest --config jest.config.cjs 'src/.*\\.ts$'",
    "test:watch": "jest --watch 'src/.*\\.ts$'"
  },
  "files": [
    "build"
  ],
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "dotenv": "^16.0.0",
    "ethers": "^6.0.0",
    "solc": "^0.8.28",
    "zod": "^3.0.0"
  },
  "devDependencies": {
    "@nomicfoundation/hardhat-toolbox": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^20.0.0",
    "hardhat": "^2.22.17",
    "jest": "^29.7.0",
    "ts-jest": "^29.2.5",
    "typescript": "^5.0.0"
  },
  "engines": {
    "node": ">=18"
  }
}

================
File: README.md
================
# MCP Ethers Wallet ![NPM Version](https://img.shields.io/npm/v/mcp-ethers-wallet)

A Model Context Protocol server for interacting with Ethereum wallets and networks using Ethers.js v6. This server provides LLMs with a standardized interface to interact with Ethereum networks, smart contracts, and wallets.

## Overview

The MCP Ethers Wallet server implements the [Model Context Protocol](https://modelcontextprotocol.io) specification, providing LLMs with tools to:

- Query blockchain data across multiple networks
- Interact with smart contracts
- Manage wallet operations
- Resolve ENS names
- Handle transactions
- Estimate gas costs
- Work with ERC20, ERC721, and ERC1155 tokens

## Installation

```bash
npm install mcp-ethers-wallet
```

## Quick Start

### Starting the Server

```typescript
import { startServer } from 'mcp-ethers-wallet';

startServer().catch((error) => {
  console.error('Failed to start server:', error);
  process.exit(1);
});
```

### Using with Claude Desktop

1. Install Claude Desktop
2. Add a new MCP server with the following configuration:
   ```json
    "ethers": {
      "command": "node",
      "args": [
        "/path-to-mcp-ethers-wallet/build/src/index.js"
      ],
      "env": {
        "ALCHEMY_API_KEY": "<<your alchemy api key>>"
      }
    }
   ```
3. The tools will now be available in your Claude conversations

### Testing with MCP Inspector

1. Install the MCP Inspector:
   ```bash
   npm install -g @modelcontextprotocol/inspector
   ```

2. Start the server:
   ```bash
   npm start
   ```

3. In another terminal, run the inspector:
   ```bash
   mcp-inspector
   ```

4. Open http://localhost:5173 in your browser to interact with the tools

## Available Tools

### Network Information
- `getSupportedNetworks`: Get a list of all supported networks and their configurations
- `getBlockNumber`: Get the current block number for a network
- `getBlockDetails`: Get detailed information about a specific block
- `getGasPrice`: Get the current gas price
- `getFeeData`: Get detailed fee data including base fee and priority fee

### Wallet Operations
- `generateWallet`: Generate a new Ethereum wallet with a random private key
- `loadWallet`: Load an existing wallet from a private key for the current session
- `checkWalletExists`: Check if a wallet is configured (without exposing private keys)
- `getWalletBalance`: Get the native token balance of a wallet
- `getWalletTransactionCount`: Get the number of transactions sent from a wallet
- `getERC20Balance`: Get the balance of an ERC20 token for a wallet

### Transaction Management
- `getTransactionDetails`: Get detailed information about a transaction
- `sendTransaction`: Send a native token transaction
- `sendTransactionWithOptions`: Send a transaction with custom options (gas, nonce, etc)
- `getTransactionsByBlock`: Get all transactions in a specific block

### Signing Operations
- `signMessage`: Sign a message using personal_sign (the recommended method)
- `ethSign`: Sign data using the legacy eth_sign method (use with caution)

### Smart Contract Interaction
- `contractCall`: Execute a contract write method
- `contractCallView`: Execute a contract read method
- `getContractCode`: Get the bytecode of a deployed contract

### ENS Operations
- `lookupAddress`: Resolve an ENS name to an address
- `resolveName`: Resolve an address to an ENS name

### ERC20 Token Operations
- `getERC20TokenInfo`: Get basic information about an ERC20 token (name, symbol, decimals, total supply)
- `getERC20Balance`: Get the token balance for an address
- `getERC20Allowance`: Get the approved amount for a spender
- `transferERC20`: Transfer tokens to a recipient
- `approveERC20`: Approve a spender to use tokens
- `transferFromERC20`: Transfer tokens from one address to another (requires approval)

### ERC721 NFT Operations
- `getERC721CollectionInfo`: Get basic information about an NFT collection
- `getERC721Owner`: Get the owner of a specific NFT
- `getERC721Metadata`: Get and parse metadata for a specific NFT
- `getERC721TokensOfOwner`: Get all NFTs owned by an address
- `transferERC721`: Transfer an NFT to a new owner
- `safeTransferERC721`: Safely transfer an NFT to a new owner

### ERC1155 Multi-Token Operations
- `getERC1155Balance`: Get token balance for a specific token ID
- `getERC1155BatchBalances`: Get token balances for multiple token IDs at once
- `getERC1155Metadata`: Get and parse metadata for a specific token
- `getERC1155TokensOfOwner`: Get all tokens owned by an address
- `safeTransferERC1155`: Safely transfer tokens to another address
- `safeBatchTransferERC1155`: Safely transfer multiple tokens in a batch

## Network Support

The server supports multiple networks including:
- Ethereum Mainnet
- Polygon PoS
- Arbitrum
- Optimism
- Base
- And more...

Use the `getSupportedNetworks` tool to get a complete list of supported networks.

## Configuration

The server can be configured using environment variables:

- `ALCHEMY_API_KEY`: Your Alchemy API key for network access
- `PRIVATE_KEY`: Private key for transaction signing (optional)
- `DEFAULT_NETWORK`: Default network to use (defaults to "mainnet")
- `LOG_LEVEL`: Logging level (error, warn, info, debug) - defaults to "info"
- `SERVER_PORT`: Port to run the server on (defaults to 3000)

### Wallet Setup

There are three ways to set up a wallet for transaction signing:

1. **Environment Variable**: Add your private key to the `.env` file:
   ```
   PRIVATE_KEY=0x123abc...
   ```

2. **Generate a New Wallet**: Use the `generateWallet` tool to create a new wallet:
   ```
   <invoke name="generateWallet">
   <parameter name="saveToEnv">true</parameter>
   </invoke>
   ```
   This will generate a new random wallet and optionally save it to the server's environment for the current session.

3. **Load an Existing Wallet**: Use the `loadWallet` tool to load a wallet from an existing private key:
   ```
   <invoke name="loadWallet">
   <parameter name="privateKey">0x123abc...</parameter>
   </invoke>
   ```
   This will load the wallet and make it available for transactions in the current session.

**Important**: Always keep your private keys secure. Never share them or commit them to version control.

## Error Handling

The server provides detailed error messages for common issues:
- Invalid network names or RPC URLs
- Chain ID mismatches
- Contract interaction failures
- Transaction errors
- Network connectivity issues
- Token-specific errors (insufficient balance, allowance, etc.)

## Caching

The server implements intelligent caching for frequently accessed data:
- Token metadata (1 hour TTL)
- Token balances (30 seconds TTL)
- Block data (10 seconds TTL)
- Transaction data (1 minute TTL)

## Rate Limiting

To prevent abuse, the server implements rate limiting for various operations:
- General operations: 120 requests per minute
- Contract calls: 60 requests per minute
- Transactions: 20 requests per minute

## Development

```bash
# Install dependencies
npm install

# Run tests
npm test

# Start in development mode
npm run dev

# Build
npm run build
```

## Contributing

Issues and pull requests are welcome on GitHub.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Author

Dennison Bertram (dennison@tally.xyz)

================
File: server.ts.backup
================
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
    CallToolRequestSchema,
    ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { EthersService } from "./services/ethersService.js";
import { DefaultProvider } from "./config/networks.js";
import { z } from "zod";
import { config } from "dotenv";
import { ethers } from "ethers";

// Import the new tool definitions and handlers
import { allTools, allHandlers } from "./tools/index.js";
import { initializeErc20Handlers } from "./tools/handlers/erc20.js";
import { initializeErc721Handlers } from "./tools/handlers/erc721.js";
import { initializeErc1155Handlers } from "./tools/handlers/erc1155.js";

config(); // Load environment variables

// Define schemas for contract calls
const contractCallSchema = z.object({
    contractAddress: z.string(),
    abi: z.union([z.string(), z.array(z.string())]),
    method: z.string(),
    methodArgs: z.array(z.any()).optional(),
    provider: z.string().optional(),
    chainId: z.number().optional()
});

const contractCallViewSchema = z.object({
    address: z.string(),
    abi: z.union([z.string(), z.array(z.string())]),
    method: z.string(),
    args: z.array(z.any()).optional(),
    provider: z.string().optional(),
    chainId: z.number().optional()
});

const server = new Server(
    {
        name: "ethers-wallet-server",
        version: "1.0.0",
    },
    {
        capabilities: {
            tools: {},
        },
    }
);

// Initialize the ethers service with configurable default network
const defaultNetworkInput = process.env.DEFAULT_NETWORK || "mainnet";
// Convert common network names to the official names used in DefaultProvider
const networkAliasMap: Record<string, DefaultProvider> = {
    "mainnet": "Ethereum",
    "ethereum": "Ethereum",
    "polygon": "Polygon PoS",
    "arbitrum": "Arbitrum",
    "optimism": "Optimism",
    "avalanche": "Avalanche C-Chain",
    "base": "Base"
};
const defaultNetwork = networkAliasMap[defaultNetworkInput.toLowerCase()] || defaultNetworkInput as DefaultProvider;

// Create provider with the correct network name
const provider = new ethers.AlchemyProvider(
    defaultNetwork === "Ethereum" ? "mainnet" : defaultNetwork.toLowerCase().replace(" ", "-"), 
    process.env.ALCHEMY_API_KEY
);
const ethersService = new EthersService(provider);

// Initialize handlers with ethersService
initializeErc20Handlers(ethersService);
initializeErc721Handlers(ethersService);
initializeErc1155Handlers(ethersService);

// Define existing tools
const existingTools = [
    {
        name: "getSupportedNetworks",
        description: "Get a list of all supported networks and their configurations. Shows which network is the default (used when no provider is specified). Call this first to discover available networks before using other network-related functions.",
        inputSchema: {
            type: "object",
            properties: {},
        },
    },
    {
        name: "generateWallet",
        description: "Generate a new Ethereum wallet with a random private key. Returns the wallet address and private key. IMPORTANT: Store the private key securely as it provides full control over the wallet.",
        inputSchema: {
            type: "object",
            properties: {
                saveToEnv: {
                    type: "boolean",
                    description: "Optional. If true, the private key will be saved to the server's environment variables for future use. Default is false.",
                },
            },
        },
    },
    {
        name: "loadWallet",
        description: "Load an existing wallet from a private key. The wallet will be used for all transactions in the current session. IMPORTANT: Transmitting private keys is a security risk. Use with caution.",
        inputSchema: {
            type: "object",
            properties: {
                privateKey: {
                    type: "string",
                    description: "The private key of the wallet to load. Should start with '0x'.",
                },
                saveToEnv: {
                    type: "boolean",
                    description: "Optional. If true, the private key will be saved to the server's environment variables for this session. Default is true.",
                },
            },
            required: ["privateKey"]
        },
    },
    {
        name: "ethSign",
        description: "Signs data using the Ethereum eth_sign method (legacy). IMPORTANT: This is less secure than signMessage as it can sign transaction-like data. Use with caution.",
        inputSchema: {
            type: "object",
            properties: {
                data: {
                    type: "string",
                    description: "The data to sign. Will be converted to hex if not already in hex format.",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
            },
            required: ["data"]
        },
    },
    {
        name: "checkWalletExists",
        description: "Check if there is a wallet configured on the server. Returns basic wallet info like address but never exposes private keys.",
        inputSchema: {
            type: "object",
            properties: {
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks. If not provided, uses the default network.",
                },
            },
        },
    },
    {
        name: "getWalletBalance",
        description: "Get the ETH balance of a wallet",
        inputSchema: {
            type: "object",
            properties: {
                address: {
                    type: "string",
                    description: "The Ethereum address to query",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
                chainId: {
                    type: "number",
                    description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
                },
            },
            required: ["address"],
        },
    },
    {
        name: "getWalletTransactionCount",
        description: "Get the number of transactions ever sent by an address",
        inputSchema: {
            type: "object",
            properties: {
                address: {
                    type: "string",
                    description: "The Ethereum address to query",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
                chainId: {
                    type: "number",
                    description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
                },
            },
            required: ["address"]
        },
    },
    {
        name: "getBlockNumber",
        description: "Get the current block number",
        inputSchema: {
            type: "object",
            properties: {
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
                chainId: {
                    type: "number",
                    description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
                },
            },
        },
    },
    {
        name: "getBlockDetails",
        description: "Get details about a block",
        inputSchema: {
            type: "object",
            properties: {
                blockTag: {
                    type: ["string", "number"],
                    description: "The block number or the string 'latest'",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
                chainId: {
                    type: "number",
                    description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
                },
            },
            required: ["blockTag"]
        },
    },
    {
        name: "getTransactionDetails",
        description: "Get details about a transaction",
        inputSchema: {
            type: "object",
            properties: {
                txHash: {
                    type: "string",
                    description: "The transaction hash to lookup",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
                chainId: {
                    type: "number",
                    description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
                },
            },
            required: ["txHash"]
        },
    },
    {
        name: "getGasPrice",
        description: "Get the current gas price",
        inputSchema: {
            type: "object",
            properties: {
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
                chainId: {
                    type: "number",
                    description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
                },
            },
        },
    },
    {
        name: "getFeeData",
        description: "Get the current network fee data",
        inputSchema: {
            type: "object",
            properties: {
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
                chainId: {
                    type: "number",
                    description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
                },
            },
        },
    },
    {
        name: "getContractCode",
        description: "Get a contract's bytecode",
        inputSchema: {
            type: "object",
            properties: {
                address: {
                    type: "string",
                    description: "The contract's address",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
                chainId: {
                    type: "number",
                    description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
                },
            },
            required: ["address"]
        },
    },
    {
        name: "lookupAddress",
        description: "Get the ENS name for an address",
        inputSchema: {
            type: "object",
            properties: {
                address: {
                    type: "string",
                    description: "The Ethereum address to resolve",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
                chainId: {
                    type: "number",
                    description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
                },
            },
            required: ["address"]
        },
    },
    {
        name: "resolveName",
        description: "Get the address for an ENS name",
        inputSchema: {
            type: "object",
            properties: {
                name: {
                    type: "string",
                    description: "The ENS name to resolve",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
                chainId: {
                    type: "number",
                    description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
                },
            },
            required: ["name"]
        },
    },
    {
        name: "formatEther",
        description: "Convert a wei value to a decimal string in ether",
        inputSchema: {
            type: "object",
            properties: {
                wei: {
                    type: "string",
                    description: "The wei value to format",
                },
            },
            required: ["wei"]
        },
    },
    {
        name: "parseEther",
        description: "Convert an ether value to wei",
        inputSchema: {
            type: "object",
            properties: {
                ether: {
                    type: "string",
                    description: "The ether value to parse",
                },
            },
            required: ["ether"]
        },
    },
    {
        name: "formatUnits",
        description: "Convert a value to a decimal string with specified units",
        inputSchema: {
            type: "object",
            properties: {
                value: {
                    type: "string",
                    description: "The value to format",
                },
                unit: {
                    type: ["string", "number"],
                    description: "The number of decimals or unit name (e.g., 'gwei', 18)",
                },
            },
            required: ["value", "unit"]
        },
    },
    {
        name: "parseUnits",
        description: "Convert a decimal string to its smallest unit representation",
        inputSchema: {
            type: "object",
            properties: {
                value: {
                    type: "string",
                    description: "The decimal string to parse",
                },
                unit: {
                    type: ["string", "number"],
                    description: "The number of decimals or unit name (e.g., 'gwei', 18)",
                },
            },
            required: ["value", "unit"]
        },
    },
    {
        name: "sendTransaction",
        description: "Send ETH from the server's wallet to a recipient",
        inputSchema: {
            type: "object",
            properties: {
                to: {
                    type: "string",
                    description: "The recipient address",
                },
                value: {
                    type: "string",
                    description: "The amount of ETH to send",
                },
                data: {
                    type: "string",
                    description: "Optional. Data to include in the transaction",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
            },
            required: ["to", "value"]
        },
    },
    {
        name: "signMessage",
        description: "Sign a message using the server's wallet",
        inputSchema: {
            type: "object",
            properties: {
                message: {
                    type: "string",
                    description: "The message to sign",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
            },
            required: ["message"]
        },
    },
    {
        name: "contractCall",
        description: "Call a view/pure method on a smart contract (read-only operations)",
        inputSchema: {
            type: "object",
            properties: {
                contractAddress: {
                    type: "string",
                    description: "The address of the contract to call",
                },
                abi: {
                    type: "string",
                    description: "The ABI of the contract as a JSON string",
                },
                method: {
                    type: "string",
                    description: "The name of the method to call",
                },
                args: {
                    type: "array",
                    description: "The arguments to pass to the method",
                    items: { type: "any" },
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
                chainId: {
                    type: "number",
                    description: "Optional. The chain ID to use for the call. If provided, will verify it matches the provider's network.",
                }
            },
            required: ["contractAddress", "abi", "method"]
        },
    },
    {
        name: "contractCallView",
        description: "Call a view/pure method on a smart contract (read-only operations)",
        inputSchema: {
            type: "object",
            properties: {
                contractAddress: {
                    type: "string",
                    description: "The address of the contract to call",
                },
                abi: {
                    type: "string",
                    description: "The ABI of the contract as a JSON string",
                },
                method: {
                    type: "string",
                    description: "The name of the method to call (must be a view/pure function)",
                },
                args: {
                    type: "array",
                    description: "The arguments to pass to the method",
                    items: { type: "any" },
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
                chainId: {
                    type: "number",
                    description: "Optional. The chain ID to use for the call. If provided, will verify it matches the provider's network.",
                }
            },
            required: ["contractAddress", "abi", "method"]
        },
    },
    {
        name: "contractCallWithEstimate",
        description: "Call a method on a smart contract with automatic gas estimation",
        inputSchema: {
            type: "object",
            properties: {
                contractAddress: {
                    type: "string",
                    description: "The address of the smart contract",
                },
                abi: {
                    type: "string",
                    description: "The ABI of the contract as a JSON string",
                },
                method: {
                    type: "string",
                    description: "The method name to invoke",
                },
                methodArgs: {
                    type: "array",
                    description: "An array of arguments to pass to the method",
                    items: {
                        type: ["string", "number", "boolean", "object"]
                    }
                },
                value: {
                    type: "string",
                    description: "Optional. The amount of ETH to send with the call",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
            },
            required: ["contractAddress", "abi", "method"]
        },
    },
    {
        name: "contractSendTransaction",
        description: "Call a method on a smart contract and send a transaction with custom parameters",
        inputSchema: {
            type: "object",
            properties: {
                contractAddress: {
                    type: "string",
                    description: "The address of the smart contract",
                },
                abi: {
                    type: "string",
                    description: "The ABI of the contract as a JSON string",
                },
                method: {
                    type: "string",
                    description: "The method name to invoke",
                },
                methodArgs: {
                    type: "array",
                    description: "An array of arguments to pass to the method",
                    items: {
                        type: ["string", "number", "boolean", "object"]
                    }
                },
                value: {
                    type: "string",
                    description: "Optional. The amount of ETH to send with the call",
                },
                gasLimit: {
                    type: "string",
                    description: "Optional. The gas limit for the transaction",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
            },
            required: ["contractAddress", "abi", "method"]
        },
    },
    {
        name: "contractSendTransactionWithEstimate",
        description: "Call a method on a smart contract and send a transaction with automatic gas estimation",
        inputSchema: {
            type: "object",
            properties: {
                contractAddress: {
                    type: "string",
                    description: "The address of the smart contract",
                },
                abi: {
                    type: "string",
                    description: "The ABI of the contract as a JSON string",
                },
                method: {
                    type: "string",
                    description: "The method name to invoke",
                },
                methodArgs: {
                    type: "array",
                    description: "An array of arguments to pass to the method",
                    items: {
                        type: ["string", "number", "boolean", "object"]
                    }
                },
                value: {
                    type: "string",
                    description: "Optional. The amount of ETH to send with the call",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
            },
            required: ["contractAddress", "abi", "method"]
        },
    },
    {
        name: "contractCallWithOverrides",
        description: "Call a method on a smart contract with advanced options",
        inputSchema: {
            type: "object",
            properties: {
                contractAddress: {
                    type: "string",
                    description: "The address of the smart contract",
                },
                abi: {
                    type: "string",
                    description: "The ABI of the contract as a JSON string",
                },
                method: {
                    type: "string",
                    description: "The method name to invoke",
                },
                methodArgs: {
                    type: "array",
                    description: "An array of arguments to pass to the method",
                    items: {
                        type: ["string", "number", "boolean", "object"]
                    }
                },
                value: {
                    type: "string",
                    description: "Optional. The amount of ETH to send with the call",
                },
                gasLimit: {
                    type: "string",
                    description: "Optional. A manual gas limit for the transaction",
                },
                gasPrice: {
                    type: "string",
                    description: "Optional. A manual gas price for legacy transactions",
                },
                nonce: {
                    type: "number",
                    description: "Optional. A manual nonce for the transaction",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
            },
            required: ["contractAddress", "abi", "method"]
        },
    },
    {
        name: "contractSendTransactionWithOverrides",
        description: "Call a method on a smart contract and send a transaction with custom parameters",
        inputSchema: {
            type: "object",
            properties: {
                contractAddress: {
                    type: "string",
                    description: "The address of the smart contract",
                },
                abi: {
                    type: "string",
                    description: "The ABI of the contract as a JSON string",
                },
                method: {
                    type: "string",
                    description: "The method name to invoke",
                },
                methodArgs: {
                    type: "array",
                    description: "An array of arguments to pass to the method",
                    items: {
                        type: ["string", "number", "boolean", "object"]
                    }
                },
                value: {
                    type: "string",
                    description: "Optional. The amount of ETH to send with the call",
                },
                gasLimit: {
                    type: "string",
                    description: "Optional. The gas limit for the transaction",
                },
                gasPrice: {
                    type: "string",
                    description: "Optional. A manual gas price for legacy transactions",
                },
                nonce: {
                    type: "number",
                    description: "Optional. A manual nonce for the transaction",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
            },
            required: ["contractAddress", "abi", "method"]
        },
    },
    {
        name: "sendRawTransaction",
        description: "Send a raw transaction",
        inputSchema: {
            type: "object",
            properties: {
                signedTransaction: {
                    type: "string",
                    description: "A fully serialized and signed transaction",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                }
            },
            required: ["signedTransaction"]
        },
    },
    {
        name: "queryLogs",
        description: "Query historical logs",
        inputSchema: {
            type: "object",
            properties: {
                address: {
                    type: "string",
                    description: "The contract address emitting the events (optional).",
                },
                topics: {
                    type: "array",
                    description: "A list of topics to filter by. Each item can be a string, null, or an array of strings (optional)",
                    items: { 
                        type: ["string", "null", "array"],
                        items: { type: "string" }
                    }
                },
                fromBlock: {
                    type: ["string", "number"],
                    description: "The starting block number (optional).",
                },
                toBlock: {
                    type: ["string", "number"],
                    description: "The ending block number (optional).",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
            },
        },
    },
    {
        name: "contractEvents",
        description: "Query historical events from a contract",
        inputSchema: {
            type: "object",
            properties: {
                contractAddress: {
                    type: "string",
                    description: "The address of the contract to query events from",
                },
                abi: {
                    type: "string",
                    description: "The ABI of the contract as a JSON string",
                },
                eventName: {
                    type: "string",
                    description: "The name of the event to look for. (Optional).",
                },
                topics: {
                    type: "array",
                    description: "A list of topics to filter by. Each item can be a string, null, or an array of strings (optional)",
                    items: { 
                        type: ["string", "null", "array"],
                        items: { type: "string" }
                    }
                },
                fromBlock: {
                    type: ["string", "number"],
                    description: "The starting block number (optional).",
                },
                toBlock: {
                    type: ["string", "number"],
                    description: "The ending block number (optional).",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
            },
            required: ["contractAddress", "abi"]
        },
    },
    {
        name: "sendTransactionWithOptions",
        description: "Send a transaction with advanced options including gas limit, gas price, and nonce",
        inputSchema: {
            type: "object",
            properties: {
                to: {
                    type: "string",
                    description: "The recipient address",
                },
                value: {
                    type: "string",
                    description: "The amount of ETH to send",
                },
                data: {
                    type: "string",
                    description: "Optional. Data to include in the transaction",
                },
                gasLimit: {
                    type: "string",
                    description: "Optional. The gas limit for the transaction",
                },
                gasPrice: {
                    type: "string",
                    description: "Optional. The gas price in gwei",
                },
                nonce: {
                    type: "number",
                    description: "Optional. The nonce to use for the transaction",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
                chainId: {
                    type: "number",
                    description: "Optional. The chain ID to use for the transaction. If provided, will verify it matches the provider's network.",
                }
            },
            required: ["to", "value"]
        },
    },
    {
        name: "getTransactionsByBlock",
        description: "Get details about transactions in a specific block.",
        inputSchema: {
            type: "object",
            properties: {
                blockTag: {
                    type: ["string", "number"],
                    description: "The block number or the string 'latest'",
                },
                provider: {
                    type: "string",
                    description: "Optional. Either a network name or custom RPC URL. Use getSupportedNetworks to get a list of supported networks.",
                },
                chainId: {
                    type: "number",
                    description: "Optional. The chain ID to use. If provided with a named network and they don't match, the RPC's chain ID will be used.",
                }
            },
            required: ["blockTag"]
        },
    },
];

// Combine all tools
const tools = [...existingTools, ...allTools];

// Define available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
    return { tools };
});

// Define existing handlers
const existingHandlers = {
    getWalletBalance: async (args: unknown) => {
        const schema = z.object({ 
            address: z.string(),
            provider: z.string().optional(),
            chainId: z.number().optional()
        });
        const { address, provider, chainId } = schema.parse(args);
        const balance = await ethersService.getBalance(address, provider, chainId);
        return {
            content: [{ type: "text", text: `The balance of ${address} is ${balance} ETH` }],
        };
    },
    
    getWalletTransactionCount: async (args: unknown) => {
        const schema = z.object({ 
            address: z.string(),
            provider: z.string().optional(),
            chainId: z.number().optional()
        });
        const { address, provider, chainId } = schema.parse(args);
        const count = await ethersService.getTransactionCount(address, provider, chainId);
        return {
            content: [{ type: "text", text: `The transaction count for ${address} is ${count}` }],
        };
    },
    
    getBlockNumber: async (args: unknown) => {
        const schema = z.object({ 
            provider: z.string().optional(),
            chainId: z.number().optional()
        });
        const { provider, chainId } = schema.parse(args);
        const blockNumber = await ethersService.getBlockNumber(provider, chainId);
        return {
            content: [{ type: "text", text: `The current block number is ${blockNumber}` }],
        };
    },
    
    getSupportedNetworks: async (args: unknown) => {
        const networks = ethersService.getSupportedNetworks();
        return {
            content: [{ type: "text", text: JSON.stringify(networks, null, 2) }],
        };
    },
    
    generateWallet: async (args: unknown) => {
        const schema = z.object({
            saveToEnv: z.boolean().optional().default(false)
        });
        
        try {
            const { saveToEnv } = schema.parse(args);
            
            // Generate a new random wallet
            const wallet = ethers.Wallet.createRandom();
            const address = wallet.address;
            const privateKey = wallet.privateKey;
            
            // If saveToEnv is true, save the private key to process.env
            // Note: This only persists for the current session
            if (saveToEnv) {
                process.env.PRIVATE_KEY = privateKey;
                
                // Update the ethersService with the new wallet
                const signer = new ethers.Wallet(privateKey, ethersService.provider);
                ethersService.setSigner(signer);
            }
            
            return {
                content: [{ 
                    type: "text", 
                    text: `New wallet generated:\n\nAddress: ${address}\nPrivate Key: ${privateKey}\n\n${
                        saveToEnv 
                            ? "The private key has been saved to the server's environment for this session. It will be used for transactions until the server restarts." 
                            : "IMPORTANT: Save this private key securely. It has NOT been saved on the server."
                    }\n\nTo use this wallet permanently, add this private key to your .env file as PRIVATE_KEY=${privateKey}`
                }]
            };
        } catch (error) {
            return {
                isError: true,
                content: [{ 
                    type: "text", 
                    text: `Error generating wallet: ${error instanceof Error ? error.message : String(error)}` 
                }]
            };
        }
    },
    
    loadWallet: async (args: unknown) => {
        const schema = z.object({
            privateKey: z.string().refine(
                (key) => key.startsWith('0x') && key.length === 66,
                { message: "Invalid private key format. Must start with '0x' and be 66 characters long." }
            ),
            saveToEnv: z.boolean().optional().default(true)
        });
        
        try {
            const { privateKey, saveToEnv } = schema.parse(args);
            
            // Create a wallet from the private key
            const wallet = new ethers.Wallet(privateKey, ethersService.provider);
            const address = wallet.address;
            
            // Set the wallet as the signer for ethersService
            ethersService.setSigner(wallet);
            
            // Optionally save to environment variables (in-memory only)
            if (saveToEnv) {
                process.env.PRIVATE_KEY = privateKey;
            }
            
            return {
                content: [{ 
                    type: "text", 
                    text: `Wallet loaded successfully!\n\nAddress: ${address}\n\nThis wallet will be used for all transactions in the current session${
                        saveToEnv ? " and has been saved to the server's environment variables for this session" : ""
                    }.\n\nIMPORTANT: The wallet will only persist until the server is restarted.`
                }]
            };
        } catch (error) {
            // Sanitize error message to ensure it doesn't contain the private key
            let errorMessage = error instanceof Error ? error.message : String(error);
            if (errorMessage.includes('0x')) {
                errorMessage = errorMessage.replace(/0x[a-fA-F0-9]{64}/g, '[PRIVATE_KEY_REDACTED]');
            }
            
            return {
                isError: true,
                content: [{ 
                    type: "text", 
                    text: `Error loading wallet: ${errorMessage}` 
                }]
            };
        }
    },
    
    checkWalletExists: async (args: unknown) => {
        const schema = z.object({
            provider: z.string().optional()
        });
        const { provider } = schema.parse(args);
        
        try {
            const walletInfo = await ethersService.getWalletInfo(provider);
            if (!walletInfo) {
                return {
                    content: [{ 
                        type: "text", 
                        text: "No wallet is currently configured on the server." 
                    }]
                };
            }
            
            return {
                content: [{ 
                    type: "text", 
                    text: `Wallet is configured with address: ${walletInfo.address}` 
                }]
            };
        } catch (error) {
            return {
                isError: true,
                content: [{ 
                    type: "text", 
                    text: `Error checking wallet: ${error instanceof Error ? error.message : String(error)}` 
                }]
            };
        }
    },
    
    getFeeData: async (args: unknown) => {
        const schema = z.object({ 
            provider: z.string().optional(),
            chainId: z.number().optional()
        });
        
        try {
            const { provider, chainId } = schema.parse(args);
            const feeData = await ethersService.getFeeData(provider, chainId);
            
            // Format the fee data in a more readable way
            const formattedFeeData = {
                gasPrice: feeData.gasPrice ? ethersService.formatUnits(feeData.gasPrice, 'gwei') + ' gwei' : null,
                maxFeePerGas: feeData.maxFeePerGas ? ethersService.formatUnits(feeData.maxFeePerGas, 'gwei') + ' gwei' : null,
                maxPriorityFeePerGas: feeData.maxPriorityFeePerGas ? ethersService.formatUnits(feeData.maxPriorityFeePerGas, 'gwei') + ' gwei' : null
            };
            
            return {
                content: [{ 
                    type: "text", 
                    text: JSON.stringify(formattedFeeData, null, 2)
                }]
            };
        } catch (error) {
            // Proper error handling according to MCP protocol
            return {
                isError: true,
                content: [{ 
                    type: "text", 
                    text: `Error getting fee data: ${error instanceof Error ? error.message : String(error)}` 
                }]
            };
        },

    getGasPrice: async (args: unknown) => {
        const schema = z.object({ 
            provider: z.string().optional(),
            chainId: z.number().optional()
        });
        
        try {
            const { provider, chainId } = schema.parse(args);
            const gasPrice = await ethersService.getGasPrice(provider, chainId);
            
            // Format the gas price in gwei for readability
            const gasPriceGwei = ethersService.formatUnits(gasPrice, 'gwei');
            
            return {
                content: [{ 
                    type: "text", 
                    text: `Current gas price: ${gasPriceGwei} gwei`
                }]
            };
        } catch (error) {
            // Proper error handling according to MCP protocol
            return {
                isError: true,
                content: [{ 
                    type: "text", 
                    text: `Error getting gas price: ${error instanceof Error ? error.message : String(error)}` 
                }]
            };
        },
    
    signMessage: async (args: unknown) => {
        const schema = z.object({ 
            message: z.string(),
            provider: z.string().optional()
        });
        
        try {
            const { message, provider } = schema.parse(args);
            
            // Check if a wallet is configured
            const walletInfo = await ethersService.getWalletInfo(provider);
            if (!walletInfo) {
                throw new Error("No wallet is configured. Please set up a wallet using loadWallet or generateWallet first.");
            }
            
            // Sign the message
            const signature = await ethersService.signMessage(message, provider);
            
            return {
                content: [{ 
                    type: "text", 
                    text: `Message signed successfully!\n\nMessage: "${message}"\nSigner: ${walletInfo.address}\nSignature: ${signature}`
                }]
            };
        } catch (error) {
            return {
                isError: true,
                content: [{ 
                    type: "text", 
                    text: `Error signing message: ${error instanceof Error ? error.message : String(error)}` 
                }]
            };
        },

    ethSign: async (args: unknown) => {
        const schema = z.object({ 
            data: z.string(),
            provider: z.string().optional()
        });
        
        try {
            const { data, provider } = schema.parse(args);
            
            // Check if a wallet is configured
            const walletInfo = await ethersService.getWalletInfo(provider);
            if (!walletInfo) {
                throw new Error("No wallet is configured. Please set up a wallet using loadWallet or generateWallet first.");
            }
            
            // Sign the data using eth_sign
            const signature = await ethersService.ethSign(data, provider);
            
            return {
                content: [{ 
                    type: "text", 
                    text: `Data signed successfully using eth_sign!\n\nData: ${data}\nSigner: ${walletInfo.address}\nSignature: ${signature}\n\nWARNING: eth_sign is a legacy signing method and less secure than personal_sign. Use with caution.`
                }]
            };
        } catch (error) {
            return {
                isError: true,
                content: [{ 
                    type: "text", 
                    text: `Error signing data with eth_sign: ${error instanceof Error ? error.message : String(error)}` 
                }]
            };
        }
    }
};

// Combine all handlers
const toolHandlers = {
    ...existingHandlers,
    ...allHandlers
};

// Handle tool calls
server.setRequestHandler(CallToolRequestSchema, async (request) => {
    const { name, arguments: args } = request.params;

    try {
        const handler = toolHandlers[name as keyof typeof toolHandlers];
        if (!handler) {
            throw new Error(`Tool not found: ${name}`);
        }
        return await handler(args);
    } catch (error: any) {
        return {
            isError: true,
            content: [{ type: "text", text: `Error processing the request: ${error.message}` }]
        };
    }
});

export async function startServer() {
    const transport = new StdioServerTransport();
    await server.connect(transport);
    console.error(`MCP server running on stdio (default network: ${defaultNetwork})`);
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "build",
    "declaration": true,
    "sourceMap": true
  },
  "include": ["src/**/*", "jest.setup.ts"],
  "exclude": ["node_modules", "build"]
}

================
File: tsconfig.node.json
================
{
  "extends": "./tsconfig.json",
  "ts-node": {
    "esm": true,
    "experimentalSpecifierResolution": "node"
  }
}
